using System;//FuncやActionを使うために必要
using System.Linq;// evsからキー名指定でインデックス番号取り出すfor文に必要（Skipなど）
using System.Collections;//IENumeratorを使う用
using System.Collections.Generic; //Listに必要
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.XR;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;
using RootMotion.FinalIK;
using DG.Tweening;//DOTween
using System.Text.RegularExpressions;
using UnityEngine.PostProcessing; //Post-processing Stackをスクリプトでいじるために必要
using UnityEngine.Rendering.PostProcessing;//PostProcessing Stack v2をスクリプトでいじるために必要
using UnityEngine.Audio;//AudioMixer使うのに必要
using System.Reflection;
using TMPro;//TextMeshPro
using System.IO;//外部ファイル読み込みなど
using UnityEditor;
using System.Text;//JSON形式に変換など？
using UnityEngine.Playables;//タイムラインを再生するコンポーネント
using UnityEngine.Timeline;//トラックやクリップの読み込みなど
using Sirenix.OdinInspector;//Odin(Dictionaryをインスペクターに表示するために必要)

public partial class DataCounter : SerializedMonoBehaviour//OdinでDictionaryをインスペクターに表示するためにMonoBehaviourから変更
{
    //[HideInInspector]
    public DataBridging DB;
    public OrderedDictionary<string, bool> staticFlagDict;

    #region テスト空間
    public bool testbool;
    public int testInt01, testInt02;
    public float testFloat01, testFloat02, testFloat03;
    public Collider testCollider01;
    public Texture testTexture01;
    public Material testMaterial01;
    public MeshRenderer testMeshRenderer01;

    public Vector3 testV3;
    public string testString01, testString02;

    #endregion

    #region シーン移動 画面フェード タイムスケール系
    [HideInInspector]
    public GameObject
        FadeCanvasObj;

    [HideInInspector]
    public FadeImage
        fadeImage;
    //↑テラシュールブログさんで作られたスクリプト。スクリプト内にmaterial、color、MaskTexture、CutoutRange全部入ってる。
    //↓こっちはただ自前でImageを置いただけ
    //SortingLayerをFadeBackにするためにQuadオブジェクトを使っている
    [HideInInspector]
    public MeshRenderer
        fadeBlackQuadMeshRenderer,
        fadeWhiteQuadMeshRenderer,
        fadeBlackUIQuadMeshRenderer,
        fadeWhiteUIQuadMeshRenderer,
        fadeBlackSmartPhoneQuadMeshRenderer,
        fadeColorQuadMeshRenderer;

    [HideInInspector]
    public Image
            fadeBlackCanvasImage;//1904再度フェード置き（今度はキャンバスでUIより前にできるはず）

    [HideInInspector]
    public float
    nowFadeEndDepthFloat;
    [HideInInspector]
    public Color
        nowFadeEndColor;

    [HideInInspector]
    public float
        renderSettingFogDensityDefFloat;

    #endregion

    #region カメラ キャラ Roomオブジェ サウンド メインスクリプト 探索用オブジェクト
    [HideInInspector]
    public Transform
        GameObjectsTrs, ServerTrs, SounderTrs, DontDestroySoundObjsTrs,
        CameraObjectsTrs, CameraAnchorTrs, CameraUserControlTrs, CameraAdjustTrackingTrs, VRCameraTrs, VRUICameraTrs, VRFadeCameraTrs,
        TPSCameraAnchorTrs, TPSCameraTrs,
        FreeCameraAnchorTrs, FreeCameraTrs,
        MessageCanvasTrs,

        Player_DummyTrs, PlayerRHandTrs, PlayerLHandTrs, PlayerRhitosashi02Trs, PlayerLhitosashi03Trs, PlayerLCalfTrs, PlayerLFootTrs,
        PlayerKubiNekkoPosObjTrs,

        GirlMeshTrs, GirlColBldMeshsTrs,
        Hair_Basic_FrontShadowOnlyTrs,
        GirlTrs, GirlPelvisTrs, GirlSpineTrs, GirlSpine1Trs, GirlHeadTrs,
        GirlRThighTrs, GirlRCalfTrs, Girlsub_knee_RTrs,
        GirlRFootTrs, GirlRToe0Trs, GirlRToe1Trs, GirlRToe2Trs, GirlRToe3Trs, GirlRToe4Trs,
        GirlRForearmTrs, GirlRUpperArmTrs,
        GirlRHandTrs, GirlRhitosashi00Trs, GirlRhitosashi02Trs, GirlRko00Trs, GirlRkusuri00Trs, GirlRnaka00Trs, GirlRoya00Trs, GirlRoya02Trs,
        GirlLThighTrs, GirlLCalfTrs, Girlsub_knee_LTrs,
        GirlLFootTrs, GirlLToe0Trs, GirlLToe1Trs, GirlLToe2Trs, GirlLToe3Trs, GirlLToe4Trs,
        GirlLForearmTrs, GirlLUpperArmTrs,
        GirlLHandTrs, GirlLhitosashi00Trs, GirlLhitosashi02Trs, GirlLko00Trs, GirlLkusuri00Trs, GirlLnaka00Trs, GirlLoya00Trs,
        GirlRToe41Trs, GirlRToe31Trs,
        GirlTang0000Trs, GirlTang0001Trs, GirlTang0002Trs, GirlTang0003Trs,
        GirlTooth00Trs, GirlTooth01Trs,

        GirlFaceLightTrs,

        sk_rootTrs,
        SeePointTrs,
        EventObjectsTrs,

    #region Room系
        RoomTrs, SotoTrs,
        DoorRootTrs, DoorTrs, ChairTrs, BedTrs,
        CarpetTrs, SchoolBagTrs,
        SpeakerTrs, GrasstableTrs, GomibakoTrs,
        YukaTrs,
        TargetsTrs, GirlIKTargetsTrs, PlayerIKTargetsTrs,
        Drill_chieriTrs,
        BunguTrs, Eiffel_hiTrs, JougiTrs,
        CalenderTrs,
        TabletTrs,
        PonyTrs,
        Particle_DustTrs,

    #endregion

    #region パラメーター系
    Sharpen_table_Room_ParameterTrs,
        Sharpen_syukudai_GirlRhitosashi02_ParameterTrs,
        Keshigomu_table_Room_ParameterTrs,
        Keshigomu_syukudai_GirlRhitosashi02_ParameterTrs,
        Keshigomu_C_Modositehosii_table_Room_ParameterTrs;

    //[HideInInspector]
    public GameObject//リソース化統一に伴い再設定 //取得はHierarchyObjLoad
        ChieriSumaho_LHand_DefPosObj,
        ChieriSumaho_LHand_BuraBuraPosObj,
        //ペットボトルは使用時に取得
        PetBottleObj = null, CapObj = null;

    public Vector3
        bunguDefPos,
        bunguDefEul,
        eiffel_hiObjDefPos,
        eiffel_hiObjDefEul,
        ponyDefPos,
        ponyDefEul,
        schoolBagDefPos,
        schoolBagDefEul;

    public Material //ポニー発光用マテリアル
        ponyDefMat,
        ponyShinyaMat;
    #endregion

    #region　ライト

    [HideInInspector]
    public GameObject LightFolder;

    //タグでデフォルト設置のライトを取得する用
    [HideInInspector]
    public List<Light> defLightList;
    [HideInInspector]
    public List<bool> defLightONOFFBoolList;
    #endregion

    [HideInInspector]
    public List<Collider> //手の届く範囲にあるコリダー(今の所未使用)
            RHandAreaContactGrapColliderList = new List<Collider>(),
            LHandAreaContactGrapColliderList = new List<Collider>();

    #region 探索用オブジェクト タグで取得（タグ切り替えでイベント対象ONOFFできるように）
    GameObject[] TansakuSeeObjColliderObjs; //子の子にあるコリダーにタグが付いているのでそれを取得
    public List<GameObject> TansakuObjList; //そこから親の親のオブジェを入れる用
    #endregion

    #region BGM SE再生時のクローン元Obj群
    [HideInInspector]
    public GameObject
        DirectBGMObj,
        OtherSEObj,
        Other3DSEObj,
        AsiotoSEObj,
        KashibakoSEObj,
        UISEObj,
        HukidashiSEObj,
        ChairSEObj,
        ClockSEObj,
        DoorSEObj,
        ChimeSEObj,
        FracturedSEObj,
        SocksSEObj,
        KO_IdouPoint3DSEObj;
    #endregion
    #region 足音 箱のSEリストなど

    public List<String>
        footStepSEStr_flooring1List = new List<string>(),
        footStepSEStr_flooring2List = new List<string>(),
        footStepSEStr_carpet1List = new List<string>(),
        footStepSEStr_BetaAsiList = new List<string>(),
        footStepSEStr_BetaAsiPicthMinus10List = new List<string>(),
        footStepSEStr_Low1List = new List<string>(),
        woodFloorCreakingSEStrList = new List<string>(),
        woodFloorCreakingPicthMinus6SEStrList = new List<string>(),
        woodFloorCreakingShortSEStrList = new List<string>(),
        woodFloorCreakingShortPicthMinus6SEStrList = new List<string>(),
        himoKishimiShortSEStrList = new List<string>(),
        kashibakoSEStrList = new List<string>(),
        KO_PlayerAsioto_DefList = new List<string>();

    #endregion

    //オフ直前
    public Transform
            Carpet02Trs,
            Combined_MeshesTrs;

    [HideInInspector]
    public GameObject
        SharpenObj, KeshigomuObj;
    public GameObject
        KeshigomuRigidObj;

    //衣装チェンジ用
    public GameObject
        Body,
        Body02,
        Mae_hair,
        Naka_hair,
        Ushiro_hair,
        PonyTail,
        //プレイヤーダミー
        Dummy_Body,
        Dummy_Hand;

    [HideInInspector]
    public Slider SeePointHitSlider;

    [HideInInspector]
    public Camera
        VRCamera, VRUICamera, VRFadeCamera,
        TPSCamera, FreeCamera;

    [HideInInspector]
    public AudioListener
        VRCameraAudioListener,
        TPSCameraAudioListener,
        FreeCameraAudioListener;

    [HideInInspector]
    public ResourceFiles
        ResourceFiles;

    //UI_SE・BGM
    [HideInInspector]
    public AudioSource sounderSEAudioSource, sounderBGMAudioSource;
    public AudioClip sounderAudioClip;
    [HideInInspector]
    public Speaker speaker;
    [HideInInspector]
    public AudioHighPassFilter speakerHighPass;
    [HideInInspector]
    public Aircon aircon;
    [HideInInspector]
    public ClockSE clockSE;
    [HideInInspector]
    public TownSE townSE;
    [HideInInspector]
    public SemiSE semiSE;

    //掴み音系
    [HideInInspector]
    public List<String>
        grapMetalStrList,
        grapHadaStrList;

    //アニメーター 表情はほぼモーフを直接いじらず モーフアニメをanimファイルにし、アニメーターステートに入れてそれを指定再生する
    [HideInInspector]
    public Animator
        girlAnim,
        playerAnim,
        doorAnim,
        chairAnim,
        saraAnim;
    //右下テキスト
    [HideInInspector]
    public Text RightUnderText, SkipPose01;
    //リソースから取得なので一旦隠さない
    public Text SubTitleText00;

    #endregion

    #region 表情 girl SkinnedMeshRendererブレンドシェイプ群
    [HideInInspector]
    public SkinnedMeshRenderer
        //Ase, Eye, EYE_def, Eyebrows_def, Tang_def, Tooth_def,
        Ase, Tere,
        Kounai_def, Mouth_def,
        EYE_def;

    //まばたきランダム用floatカウンター
    public float blinkTime;

    //照れはメッシュのフェードインアウトで
    public Material tereMaterial;
    public Color
        tereDefOnColor,
        tereOnColor,
        tereDefOffColor;

    //呼吸速度調節用
    Mebiustos.BreathController.OriBreathController
        OriBreathController;

    #endregion

    #region サイズ・ステータス系(元orig_sizechange)(Targetsなど)
    [HideInInspector]
    public Transform
        PlayerTargetTrs, PlayerEyeTargetTrs, PlayerHeadTargetTrs,


        HeadSphereTrs, BreastSphereTrs, SpineSphereTrs, PantsSphereTrs,
        RHandSphereTrs, LHandSphereTrs, RFootSphereTrs, LFootSphereTrs,
        //LFootColTrs, RFootColTrs,
        PlayerStandFeetCubeTrs;

    [HideInInspector]
    public Slider seeHeadSlider, seeBreastSlider, seeSpineSlider, seePantsSlider,
        seeRHandSlider, seeLHandSlider, seeRFootSlider, seeLFootSlider;

    [HideInInspector]
    public float seeHeadFloat, seeBreastFloat, seeSpineFloat, seePantsFloat,
        seeRHandFloat, seeLHandFloat, seeRFootFloat, seeLFootFloat;
    [HideInInspector]
    public float seeAllFloat;

    //パーセンテージ表示用
    [HideInInspector]
    public float seeHeadPercentFloat, seeBreastPercentFloat, seeSpinePercentFloat, seePantsPercentFloat,
        seeHandPercentFloat, seeFootPercentFloat;

    [HideInInspector]
    public float sizechangeRateFloat
        //        = 1.0001f;//縮小率
        = 1.0000f;//縮小率デバッグ中なのでサイズそのまま

    [HideInInspector]
    public float nowPlayerSintyouFloat, nowPlayerTaizyuuFloat;

    //プレイヤー移動スピード
    public float playerMoveSpeed = 4;

    //縮小メソッド用スイッチ 
    [HideInInspector]
    public bool isSeeShrink = true;

    //　aとbはjukesさんに調整してもらった高さ自動調整用数値（今はカメラアンカーがあるので使ってない）
    // float jukes_a = 1.15f;
    // float jukes_b;

    //[HideInInspector]
    public Vector3
        nowPlayerLocalScale, nowPlayerLocalPos, nowPlayerLocalEur, nowTrackingSpcPos,
        defPlayerLocalPos;

    #endregion

    #region Ray関係
    public Ray playerSeeRay;

    public RaycastHit
        playerSeeHomeWorkRayHit,
        playerSeeSmartPhoneRayHit,
        sentakushiRayHit;

    [HideInInspector]
    public LayerMask
        seeRayBlockLayerMask,
        seeRaySentakushiLayerMask,
        AN_GrapLayerMask,
        AN_GrapSupportLayerMask;

    #endregion

    #region FinalIK
    public FullBodyBipedIK FBBIK;//FullBodyBipedIK
    public LookAtIK LAIKBody, LAIKEye, LAIKHead;//LookAtIK
    public CCDIK CCDIKRHand, CCDIKLHand;

    //オリジナルのターゲット群
    [HideInInspector]
    public Transform
        IKLookAtHeadTargetTrs, IKLookAtEyeTargetTrs, IKLookAtBodyTargetTrs,
        IKBodyTargetTrs,
        IKLHandTargetTrs, IKLShoulderTargetTrs,
        IKRHandTargetTrs, IKRShoulderTargetTrs,
        IKLFootTargetTrs, IKLThighTargetTrs,
        IKRFootTargetTrs, IKRThighTargetTrs,
        CCDIKRHandTargetTrs, CCDIKLHandTargetTrs,

        //割り当てるIKボーン群
        Bip001Trs,
        Bip001NeckTrs, Bip001HeadTrs,
        Bip001PelvisTrs, Bip001Spine, Bip001Spine1,
        joint_L_eye00Trs, joint_R_eye00Trs,
        Bip001_R_UpperArmTrs, Bip001_R_ForearmTrs, Bip001_R_HandTrs,
        Bip001_L_UpperArmTrs, Bip001_L_ForearmTrs, Bip001_L_HandTrs;

    #region//略群
    //FBBIK
    [HideInInspector]
    public IKEffector
        IKBodyEf,
        IKLHandEf, IKLShoulderEf,
        IKRHandEf, IKRShoulderEf,
        IKLFootEf, IKLThighEf,
        IKRFootEf, IKRThighEf;

    //LAIK
    public IKSolverLookAt
        LAIKHeadS, LAIKEyeS, LAIKBodyS;

    //CCDIK
    private IKSolverCCD.Bone
       CCDIKRUpperArmSBone, CCDIKRForearmSBone, CCDIKRHandSBone,
       CCDIKLUpperArmSBone, CCDIKLForearmSBone, CCDIKLHandSBone;

    #endregion

    //目と頭のLookAtWeight初期値
    [HideInInspector]
    public float
        LAIKSEyesDefWeight,
        LAIKSHeadDefWeight;

    #endregion

    #region PlayerFinalIK
    public FullBodyBipedIK PlayerFBBIK;//FullBodyBipedIK
    public LookAtIK PlayerLAIKBody, PlayerLAIKEye, PlayerLAIKHead;//LookAtIK
    public CCDIK PlayerCCDIKRHand, PlayerCCDIKLHand;

    //オリジナルのターゲット群
    [HideInInspector]
    public Transform
        PlayerIKLookAtHeadTargetTrs, PlayerIKLookAtEyeTargetTrs, PlayerIKLookAtBodyTargetTrs,
        PlayerIKBodyTargetTrs,
        PlayerIKLHandTargetTrs, PlayerIKLShoulderTargetTrs,
        PlayerIKRHandTargetTrs, PlayerIKRShoulderTargetTrs,
        PlayerIKLFootTargetTrs, PlayerIKLThighTargetTrs,
        PlayerIKRFootTargetTrs, PlayerIKRThighTargetTrs,
        PlayerCCDIKRHandTargetTrs, PlayerCCDIKLHandTargetTrs,

    //割り当てるIKボーン群
        Bip002HeadTrs,
        Bip002PelvisTrs, Bip002Spine, Bip002Spine1,
        tempREyeTrs, tempLEyeTrs,
        Bip002_R_UpperArmTrs, Bip002_R_ForearmTrs, Bip002_R_HandTrs,
        Bip002_L_UpperArmTrs, Bip002_L_ForearmTrs, Bip002_L_HandTrs;

    #region//略群
    //FBBIK
    private IKEffector
        PlayerIKBodyEf,
        PlayerIKLHandEf, PlayerIKLShoulderEf,
        PlayerIKRHandEf, PlayerIKRShoulderEf,
        PlayerIKLFootEf, PlayerIKLThighEf,
        PlayerIKRFootEf, PlayerIKRThighEf;

    //LAIK
    private IKSolverLookAt
        PlayerLAIKHeadS, PlayerLAIKEyeS, PlayerLAIKBodyS;

    //CCDIK
    private IKSolverCCD.Bone
       PlayerCCDIKRUpperArmSBone, PlayerCCDIKRForearmSBone, PlayerCCDIKRHandSBone,
       PlayerCCDIKLUpperArmSBone, PlayerCCDIKLForearmSBone, PlayerCCDIKLHandSBone;

    #endregion

    //目と頭のLookAtWeight初期値
    [HideInInspector]
    public float
        PlayerLAIKSEyesDefWeight,
        PlayerLAIKSHeadDefWeight;

    //■■プレイヤー専用
    [HideInInspector]
    public GameObject //■頭に追従用FinalIKスクリプト の入ったObj（VRカメラにペアレントされている）
        PlayerFBBIKHeadEffectorObj,
        //↑からの追従情報を受け取って、FBBIKで操作する、PlayerBipedの親Obj（子にPlayerBiped本体がいる）
        PlayerFBBIKtoHeadEffectorObj;

    [HideInInspector]
    bool //FPS時にプレイヤーの手や体を例外で表示するとき用
        isDummyHandVis = false,
        isDummyBodyVis = false;


    #endregion

    #region TimeLine

    /*現状の動作方法説明
 Genericタイプの「OrderedDictionary」を実装（サイトからコピペして実装できた）
非GenericのOrderedDictionaryはobjで型を入れなきゃいけなくてうまく動かないので（Actionが動かない）

Actionを使うためにusing:System
Actionはdelgateというメソッドをカプセル化（変数として扱える？）する機能の省略表記版（ラムダ式？）

先述のジェネリックOrderedDictionaryに"イベント名"とActionでメソッドを入れておくことで
・追加順にインデックス
・イベント名がキー名
・そのままメソッドが書ける
という状態。

        ●コルーチン導入につき注意点
        コルーチン実行時にnowRunCoroutineに実行中コルーチンを代入しておいて、デバッグ移動時などにストップする。

    */

    public OrderedDictionary<string, Action> evs = new OrderedDictionary<string, Action>();

    //イベント移動用bool(初期化が終るまでイベント走らないように)
    [HideInInspector]
    public bool isEvRun = false;

    [SerializeField, Range(0, 5), HeaderAttribute("タイムスケール")]
    public float timeScale;
    private bool eventMoveFlag = true, debugEventMoveFlag = false;

    //デバッグ用にイベント名とアニメクリップ名表示用
    [HideInInspector]
    public Text
        EvNameText,
        AnimClipNameText;

    //分岐待機用の変数群
    #region //bunkiTaikiBoolメモ抽出
    //    //説明の途中で宿題見ても良いようにboolON
    //    bunkiTaikiBool01 = true;

    //            //コリダーから外れたら落ちる発動
    //            if (playerTargetOnTriggerExitBool == true && bunkiTaikiBool01 == false)

    //            //ランダムで消しゴム等のモーション（falseの間）
    //            if (bunkiTaikiBool01 == false)
    //            { SyukudaiTaiki();
    //}

    ////中断用の変数群 初期化
    //bunkiTaikiBool01 = false;//スカート覗いた時用（コルーチン切り替え）

    //                bunkiTaikiBool02 = false;//スカートイベント終了時用
    #endregion //bunkiTaikiBoolメモ抽出
    public bool
        bunkiTaikiBool01,
        bunkiTaikiBool02;
    public float
        bunkiTaikiFloat01;

    //コルーチンイベント進行用
    private IEnumerator nowRunEvIEnumerator;
    private Coroutine
        nowRunEvCoroutine,
        evTempCoroutine;

    //イベントを跨ぐ変数群
    public bool
        bunkiHwSkipBool01,
        bunkiHwSkipBool02,
        bunkiGaugeTutorialFlagBool,
        isSkirtAngry01;

    //イベントを跨ぐコルーチン用
    public Coroutine evSpanTempCoroutine01;

    //選択肢番号取得用int(0も選択肢番号なので99を初期値とする)
    [HideInInspector]
    public int sentakuListNum = 99;

    #endregion

    #region 着替え系
    public Material
        mat_body,//デフォルトのちえりBodyメッシュマテリアル
        mat_body_Barefoot,//素足用のちえりBodyメッシュマテリアル
        mat_body_TankTop,//一時的に取得
        mat_body_TankTop_Barefoot,//一時的に取得
        mat_body_Bikini;//一時的に取得

    public GameObject
        BodyObj,//ちえりのBodyメッシュObj
        SocksObj;//靴下のメッシュObj


    #endregion

    #region 仮想ボタン（OculusTouchなどでトリガーAxisを決定ボタンにする用）(Viveでの同時押しカメラリセット)（ControllerAutoInitializeSystemにある）
    public bool
    //決定ボタン
        isKetteiDown = false,
        isKetteiUp = false,
        isKettei = false,
    //切り替えバックボタン
        isBackDown = false,
        isBackUp = false,
        isBack = false,
    //メニュー ポーズボタン
        isMenuPauseDown = false,
        isMenuPauseUp = false,
        isMenuPause = false,
    //カメラリセットボタン
        isCameraResetDown = false,
    //カメラリセットボタン
        isVivePadDown = false,
        isVivePadUp = false,
        isVivePad = false;

    public float //Axis系
        cameraStickAxisX,
        cameraStickAxisY,
        sentakuAxisX,
        sentakuAxisY;


    #endregion

    UTJ.SpringManager //SpringManager取得（スカートなどの揺れモノのスクリプト）
        skirtSpringManager;


    #region □独立システムテンプレ
    //#region 変数
    //bool
    //isSystem = false;

    //#endregion

    //IEnumerator SystemIEnum()
    //{
    //    if (isSystem) { yield break; }
    //    isSystem = true;
    //    List<GameObject> exitDestroyObjList = new List<GameObject>();

    //    #region ■■■初期化
    //    #endregion

    //    #region ■■■ループ
    //    while (isSystem)
    //    {
    //        yield return null;
    //    }
    //    #endregion

    //    #region ■■■終了処理
    //    for (int i = 0; i < exitDestroyObjList.Count; i++)
    //    { Destroy(exitDestroyObjList[i]); }
    //    exitDestroyObjList.Clear();
    //    #endregion
    //    yield break;
    //}


    #endregion

    #region ■言語システム※構築中 今はUIのEnglish書き換えるのみ
    #region 変数
    bool
        isLanguageSystem = false;

    public List<string>
        engMiscKeys,
        engMiscValues;
    public Dictionary<string, string>
        engMiscDict = new Dictionary<string, string>();

    #endregion

    IEnumerator LanguageSystemIEnum()
    {
        if (isLanguageSystem) { yield break; }
        isLanguageSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        #region テキスト読み込みDictionary化
        //■まず「＊改行」区切りで全部配列に読み込み
        //StreamingAssets読み込みテスト
        string tmpStr
            = File.ReadAllText(Application.streamingAssetsPath + "/Text/EnglishMisc.txt", Encoding.UTF8);
        string[]
            tmpEngMiscDataArray = tmpStr.Split(new string[] { "＊\r\n" }, StringSplitOptions.None);

        //全角の＠がついているものはKey扱い
        foreach (string j in tmpEngMiscDataArray)
        {
            if (j.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
            {
                engMiscKeys.Add(j.Remove(0, 1));//先頭1文字（全角＠）を消したうえでAdd
            }

        }

        //全角の＠がついていないものはValue（本文）
        foreach (string j in tmpEngMiscDataArray)
        {
            if (j.IndexOf("＠") == 0 || j.IndexOf("//") == 0)
            {
                continue;//「＠」と「//」がついてたら次のループへ
            }

            engMiscValues.Add(j);
        }

        //Dictionaryに代入
        for (int i = 0; i < engMiscKeys.Count; i++)
        {
            engMiscDict[engMiscKeys[i]] = engMiscValues[i];
        }
        #endregion


        #endregion

        //今はループしない
        isLanguageSystem = false;

        #region ■■■ループ
        while (isLanguageSystem)
        {
            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }


    #endregion

    #region ■選択システムリメイク

    #region 変数
    bool
    isSelectSystem = false;

    #endregion

    IEnumerator SelectSystemIEnum(GameObject SelectRootObj, int firstSelectNum = 0)
    {
        if (isSelectSystem) { yield break; }
        isSelectSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        //渡されたRootObjの直下ObjをListで取得
        List<GameObject> selectObjList = new List<GameObject>();
        foreach (Transform trs in SelectRootObj.transform)
        {
            selectObjList.Add(trs.gameObject);
        }

        int
            prevSelectNum = -1,//初期選択演出入れる用に-1（nowと同じじゃなきゃなんでもよし）
            nowSelectNum = firstSelectNum;//選択状態

        //選択上下Axis用
        bool
            isUp = false,
            isDown = false;



        #endregion

        #region ■■■ループ
        while (isSelectSystem && SelectRootObj != null)
        {
            if (isMenuSystem == false)//メニュー時無効
            {
                #region 上下入力ボタンダウン化しint1ずつ操作

                //コントローラー
                if (isUp == false && sentakuAxisY > 0.3f)//元 ==1
                {
                    nowSelectNum--;
                    isUp = true;
                }
                if (isDown == false && sentakuAxisY < -0.3f)//元 ==-1
                {
                    nowSelectNum++;
                    isUp = true;
                }

                //マウスホイール
                if (isUp == false && mouseWheelFloat > 0)
                {
                    nowSelectNum--;
                    isUp = true;
                }
                if (isDown == false && mouseWheelFloat < 0)
                {
                    nowSelectNum++;
                    isDown = true;
                }

                //両方とも押されてなければbollをfalse
                if (sentakuAxisY == 0f && sentakuAxisY == 0f && mouseWheelFloat == 0)
                {
                    isUp = isDown = false;
                }

                //選択肢の数の間でのみint上下
                nowSelectNum = Mathf.Clamp(nowSelectNum, 0, selectObjList.Count - 1);
                #endregion

                #region 選択ナンバー動いた演出
                if (prevSelectNum != nowSelectNum)
                {
                    for (int i = 0; i < selectObjList.Count; i++)
                    {
                        //該当の枠だけON
                        if (i == nowSelectNum)
                        {
                            SEPlay(UISEObj, "UI_pin");
                            selectObjList[i].transform.GetChild(0).gameObject.SetActive(true);
                        }
                        else
                        {
                            //他 全部オフ
                            selectObjList[i].transform.GetChild(0).gameObject.SetActive(false);
                        }
                    }
                }
                #endregion

                prevSelectNum = nowSelectNum;

                #region 決定
                if (isKetteiDown)
                {
                    #region 演出
                    //決定音
                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");

                    #region フラッシング
                    for (int i = 0; i < 4; i++)
                    {
                        selectObjList[nowSelectNum].transform.GetChild(0).gameObject.SetActive(false);
                        yield return new WaitForSeconds(0.04f);
                        selectObjList[nowSelectNum].transform.GetChild(0).gameObject.SetActive(true);
                        yield return new WaitForSeconds(0.04f);
                    }
                    #endregion

                    #endregion

                    //選択した番号をTimeLineに送信して終了
                    sentakuListNum = nowSelectNum;
                    isSelectSystem = false;
                }
                #endregion
            }
            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }


    #endregion

    #region ■TPSカメラシステム

    #region 変数
    bool
        isTPSCameraSystem = false;

    bool
        isTPSOneCameraView = false,
        isTPSTwoCameraView = false,
        isTPSOffCameraView = true;

    public int
        tPSModeInt = 0;
    public float
        tPSCameraMoveSpeed = 1;
    #endregion

    IEnumerator TPSCameraSystemIEnum()
    {
        if (isTPSCameraSystem) { yield break; }
        isTPSCameraSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region 初期化

        Vector3 //TPSカメラPos代入用(操作は別モードになる予定なので、今はデバッグ状態)
            tmpTPSCameraPos = TPSCameraAnchorTrs.localPosition;


        //bool //小人スケールかどうか
        //    isScaleView = true;

        int //tPSModeIntの変更を取得して、そのタイミングで変更処理
            prevTPSModeInt = -1; //初回処理用に初期値-1

        GameObject
            TPSMode1PosObj = Resources.Load("EventSystem/TPSCamera/PosObj/TPSMode1PosObj") as GameObject,
            TPSMode2PosObj = Resources.Load("EventSystem/TPSCamera/PosObj/TPSMode2PosObj") as GameObject;
        #endregion

        #region ループ
        while (isTPSCameraSystem)
        {
            //■カメラ切り替え(直接Intを書き換えても変わる。Tキーを押すと順繰りに変わる)
            //カメラ切り替えキー、TキーでTPSカメラモードのInt増やす
            if (Input.GetButtonDown(DB.inputDict["カメラ切り替え"]) ||
                Input.GetKeyDown(KeyCode.T))
            {
                tPSModeInt++;
                //最大値越えたら0に戻す
                if (tPSModeInt > 2) { tPSModeInt = 0; }
            }

            //前フレームとModeInt変わったら
            if (tPSModeInt != prevTPSModeInt)
            {
                prevTPSModeInt = tPSModeInt;

                //0はTPSオフ（FPS）
                if (tPSModeInt == 0)
                {
                    //ONにした瞬間出てしまうのでメニュー非表示時のみ
                    if (isMenuSystem == false) { SubTitleVis(true, "□FPS MODE", 0.2f, true); }

                    TPSCamera.enabled = false;
                    //VR時はカメラリセット挟む
                    if (XRSettings.enabled) { CameraReset(null, null, true); }

                    //FreeCamera時はFreeCameraのONOFF
                    if (isFreeCameraModeSystem) { FreeCamera.enabled = true; }
                    else { VRCamera.enabled = true; }

                    //FreeCamera時は ほかのTPS時と同じく出しておく
                    if (isFreeCameraModeSystem)
                    {
                        //モデル表示
                        Dummy_Body.SetActive(true);
                        Dummy_Hand.SetActive(false);
                    }
                    else//TPSのみなら、普通FPS視点時は元の非表示
                    {
                        //モデル非表示
                        if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }

                        //通常時にONかOFFか判定に従って ONOFF
                        if (isDummyHandVis) { Dummy_Hand.SetActive(true); }
                        else { Dummy_Hand.SetActive(false); }

                        //登り時にONかOFFか判定に従って ONOFF
                        if (isANSystem == false)
                        { if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }
                    }



                }
                else if (tPSModeInt == 1)
                {
                    SubTitleVis(true, "■TPS MODE=1", 0.2f, true);

                    //FreeCamera時はFreeCameraのONOFF
                    if (isFreeCameraModeSystem) { FreeCamera.enabled = false; }
                    else { VRCamera.enabled = false; }
                    //VR時はカメラリセット挟む
                    if (XRSettings.enabled) { CameraReset(null, null, true); }

                    TPSCamera.enabled = true;
                    TPSCameraAnchorTrs.localPosition
                        = TPSMode1PosObj.transform.localPosition;

                    //モデル表示
                    Dummy_Body.SetActive(true);
                    Dummy_Hand.SetActive(false);
                }
                else if (tPSModeInt == 2)
                {
                    SubTitleVis(true, "■TPS MODE=2", 0.2f, true);
                    //FreeCamera時はFreeCameraのONOFF
                    if (isFreeCameraModeSystem) { FreeCamera.enabled = false; }
                    else { VRCamera.enabled = false; }
                    //VR時はカメラリセット挟む
                    if (XRSettings.enabled) { CameraReset(null, null, true); }

                    TPSCamera.enabled = true;
                    TPSCameraAnchorTrs.localPosition
                        = TPSMode2PosObj.transform.localPosition;

                    //モデル表示
                    Dummy_Body.SetActive(true);
                    Dummy_Hand.SetActive(false);
                }

            }

            #region //TPSカメラ時ズームロング 、小人スケールONOFF
            //if (TPSCamera.enabled)
            //{
            //    if (Input.GetKey(KeyCode.UpArrow))
            //    {
            //        tmpTPSCameraPos.y += tPSCameraMoveSpeed * Time.deltaTime;
            //        TPSCameraAnchorTrs.localPosition = tmpTPSCameraPos;
            //    }
            //    if (Input.GetKey(KeyCode.DownArrow))
            //    {
            //        tmpTPSCameraPos.y -= tPSCameraMoveSpeed * Time.deltaTime;
            //        TPSCameraAnchorTrs.localPosition = tmpTPSCameraPos;
            //    }
            //    if (Input.GetKey(KeyCode.LeftArrow))
            //    {
            //        tmpTPSCameraPos.z += tPSCameraMoveSpeed * Time.deltaTime;
            //        TPSCameraAnchorTrs.localPosition = tmpTPSCameraPos;
            //    }
            //    if (Input.GetKey(KeyCode.RightArrow))
            //    {
            //        tmpTPSCameraPos.z -= tPSCameraMoveSpeed * Time.deltaTime;
            //        TPSCameraAnchorTrs.localPosition = tmpTPSCameraPos;
            //    }

            //    #region //小人視点と1倍視点切り替え（プレイヤー近すぎてピント合わせられないので、やるなら別アプローチ必要）
            //    //if (Input.GetKeyDown(KeyCode.Y))
            //    //{
            //    //    if (isScaleView) { isScaleView = false; }
            //    //    else { isScaleView = true; }
            //    //}

            //    //if (isScaleView)
            //    //{
            //    //    //縮小視点
            //    //    TPSCameraTrs.localScale = Vector3.one;
            //    //}
            //    //else
            //    //{
            //    //    //1倍サイズ視点
            //    //    TPSCameraTrs.localScale
            //    //        = new Vector3(1 / nowPlayerLocalScale.x, 1 / nowPlayerLocalScale.y, 1 / nowPlayerLocalScale.z);
            //    //}
            //    #endregion

            //}
            #endregion


            yield return null;
        }
        #endregion

        #region 終了処理

        #region TPS=0と同じ処理
        TPSCamera.enabled = false;

        //FreeCamera時はFreeCameraのONOFF
        if (isFreeCameraModeSystem) { FreeCamera.enabled = true; }
        else { VRCamera.enabled = true; }
        //モデル非表示
        if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }
        //通常時にONかOFFか
        if (isDummyHandVis) { Dummy_Hand.SetActive(true); }
        else { Dummy_Hand.SetActive(false); }

        //登り時にONかOFFか
        if (isANSystem == false)
        { if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }
        #endregion


        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        #endregion
        yield break;
    }


    #endregion
    #region ■FREECameraMODEシステム

    #region 変数
    bool
        isFreeCameraModeSystem = false,
        isFreeCameraSetumeiWait = false;
    #endregion

    IEnumerator FreeCameraModeSystemIEnum()
    {
        if (isFreeCameraModeSystem) { yield break; }
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        //説明画面表示中はオンオフできないように
        isFreeCameraSetumeiWait = true;

        #region 操作説明 表示
        GameObject SousaSetumeiFreeCameraWindowCanvas;
        if (DB.isEnglish)
        {
            SousaSetumeiFreeCameraWindowCanvas
                = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiFreeCameraEngWindowCanvas") as GameObject
                , VRCameraTrs, false);
        }
        else
        {
            SousaSetumeiFreeCameraWindowCanvas
                = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiFreeCameraWindowCanvas") as GameObject
                , VRCameraTrs, false);
        }

        FadeBlack(0.5f, 0.5f);

        ////すぐ飛ばさないようためしにウェイト
        //yield return new WaitForSeconds(1);

        while (isKetteiDown == false)
        {
            yield return null;
        }

        FadeBlack(0, 0.5f);
        Destroy(SousaSetumeiFreeCameraWindowCanvas);

        #endregion

        isFreeCameraModeSystem = true;
        isFreeCameraSetumeiWait = false;

        SubTitleVis(true, "■FreeCameraMODE ON", 0.2f, true);

        #region ■■■初期化

        //ひとまずデバッグオフ
        DB.isDebugMode =
        DB.isSkipMode = false;
        ////顔埋まりオフ
        //isVRBlockSystem = false;

        //カメラ設定
        VRCamera.enabled = false;
        FreeCamera.enabled = true;
        FreeCameraAnchorTrs.SetParent(GameObjectsTrs);

        //カメラ同じ位置に
        FreeCameraAnchorTrs.position = VRCameraTrs.position;

        //モデル表示
        Dummy_Body.SetActive(true);
        Dummy_Hand.SetActive(false);
        #endregion

        yield return null;

        #region ローカル変数
        //プレイヤー移動用
        Vector3 velocity;

        //マコトONOFF
        bool isMakotoVis = true;
        #endregion

        #region ■■■ループ
        while (isFreeCameraModeSystem)
        {
            //カメラ Userカメラと同じ回転
            FreeCameraAnchorTrs.eulerAngles = CameraUserControlTrs.eulerAngles;
            //VRCameraと同じスケール
            FreeCameraAnchorTrs.localScale = VRCameraTrs.lossyScale / GameObjectsTrs.localScale.z;
            #region プレイヤー移動

            // WASD入力から、XZ平面(水平な地面)を移動する方向(velocity)を得ます
            velocity = Vector3.zero;
            if (Input.GetKey(KeyCode.W))
                velocity.z += 1;
            if (Input.GetKey(KeyCode.A))
                velocity.x -= 1;
            if (Input.GetKey(KeyCode.S))
                velocity.z -= 1;
            if (Input.GetKey(KeyCode.D))
                velocity.x += 1;

            #region moveSpeed調整

            float moveSpeed = 400f * nowPlayerLocalScale.z;// 移動速度

            if (Input.GetKey(KeyCode.LeftShift))
            { moveSpeed *= 5; }
            else if (Input.GetKey(KeyCode.LeftControl))
            { moveSpeed /= 20; }
            #endregion

            // 速度ベクトルの長さを1秒でmoveSpeedだけ進むように調整します
            velocity = velocity.normalized * moveSpeed * Time.unscaledDeltaTime;

            // いずれかの方向に移動している場合
            if (velocity.magnitude > 0)
            {
                //※カメラの水平回転のみをQuaternionで取得 （XとZは0にし、CameraObjectsTrsのEulのY　と　userCameraControlEulのYを足している↓）
                var camRotOnlyY = Quaternion.Euler(0, FreeCameraTrs.localEulerAngles.y + CameraUserControlTrs.eulerAngles.y, 0);
                //移動方向(velocity)を足し込みます
                FreeCameraAnchorTrs.position += camRotOnlyY * velocity;
            }


            #region 高さ移動

            if (Input.GetKey(KeyCode.Q))
            {
                FreeCameraAnchorTrs.position += new Vector3(0, -0.015f, 0) * moveSpeed;
            }
            if (Input.GetKey(KeyCode.E))
            {
                FreeCameraAnchorTrs.position += new Vector3(0, 0.015f, 0) * moveSpeed;
            }

            #endregion


            #endregion

            //プレイヤーカメラ位置リセット
            if (isCameraResetDown || Input.GetKeyDown(KeyCode.C)) //ひとまずキーボードではC
            { FreeCameraAnchorTrs.position = VRCameraTrs.position; }

            #region マコトの表示ONOFF
            if (Input.GetKeyDown(KeyCode.Z))
            {
                if (isMakotoVis)
                {
                    isMakotoVis = false;
                    //モデル表示
                    Dummy_Body.SetActive(false);
                }
                else
                {
                    isMakotoVis = true;
                    //モデル表示
                    Dummy_Body.SetActive(true);
                }
            }

            #endregion





            #region 最後に部屋4隅の座標より外に出ないようClamp
            Vector3 newPos = FreeCameraAnchorTrs.position;

            newPos.x = Mathf.Clamp(newPos.x, -396, 145);
            newPos.y = Mathf.Clamp(newPos.y, 0.1f, 239);
            newPos.z = Mathf.Clamp(newPos.z, 1, 283);

            FreeCameraAnchorTrs.position = newPos;

            #endregion

            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();


        //カメラ設定
        VRCamera.enabled = true;
        FreeCamera.enabled = false;
        FreeCameraAnchorTrs.SetParent(VRCameraTrs);

        //ゼロ位置回転に
        FreeCameraAnchorTrs.localPosition = FreeCameraAnchorTrs.localEulerAngles = Vector3.zero;
        //スケール1に
        FreeCameraAnchorTrs.localScale = Vector3.one;

        //FPS表示時ならモデル表示オフ
        if (tPSModeInt == 0)
        {
            //モデル非表示
            if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }

            //通常時にONかOFFか判定に従って ONOFF
            if (isDummyHandVis) { Dummy_Hand.SetActive(true); }
            else { Dummy_Hand.SetActive(false); }

            //登り時にONかOFFか判定に従って ONOFF
            if (isANSystem == false)
            { if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }
        }

        #endregion

        SubTitleVis(true, "□FreeCameraMODE OFF", 0.2f, true);
        yield break;
    }


    #endregion
    #region ■プレイヤーの立ちと座りをboolとメソッドで切り替え
    public bool
        nowPlayerStand = false;
    //メソッドだと値が変わるので注意
    void ChangeStand(bool forceStand = false)
    {
        if (nowPlayerStand == false || forceStand)
        {
            nowPlayerStand = true;
            CameraAnchorTrs.localPosition
                = new Vector3(
                    CameraAnchorTrs.localPosition.x
                    , DB.cameraStandAnchorDefLocalPos.y
                    , CameraAnchorTrs.localPosition.z);
        }
        else
        {
            nowPlayerStand = false;
            CameraAnchorTrs.localPosition
                = new Vector3(
                    CameraAnchorTrs.localPosition.x
                    , DB.cameraSitAnchorDefLocalPos.y
                    , CameraAnchorTrs.localPosition.z);
        }


    }
    #endregion

    #region ■プレイヤー倒れコルーチン（Timeline用にためしに）
    #region 変数
    public bool
        isPlayerFallDownSystem = false;
    public Vector3
        playerFallDownDefCameraAnchorPos,
        playerFallDownDefCameraAnchorEul,
        playerFallDownFlowCameraAnchorPos,
        playerFallDownSlipCameraAnchorPos,
        playerFallDownSlipCameraAnchorEul;

    #endregion

    public IEnumerator PlayerFallDownSystemIEnum()
    {
        if (isPlayerFallDownSystem) { yield break; }
        isPlayerFallDownSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化

        //TPSプレイヤー倒れモーション
        isPlayerUniqueMotion = true;
        PlayerMotion("liedown_00_Re", 0.2f, 0);

        playerFallDownDefCameraAnchorPos = CameraAnchorTrs.localPosition;
        playerFallDownDefCameraAnchorEul = CameraAnchorTrs.localEulerAngles;
        playerFallDownSlipCameraAnchorPos = new Vector3(0, 0.1f, -0.7f);
        playerFallDownSlipCameraAnchorEul = new Vector3(-90, 0, 0);

        CameraAnchorTrs.DOLocalMove(playerFallDownSlipCameraAnchorPos, 0.5f).SetEase(Ease.OutBounce);
        yield return new WaitForSeconds(0.05f);
        CameraAnchorTrs.DOLocalRotate(playerFallDownSlipCameraAnchorEul, 0.05f);
        yield return new WaitForSeconds(0.05f);

        CameraAnchorTrs.DOLocalRotate(playerFallDownSlipCameraAnchorEul, 0.2f).SetEase(Ease.InSine);
        CameraAnchorTrs.DOLocalMove(playerFallDownSlipCameraAnchorPos, 0.5f).SetEase(Ease.OutBounce)
            .OnComplete(() =>
            {
                //カメラリセット（+回転と立ち設定）
                //カメラリセット値変更してリセット
                CameraReset(null
                        , playerFallDownSlipCameraAnchorPos
                        , false
                        , playerFallDownSlipCameraAnchorEul //Anchorを転んだ回転に
                        , false
                        , false//ユーザーカメラはリセットしない 
                        );
            });

        #endregion

        #region ■■■ループ
        while (isPlayerFallDownSystem)
        {
            yield return null;
        }
        #endregion

        #region ■■■終了処理
        //倒れカメラ戻し
        isPlayerUniqueMotion = false;
        CameraAnchorTrs.DOLocalRotate(playerFallDownDefCameraAnchorEul, 0.3f);
        CameraAnchorTrs.DOLocalMove(playerFallDownDefCameraAnchorPos, 0.9f)
            .OnComplete(() =>
            {

                //カメラリセット値変更してリセット
                CameraReset(null
                        , playerFallDownDefCameraAnchorPos
                        , false
                        , playerFallDownDefCameraAnchorEul
                        , false
                        , false//ユーザーカメラリセットしない
                        );
            });






        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }


    #endregion


    #region ■プレイヤー体力ゲージ
    #region 変数
    bool
        isPlayerHPSystem = false;
    GameObject //ゲージ本体
        PlayerHPSliderObj;
    Slider
        playerHPSlider,
        playerHPRedSlider,
        playerHPGreenSlider;

    Image //スライダーのImage
        playerHPSliderBackImage,
        playerHPSliderFillImage;

    Color //スライダーのデフォルトカラー取得
        playerHPSliderBackDefColor,
        playerHPSliderFillDefColor,

        //そのカラーの透明
        playerHPSliderBackTransColor,
        playerHPSliderFillTransColor;

    Tweener
        //スライダーのTween
        HPSliderTweener,
        //フェードアウトのTweener
        HPSliderFadeTweener,
        HPSliderFillFadeTweener,
        HPSliderBackFadeTweener;
    #endregion

    IEnumerator PlayerHPSystemCor()//本体（現在取得のみ）
    {
        if (isPlayerHPSystem) { yield break; }
        isPlayerHPSystem = true;

        #region 初期化
        //既にあったら削除して取り替える
        if (GameObject.Find("PlayerHPSliderObj") != null)
        { Destroy(GameObject.Find("PlayerHPSliderObj")); }
        //ゲージ本体
        PlayerHPSliderObj = Instantiate(Resources.Load("EventSystem/PlayerHP/PlayerHPSliderObj") as GameObject);
        PlayerHPSliderObj.transform.SetParent(VRCameraTrs, false);
        playerHPSlider = PlayerHPSliderObj.GetComponent<Slider>();
        playerHPSlider.maxValue = DB.playerHPMaxFloat;
        playerHPSlider.value = DB.playerHPFloat;

        playerHPRedSlider = PlayerHPSliderObj.transform.Find("PlayerHPRedSliderObj").GetComponent<Slider>();
        playerHPRedSlider.maxValue = DB.playerHPMaxFloat;
        playerHPRedSlider.value = DB.playerHPFloat;
        playerHPGreenSlider = PlayerHPSliderObj.transform.Find("PlayerHPGreenSliderObj").GetComponent<Slider>();
        playerHPGreenSlider.maxValue = DB.playerHPMaxFloat;
        playerHPGreenSlider.value = DB.playerHPFloat;


        //スライダーのImage取得
        playerHPSliderBackImage = PlayerHPSliderObj.transform.Find("Background").GetComponent<Image>();
        playerHPSliderFillImage = PlayerHPSliderObj.transform.Find("Fill").GetComponent<Image>();

        //スライダーのデフォルトカラー取得
        playerHPSliderBackDefColor = playerHPSliderBackImage.color;
        playerHPSliderFillDefColor = playerHPSliderFillImage.color;
        //カラーの透明設定
        playerHPSliderBackTransColor
            = new Color(playerHPSliderBackDefColor.r, playerHPSliderBackDefColor.g, playerHPSliderBackDefColor.b, 0);
        playerHPSliderFillTransColor
            = new Color(playerHPSliderFillDefColor.r, playerHPSliderFillDefColor.g, playerHPSliderFillDefColor.b, 0);


        //■スライダー透明に
        playerHPSliderBackImage.color = playerHPSliderBackTransColor;
        playerHPSliderFillImage.color = playerHPSliderFillTransColor;

        //オフ（非表示はオフにする）
        PlayerHPSliderObj.SetActive(false);

        #endregion

        //Debug.Log("プレイヤーHPシステム初期化完了");

        #region //現在取得だけで済んでるのでループと終了処理コメントアウト
        //#region ループ
        //while (isPlayerHPSystem)
        //{
        //    yield return null;
        //}
        //#endregion

        //#region 終了処理

        //#endregion
        //Debug.Log("プレイヤーHPシステム終了");
        #endregion
        yield break;
    }

    #region HPaddとsub スライダー表示ONOFFメソッド
    void PlayerHPAddSub(float addSubFloat)
    {
        #region 変数設定
        //現在HP取得
        float tmpPreHP = DB.playerHPFloat;
        //■スライダー表示
        HPSliderVis(true);

        //HP先に内部で処理
        DB.playerHPFloat += addSubFloat;

        //Tween用ダミーInt
        int tmpDummyInt = 0;
        //Tween動いていたらKill
        if (HPSliderTweener != null) { HPSliderTweener.Kill(); }
        #endregion

        #region 増減演出
        if (tmpPreHP < DB.playerHPFloat)//HP増える場合
        {
            //先に緑スライダー上げて（赤も）
            playerHPGreenSlider.value = DB.playerHPFloat;
            playerHPRedSlider.value = DB.playerHPFloat;

            //1秒後Tweenで本スライダー上げる
            HPSliderTweener
                = DOTween.To(() => tmpDummyInt, (x) => tmpDummyInt = x, 0, 1)
                .OnComplete(() =>
                { DOTween.To(() => playerHPSlider.value, (x) => playerHPSlider.value = x, DB.playerHPFloat, 1); });
        }
        else if (tmpPreHP > DB.playerHPFloat)//減る場合
        {
            //先に本スライダー下げて（緑も）
            playerHPSlider.value = DB.playerHPFloat;
            playerHPGreenSlider.value = DB.playerHPFloat;

            //1秒後Tweenで赤スライダー下げる
            HPSliderTweener
                = DOTween.To(() => tmpDummyInt, (x) => tmpDummyInt = x, 0, 1)
                .OnComplete(() =>
                { DOTween.To(() => playerHPRedSlider.value, (x) => playerHPRedSlider.value = x, DB.playerHPFloat, 1); });
        }
        #endregion

        //■waitTween後にフェードアウト
        //先に動いていたらKill
        if (HPSliderFadeTweener != null) { HPSliderFadeTweener.Kill(); }

        HPSliderFadeTweener =
        DOTween.To(() => tmpDummyInt, (x) => tmpDummyInt = x, 0, 5)
        .OnComplete(() =>
        { HPSliderVis(false, 2); });

    }

    void HPSliderVis(bool isVisOn, float visTime = 0)
    {
        //■なぜかSetAutoKillをFalseのRestartでうまく動かないので、毎回指定することに（このほうがメモリ保持しないし良いかも知れない）
        //まず現在動いていたら削除
        if (HPSliderBackFadeTweener != null)
        {
            HPSliderBackFadeTweener.Kill();
            HPSliderFillFadeTweener.Kill();
        }

        if (isVisOn)
        {
            //On時はオブジェクトOn
            PlayerHPSliderObj.SetActive(true);
            playerHPRedSlider.gameObject.SetActive(true);
            playerHPGreenSlider.gameObject.SetActive(true);

            HPSliderBackFadeTweener = playerHPSliderBackImage.DOColor(playerHPSliderBackDefColor, visTime);
            HPSliderFillFadeTweener = playerHPSliderFillImage.DOColor(playerHPSliderFillDefColor, visTime);
        }
        else
        {
            //off時は先に赤緑オブジェクトOff
            playerHPRedSlider.gameObject.SetActive(false);
            playerHPGreenSlider.gameObject.SetActive(false);

            HPSliderBackFadeTweener = playerHPSliderBackImage.DOColor(playerHPSliderBackTransColor, visTime);
            HPSliderFillFadeTweener = playerHPSliderFillImage.DOColor(playerHPSliderFillTransColor, visTime)
                //消えた後に本オブジェクトOff
                .OnComplete(() => { PlayerHPSliderObj.SetActive(false); });
        }
    }
    #endregion

    #endregion

    #region ■プレイヤーモーションシステム
    #region 変数
    bool
        isPlayerMotionSystem = false;

    public bool
        isPlayerWalk = false,
        isPlayerUniqueMotion = false,
        isPlayerANRotate = true;
    #endregion

    IEnumerator PlayerMotionSystemIEnum()
    {
        if (isPlayerMotionSystem) { yield break; }
        isPlayerMotionSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();


        #region 初期化

        bool //それぞれの状態になったとき、1フレームだけ処理用
            isNormal = false, isPlayerStand = false,
            isUnique = false,
            isAsinobori = false,
            isKakureoni = false, isKakureoniMove = false;

        Vector3 //かくれおに移動時の方向処理用に
            prevMovePos = new Vector3();

        bool //脚登りの片手目線向け判定用（両手掴んでたり離してたりしたら顔LookAtやめる用）
            isOneHandGrap = false;
        #endregion

        #region 足IKで地面設置テスト

        //足IK設置Ray飛ばしようObj
        GameObject
            ANFootRayOriginPosObjFolder = GameObject.Find("ANFootRayOriginPosObjFolder"),
            ANLFootRayOriginPosObj = GameObject.Find("ANLFootRayOriginPosObj"),
            ANRFootRayOriginPosObj = GameObject.Find("ANRFootRayOriginPosObj");
        #endregion


        #region ループ
        while (isPlayerMotionSystem)
        {
            #region デバッグ操作
            //if (Input.GetKeyDown(KeyCode.V))
            //{
            //    if (PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled)
            //    {
            //        PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled = false;
            //    }
            //    else
            //    {
            //        PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled = true;
            //    }
            //}
            #endregion

            //■else ifで状態参照して、下記のどれかが実行される
            #region ■ノーマル時（会話など）　　(特殊モーション中 でも かくれおに移動 でも 脚登り でもない)
            if (isPlayerUniqueMotion == false && isKOSystem == false && isANSystem == false)
            {
                #region 1フレーム目だけ処理
                if (isNormal == false)
                {
                    isNormal = true;
                    isUnique = isKakureoni = isAsinobori = false;

                    //追従やめて
                    PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled = false;

                    #region トラッキング判定で立ち座りテスト（背比べと同じ判定なので、アンカーが高くなっても立つ）
                    //VRプレイヤーが立っている時
                    if (PlayerTargetTrs.position.y > PlayerStandFeetCubeTrs.position.y)
                    {
                        isPlayerStand = true;
                        PlayerMotion("idle_01_Re", 0, 0);
                    }
                    //座っている時
                    else if (PlayerTargetTrs.position.y < PlayerStandFeetCubeTrs.position.y)
                    {
                        isPlayerStand = false;
                        PlayerMotion("sit_02_Re", 0, 0);
                    }
                    #endregion

                    #region //デフォルト以下なら座り、より高ければ立ち（アンカーのみになるのでやめ）
                    //if (CameraAnchorTrs.localPosition.y <= DB.cameraSitAnchorDefLocalPos.y)
                    //{
                    //    isPlayerStand = false;
                    //    PlayerMotion("sit_02_Re", 0.2f, 0);
                    //}
                    //else
                    //{
                    //    isPlayerStand = true;
                    //    PlayerMotion("idle_01_Re", 0.2f, 0);
                    //}
                    #endregion

                    //脚登りで回転していた場合用にゼロ
                    Player_DummyTrs.localEulerAngles = Vector3.zero;
                    //脚登りでダミーposちょいあげしていた場合用にゼロ
                    Player_DummyTrs.localPosition = new Vector3(0, 0f, 0);
                    //脚登りでIK使っていた場合用にOFF
                    DOTweenToIKEfPos(PlayerIKLFootEf, 0, 0.2f);
                    DOTweenToIKEfPos(PlayerIKRFootEf, 0, 0.2f);
                    DOTweenToLAIKSHead(PlayerLAIKHeadS, 0, 0.2f);

                    ////立ってたら座るテスト
                    //if (isPlayerStand) { ChangeStand(); }
                }
                #endregion

                #region トラッキング判定で立ち座りテスト（背比べと同じ判定なので、アンカーが高くなっても立つ）
                //VRプレイヤーが立っている時
                if (isPlayerStand == false &&
                    PlayerTargetTrs.position.y > PlayerStandFeetCubeTrs.position.y)
                {
                    isPlayerStand = true;
                    PlayerMotion("idle_01_Re", 0.2f, 0);
                }
                //座っている時
                else if (isPlayerStand &&
                    PlayerTargetTrs.position.y < PlayerStandFeetCubeTrs.position.y)
                {
                    isPlayerStand = false;
                    PlayerMotion("sit_02_Re", 0.2f, 0);
                }
                #endregion

                #region //デフォルト以下なら座り、より高ければ立ち（アンカーのみになるのでやめ）
                //if (isPlayerStand &&
                //    CameraAnchorTrs.localPosition.y <= DB.cameraSitAnchorDefLocalPos.y)
                //{
                //    isPlayerStand = false;
                //    PlayerMotion("sit_02_Re", 0.2f, 0);
                //}
                //else if (isPlayerStand == false &&
                //    CameraAnchorTrs.localPosition.y > DB.cameraSitAnchorDefLocalPos.y)
                //{
                //    isPlayerStand = true;
                //    PlayerMotion("idle_01_Re", 0.2f, 0);
                //}
                #endregion
            }
            #endregion

            #region ■特殊モーション時（boolで他のアニメ処理を止めるだけ。false待ち）
            else if (isPlayerUniqueMotion)
            {
                #region 1フレーム目だけ処理
                if (isUnique == false)
                {
                    isUnique = true;
                    isNormal = isKakureoni = isAsinobori = false;
                    //脚登りで回転していた場合用にゼロ
                    Player_DummyTrs.localEulerAngles = Vector3.zero;
                    //脚登りでダミーposちょいあげしていた場合用にゼロ
                    Player_DummyTrs.localPosition = new Vector3(0, 0f, 0);
                    //脚登りでIK使っていた場合用にOFF
                    DOTweenToIKEfPos(PlayerIKLFootEf, 0, 0);
                    DOTweenToIKEfPos(PlayerIKRFootEf, 0, 0);

                }
                #endregion
            }
            #endregion

            #region ■かくれおに移動時
            else if (isKOSystem)
            {
                #region 1フレーム目だけ処理
                if (isKakureoni == false)
                {
                    isKakureoni = true;
                    isNormal = isUnique = isAsinobori = false;

                    //追従やめて立ちポーズ化
                    PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled = false;
                    PlayerMotion("idle_01_Re", 0.2f, 0);
                    ChangeStand(true);//強制で立ちポジション
                    //脚登りで回転していた場合用にゼロ
                    Player_DummyTrs.localEulerAngles = Vector3.zero;
                    //脚登りでダミーposちょいあげしていた場合用にゼロ
                    Player_DummyTrs.localPosition = new Vector3(0, 0f, 0);
                    //脚登りでIK使っていた場合用にOFF
                    DOTweenToIKEfPos(PlayerIKLFootEf, 0, 0);
                    DOTweenToIKEfPos(PlayerIKRFootEf, 0, 0);

                    //移動している場所初期化（前回と同じ方向に進みだした際、向きなおすため）
                    prevMovePos = Vector3.zero;
                    //移動しっぱなしで特殊モーションに切り替わって戻った時用に初期化
                    isKakureoniMove = false;
                }
                #endregion

                //移動している時
                if (KO_isMove)
                {
                    //1フレだけ処理
                    if (isKakureoniMove == false)
                    {
                        isKakureoniMove = true;
                        if (isPlayerWalk)
                        { PlayerMotion("walk_00", 0.2f, 0); }
                        else { PlayerMotion("sprint_00_Re", 0.2f, 0); }
                    }
                    //移動している場所が前フレと違ったら そっち向きなおす
                    if (KO_nowMovePos != prevMovePos)
                    {
                        //移動している場所更新
                        prevMovePos = KO_nowMovePos;
                        //方向取り
                        Vector3 moveDirection = KO_nowMovePos - CameraObjectsTrs.position;
                        //ノーマライズ
                        moveDirection = moveDirection.normalized;
                        Player_DummyTrs.forward = new Vector3(moveDirection.x, 0, moveDirection.z);
                    }

                }
                //移動していない時
                else
                {
                    //1フレだけ処理
                    if (isKakureoniMove)
                    {
                        isKakureoniMove = false;
                        //立ちポーズ化
                        PlayerMotion("idle_01_Re", 0.2f, 0);
                        //移動している場所初期化（前回と同じ方向に進みだした際、向きなおすため）
                        prevMovePos = Vector3.zero;
                    }
                    ////TPSカメラ方向に向く（移動する場所わかりにくいので一旦なし）
                    //Player_DummyTrs.forward = new Vector3(TPSCameraTrs.forward.x,0, TPSCameraTrs.forward.z);
                }

            }
            #endregion

            #region ■脚登り時
            else if (isANSystem)
            {
                #region 1フレーム目だけ処理
                if (isAsinobori == false)
                {
                    isAsinobori = true;
                    isNormal = isUnique = isKakureoni = false;

                    PlayerMotion("_noData", 0.1f, 0);

                    //追従状態切り
                    PlayerFBBIKtoHeadEffectorObj.GetComponent<FullBodyBipedIK>().enabled = false;

                    ////立ってたら座るテスト
                    //if (isPlayerStand) { ChangeStand(); }



                    //両足のマッピングウェイト（FinalIKのその部位全ウェイト？）（多分現在ポーズによるひっぱりウェイトも切ってくれている。普通の足のウェイトとは違う）
                    PlayerFBBIK.solver.rightLegMapping.weight = 0;
                    PlayerFBBIK.solver.leftLegMapping.weight = 0;

                    #region 足IKで地面設置テスト
                    //ダミーPosちょい上げ（着地時は足が埋まるので）（このあとリアルタイムで切り替えるので、本来はここではいらないかも）
                    Player_DummyTrs.localPosition = new Vector3(0, 0.5f, 0);
                    //IKON
                    DOTweenToIKEfPos(PlayerIKLFootEf, 1, 0);
                    DOTweenToIKEfPos(PlayerIKRFootEf, 1, 0);

                    PlayerFBBIK.solver.leftLegChain.pull = 0;
                    PlayerFBBIK.solver.leftLegChain.reach = 1;
                    PlayerFBBIK.solver.leftLegMapping.weight = 1;

                    PlayerFBBIK.solver.rightLegChain.pull = 0;
                    PlayerFBBIK.solver.rightLegChain.reach = 1;
                    PlayerFBBIK.solver.rightLegMapping.weight = 1;


                    //手のBendGoalWeightはありかなしか
                    PlayerFBBIK.solver.rightArmMapping.weight = 1;
                    PlayerFBBIK.solver.leftArmMapping.weight = 1;

                    #endregion
                }
                #endregion

                #region 足IKで地面設置テスト

                //着地足位置までの距離、リアルタイムスケールに対応
                float footDistance =
                    0.5f
                    * (nowPlayerLocalScale.x * GameObjectsTrs.localScale.x);

                //着地足用RayPosObjをフォルダごと回転させて正面向かせる
                ANFootRayOriginPosObjFolder.transform.forward
                    = new Vector3(Player_DummyTrs.forward.x, 0, Player_DummyTrs.forward.z);


                //LRay作成
                Ray lFootRay = new Ray(ANLFootRayOriginPosObj.transform.position, -CameraObjectsTrs.up);
                RaycastHit lfootRayHit = new RaycastHit();
                Debug.DrawRay(lFootRay.origin, lFootRay.direction * 100);
                if (Physics.Raycast(lFootRay, out lfootRayHit, footDistance, AN_GrapSupportLayerMask))
                {
                    //コリダーレイでまずはテスト（他のものにあたって動かないので）
                    PlayerIKLFootTargetTrs.position = lfootRayHit.point;
                    PlayerFBBIK.solver.leftFootEffector.positionWeight = 1;
                    PlayerFBBIK.solver.leftLegMapping.weight = 1;
                    Player_DummyTrs.localPosition = new Vector3(0, 0.5f, 0);
                }
                else
                {
                    PlayerFBBIK.solver.leftFootEffector.positionWeight = 0;
                    PlayerFBBIK.solver.leftLegMapping.weight = 0;
                    Player_DummyTrs.localPosition = new Vector3(0, 0f, 0);
                }



                //RRay作成
                Ray rFootRay = new Ray(ANRFootRayOriginPosObj.transform.position, -CameraObjectsTrs.up);
                RaycastHit rfootRayHit = new RaycastHit();
                Debug.DrawRay(rFootRay.origin, rFootRay.direction * 100);
                if (Physics.Raycast(rFootRay, out rfootRayHit, footDistance, AN_GrapSupportLayerMask))
                {
                    //コリダーレイでまずはテスト（他のものにあたって動かないので）
                    PlayerIKRFootTargetTrs.position = rfootRayHit.point;
                    PlayerFBBIK.solver.rightFootEffector.positionWeight = 1;
                    PlayerFBBIK.solver.rightLegMapping.weight = 1;
                    Player_DummyTrs.localPosition = new Vector3(0, 0.5f, 0);
                }
                else
                {
                    PlayerFBBIK.solver.rightFootEffector.positionWeight = 0;
                    PlayerFBBIK.solver.rightLegMapping.weight = 0;
                    Player_DummyTrs.localPosition = new Vector3(0, 0f, 0);
                }
                #endregion


                if (isPlayerANRotate)
                {
                    #region 体を両手の中心点に向ける（Player_DummyObjそのもの）
                    //両手の中心
                    Vector3
                        handCenterPos = (AN_Hand_L_RootTrs.position + AN_Hand_R_RootTrs.position) / 2;
                    //プレイヤーからその中心点への方向
                    Vector3
                        playerToHandCenterDir = handCenterPos - Player_DummyTrs.position;
                    playerToHandCenterDir = playerToHandCenterDir.normalized;

                    //そっちへ向く
                    Player_DummyTrs.forward = playerToHandCenterDir;
                    #endregion
                }

                #region 顔を片手に向ける（LookAtIK）
                //両手掴み時はオフ
                if (AN_isRLGrap)
                {
                    if (isOneHandGrap)
                    {
                        isOneHandGrap = false;
                        //プレイヤー顔IK そのまま
                        //向き続けるので、掴まったまま移動時にまずいかも
                    }
                }
                //左手だけ掴んでる
                else if (AN_isLGrap && AN_isRLGrap == false)
                {
                    if (isOneHandGrap == false)
                    {
                        isOneHandGrap = true;

                        //プレイヤー顔IK ON
                        DOTweenToLAIKSHead(PlayerLAIKHeadS, 1, 0);
                    }
                    //プレイヤー顔IK "右"手に向け続ける
                    PlayerIKLookAtHeadTargetTrs.position
                        = AN_Hand_R_RootTrs.position;
                }
                //右手だけ掴んでる
                else if (AN_isRGrap && AN_isRLGrap == false)
                {
                    if (isOneHandGrap == false)
                    {
                        isOneHandGrap = true;

                        //プレイヤー顔IK ON
                        DOTweenToLAIKSHead(PlayerLAIKHeadS, 1, 0);
                    }
                    //プレイヤー顔IK "左"手に向け続ける
                    PlayerIKLookAtHeadTargetTrs.position
                        = AN_Hand_L_RootTrs.position;
                }
                //両手とも離してる
                else if (AN_isLGrap == AN_isRGrap == AN_isRLGrap == false)
                {
                    if (isOneHandGrap)
                    {
                        isOneHandGrap = false;
                        //プレイヤー顔IK Off
                        DOTweenToLAIKSHead(PlayerLAIKHeadS, 0, 0);
                    }
                }

                #endregion

            }
            #endregion

            yield return null;
        }
        #endregion

        //脚登り時の動き
        //FinalIKで肘の回転制御？（アオイガイさんが調べる）


        #region 終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        #endregion
        yield break;
    }

    #endregion

    #region ■マウスシステム複数

    #region マウス占有処理
    void MouseLockControl()
    {
        //カーソルロックがキャンセルされている時、クリックで戻る。
        if (Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2))
        {
            //メニュー開いてる場合
            if (isMenuSystem)
            {
                ////VR時は戻す
                //if (XRSettings.enabled)
                //{
                //Cursor.lockState = CursorLockMode.Locked;
                Cursor.visible = false;
                //}
            }
            //メニュー開いてなければいつでも戻す
            else
            {
                Cursor.lockState = CursorLockMode.Locked;
                Cursor.visible = false;
            }

        }
        else if (Input.GetKeyDown(KeyCode.Escape))
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
    }
    #endregion

    #region マウスドラッグでカメラ回転(デバッグ用で用済みかも)

    Vector3 debugLastMousePosition = new Vector3();
    Vector3 debugNewAngle = new Vector3(0, 0, 0);
    bool isDebugMouseDragCameraToggle = true;
    void DebugMouseDragCameraAngle()
    {
        #region 押しっぱなし式
        if (Input.GetMouseButtonDown(2))
        {
            // マウスクリック開始(マウスダウン)時にカメラの角度を保持(Z軸には回転させないため).
            debugNewAngle = CameraAnchorTrs.localEulerAngles;
            debugLastMousePosition = Input.mousePosition;
        }
        if (Input.GetMouseButton(2))
        {
            // マウスの移動量分カメラを回転させる.
            debugNewAngle.y += (Input.mousePosition.x - debugLastMousePosition.x) * 0.1f;
            debugNewAngle.x -= (Input.mousePosition.y - debugLastMousePosition.y) * 0.1f;
            CameraAnchorTrs.localEulerAngles = debugNewAngle;

            debugLastMousePosition = Input.mousePosition;
        }
        #endregion

        #region //トグル式
        //if (Input.GetMouseButtonDown(2)
        //    && isDebugMouseDragCameraToggle == true)
        //{ isDebugMouseDragCameraToggle = false; }

        //else if (Input.GetMouseButtonDown(2)
        //    && isDebugMouseDragCameraToggle == false)
        //{
        //    isDebugMouseDragCameraToggle = true;
        //    // マウスクリック開始(マウスダウン)時にカメラの角度を保持(Z軸には回転させないため).
        //    debugNewAngle = CameraAnchorTrs.localEulerAngles;
        //    debugLastMousePosition = Input.mousePosition;
        //}

        //if (isDebugMouseDragCameraToggle)
        //{
        //    // マウスの移動量分カメラを回転させる.
        //    debugNewAngle.y += (Input.mousePosition.x - debugLastMousePosition.x) * 0.1f;
        //    debugNewAngle.x -= (Input.mousePosition.y - debugLastMousePosition.y) * 0.1f;
        //    CameraAnchorTrs.localEulerAngles = debugNewAngle;

        //    debugLastMousePosition = Input.mousePosition;
        //}
        #endregion
    }

    #endregion 

    #region マウスホイール入力取得
    public float mouseWheelFloat, mouseWheelPrevFloat, mouseWheel1FFloat, mouseWheel1FUpDownFloat;
    public bool mouseWheelBool;
    void OnGUI()
    {
        #region //■マウスホイール入力1フレ
        ////boolがfalseで、マウスホイールが動いたら数値入力 BoolON
        //if (mouseWheelBool == false && mouseWheelFloat != 0)
        //{
        //    mouseWheel1FFloat = mouseWheelFloat;
        //    mouseWheelBool = true;
        //}

        ////マウスホイールが動いていて、ゼロ以外だったら数値ゼロ
        //else if (mouseWheelFloat != 0 && mouseWheel1FFloat != 0)
        //{ mouseWheel1FFloat = 0; }

        ////マウスホイール動いてない時に、ゼロ以外だったらboolオフ（念のため数値ゼロも入れる）
        //else if (mouseWheelBool && mouseWheelFloat == 0)
        //{
        //    mouseWheel1FFloat = 0;
        //    mouseWheelBool = false;
        //}
        #endregion

        #region ■マウスホイール入力数値1フレームに0.01ずつ0に戻っていく（マウス固体差がありそうで使えるか微妙）
        //■まずは0.01増減
        //0より大きければ毎フレーム0.01減らす
        if (mouseWheel1FUpDownFloat > 0)
        { mouseWheel1FUpDownFloat -= 0.01f; }
        //0より小さければ毎フレーム0.01増やす
        else if (mouseWheel1FUpDownFloat < 0)
        { mouseWheel1FUpDownFloat += 0.01f; }

        //その後、前フレの値と違って
        if (mouseWheelPrevFloat != mouseWheelFloat)
        {
            //0より大きい時
            if (0 < mouseWheelFloat)
            {
                //前フレーム数値より大きいならUpDownに入れる
                if (mouseWheelPrevFloat < mouseWheelFloat)
                { mouseWheel1FUpDownFloat = mouseWheelFloat; }
            }
            //0より小さい時
            else if (0 > mouseWheelFloat)
            {
                //前フレーム数値より小さいならUpDownに入れる
                if (mouseWheelPrevFloat > mouseWheelFloat)
                { mouseWheel1FUpDownFloat = mouseWheelFloat; }
            }

            //その後、Prevにはどちらにしろ入れる
            mouseWheelPrevFloat = mouseWheelFloat;
        }
        #endregion

        mouseWheelFloat = Input.GetAxis("Mouse ScrollWheel");
    }
    #endregion //マウスホイール入力取得

    #region マウスカーソル

    #region 変数
    bool
        isMouseCursorSystem;

    GameObject
        MouseCursorObj;
    Image
        MouseCursorImage;
    Vector3
        mousePos,//最後にマウスカーソルの座標に代入用
        mousePrePos,//一定時間でマウスカーソル消す仕様用
        screenToWorldPointPosition;//画面座標をワールドPosに変換用

    //Ray関係
    public Ray
        mouseRay;
    public RaycastHit
        mouseOnMenuRayHit;
    public LayerMask
        mouseRayLayerMask;

    //Clamp範囲外へ出ようとした時の値読み取り用
    float
        cursorClampOutXFlt,
        cursorClampOutYFlt;

    bool //スティック動かしている間ON　マウス動かしたらOff
        isMouseStickControll = false;
    #endregion

    IEnumerator MouseCursorSystem()
    {
        //Debug.Log("マウス起動");
        #region 初期化
        if (isMouseCursorSystem) { yield break; }
        isMouseCursorSystem = true;

        List<GameObject> exitDestroyObjList = new List<GameObject>();

        MouseCursorObj = Instantiate(Resources.Load("EventSystem/Menu/Prefab/MouseCursor") as GameObject
            , MenuFolder.transform, false);
        exitDestroyObjList.Add(MouseCursorObj);

        MouseCursorImage = MouseCursorObj.transform.Find("CursorImage").GetComponent<Image>();


        Vector3 //マウスの入力の値を読み取り、カーソルObjに代入するV3に"加算"する用（Clampをかけるために2度手間）
            mouseDragV3 = new Vector3(),
            mouseCursorPos = new Vector3();

        //■カーソル移動範囲Clamp制限用（メニューCanvasのマウス用コリダーのサイズから計算して代入）
        Vector3
            cursorPosClampMin = new Vector3(-(MouseOnMenuCollider.size.x / 2), 0, 0),
            cursorPosClampMax = new Vector3((MouseOnMenuCollider.size.x / 2), MouseOnMenuCollider.size.y, 0);

        //スティック動かしている間ON　マウス動かしたらOff
        isMouseStickControll = false;
        Vector3
            prevMousePos = new Vector3();

        #endregion
        //Debug.Log("マウスシステム初期化完了");

        #region ループ
        while (isMouseCursorSystem)
        {

            //PC時(スティック動いたらスティック操作に、マウス動いたらマウス操作になる)
            if (XRSettings.enabled == false)
            {
                #region //マウスカーソル位置色々がんばったけど複雑なのでボツ （どうせ出すRayCastからPointでマウスカーソルを置くことにした）
                //// Vector3でマウス位置座標を取得する
                //mousePos = Input.mousePosition;
                //// Z軸修正
                //mousePos.z = 50f;
                //// マウス位置座標をスクリーン座標からワールド座標に変換する
                //screenToWorldPointPosition = VRCamera.ScreenToWorldPoint(mousePos);
                //// ワールド座標に変換されたマウス座標を代入
                //MouseCursor.transform.position = screenToWorldPointPosition;


                ////Z軸修正のために一度Local値を読み込み
                //mouseCursorPos = MouseCursor.transform.localPosition;
                ////Z軸修正(メニューウインドウからほんの少し浮かす)
                //mouseCursorPos.z = -0.01f;//（Ray当てるためにほんの少し浮かす）
                ////戻す
                //MouseCursor.transform.localPosition = mouseCursorPos;
                #endregion


                if (isMouseStickControll)//スティック動いてるとき
                {
                    //マウス動いたらスティックモードやめ
                    if (prevMousePos != Input.mousePosition)
                    {
                        isMouseStickControll = false;
                    }

                    goto スティック操作;
                }
                else//マウスで動いてるとき
                {
                    #region マウスで動かす
                    //■Rayは外部マウス座標から(パース（FieldOfView）が効くとずれるのでVRUIカメラから（UIはパース変わらない）)
                    mouseRay = VRUICamera.ScreenPointToRay(Input.mousePosition);

                    //どうせ出すRayCastからPointでマウスカーソルを置くことにした
                    RaycastHit tmpRayHit;
                    if (MouseOnMenuCollider.Raycast(mouseRay, out tmpRayHit, Mathf.Infinity))
                    { MouseCursorObj.transform.position = tmpRayHit.point; }
                    #endregion

                    //スティック動いたらスティックモードに
                    if (cameraStickAxisX != 0
                        || cameraStickAxisY != 0)
                    {
                        isMouseStickControll = true;
                        //現在位置を代入
                        mouseCursorPos = MouseCursorObj.transform.localPosition;

                        //prevMousePos更新（「マウス動いたらスティックモードやめ」が動かないように）
                        prevMousePos = Input.mousePosition;
                        goto スティック操作;
                    }
                }
                prevMousePos = Input.mousePosition;
                goto ループ;
            }
            スティック操作:
            #region スティック操作（VR時など）

            //毎フレーム移動量読み取り
            mouseDragV3.x = (Input.GetAxis("Mouse X") * 0.1f)
            + (cameraStickAxisX * 0.015f);
            mouseDragV3.y = (Input.GetAxis("Mouse Y") * 0.1f)
            - (cameraStickAxisY * 0.015f);

            //代入用V3に"加算"
            mouseCursorPos += mouseDragV3;

            #region Clampする前に はみ出た分の数値読み取り
            //前フレはみ出てたらまずゼロ
            if (cursorClampOutXFlt != 0)
            { cursorClampOutXFlt = 0; }
            if (cursorClampOutYFlt != 0)
            { cursorClampOutYFlt = 0; }

            //はみ出てる分数値読み取り
            if (mouseCursorPos.x > cursorPosClampMax.x)
            { cursorClampOutXFlt = mouseCursorPos.x - cursorPosClampMax.x; }
            else if (mouseCursorPos.x < cursorPosClampMin.x)
            { cursorClampOutXFlt = mouseCursorPos.x - cursorPosClampMin.x; }

            if (mouseCursorPos.y > cursorPosClampMax.y)
            { cursorClampOutYFlt = mouseCursorPos.y - cursorPosClampMax.y; }
            else if (mouseCursorPos.y < cursorPosClampMin.y)
            { cursorClampOutYFlt = mouseCursorPos.y - cursorPosClampMin.y; }

            #endregion


            //Clamp制限（キャンバス内）
            mouseCursorPos.x = Mathf.Clamp(mouseCursorPos.x
                , cursorPosClampMin.x
                , cursorPosClampMax.x);
            mouseCursorPos.y = Mathf.Clamp(mouseCursorPos.y
                , cursorPosClampMin.y
                , cursorPosClampMax.y);
            //Z位置修正（RayCast当てるために少し浮かす）
            mouseCursorPos.z = -0.005f;
            //代入
            MouseCursorObj.transform.localPosition = mouseCursorPos;
            //読み取った値リセット
            mouseDragV3 = Vector3.zero;

            //■クリック用Rayは内部マウスカーソル座標から
            mouseRay = new Ray(MouseCursorObj.transform.position, MouseCursorObj.transform.forward);
            #endregion



            ループ:
            yield return null;
        }
        #endregion

        #region 終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        #endregion

        yield break;
    }

    #endregion

    #endregion
    #region ■カメラ スティックとマウスでの回転
    Vector3
        userCameraControlEul = new Vector3(0, 0, 0),
        ChokusetsuNyuuryokuUserCameraControlEul = Vector3.zero;

    //スティック
    bool //刻み回転スティック強めに倒したら一回目は即回転用
        isAngleYJagAddFirst = false,
        isAngleXJagAddFirst = false;

    float
        nowCameraYJagFloat = 0,
        nowCameraXJagFloat = 0,

        nowCameraXFloat = 0, //90いかないように90までの通算計算用
        nowCameraXLimitFloat = 0; //刻みなしの上下は90度に行かせない用

    //マウス
    float
        nowMouseDragAngleXLimitFloat = 0;//直接Angleをいじると0を境に360になって範囲制限できないので代替Floatで制限
    bool
        isMouseDragCameraAngleJag = false;

    float
        nowMouseCameraYJagFloat,
        nowMouseCameraXJagFloat;
    bool
        isMouseAngleYJagAddFirst,
        isMouseAngleXJagAddFirst;

    void UserControlCameraAngle()
    {
        //メニューの間は動かない(ただしユーザーゲームポーズなら動く)
        if (isMenuSystem == false || isUserGamePause)
        {
            //まず操作分を引く
            CameraUserControlTrs.localEulerAngles -= userCameraControlEul;

            //刻み　VR時 かつ 設定オフ時のみ
            if (XRSettings.enabled && DB.isUserVRSmoothRotate == false)
            {
                #region スティック左右

                if (cameraStickAxisX != 0)
                {
                    //■規定値（DB.angleJagFloat）まで貯める
                    nowCameraYJagFloat += cameraStickAxisX * DB.userStickCameraSensitivity;
                    nowCameraYJagFloat += cameraStickAxisX * DB.userStickCameraSensitivity;
                    nowCameraYJagFloat = Mathf.Clamp(nowCameraYJagFloat, -DB.angleJagFloat, DB.angleJagFloat);

                    //初回のみスティック強めに倒したら即貯まる
                    if (isAngleYJagAddFirst == false)
                    {
                        if (cameraStickAxisX > 0.7f)
                        { nowCameraYJagFloat = DB.angleJagFloat; isAngleYJagAddFirst = true; }
                        else if (cameraStickAxisX < -0.7f)
                        { nowCameraYJagFloat = -DB.angleJagFloat; isAngleYJagAddFirst = true; }
                    }

                    //貯まったら
                    if (nowCameraYJagFloat >= DB.angleJagFloat || nowCameraYJagFloat <= -DB.angleJagFloat)
                    {
                        //代入して
                        userCameraControlEul += new Vector3(0, nowCameraYJagFloat, 0);
                        nowCameraYJagFloat = 0;//リセット
                        isAngleYJagAddFirst = true;
                    }
                }
                //スティック離したら貯めた分はリセット
                else
                {
                    if (nowCameraYJagFloat != 0) { nowCameraYJagFloat = 0; }
                    if (isAngleYJagAddFirst) { isAngleYJagAddFirst = false; }
                }

                #endregion
                #region マウス刻み回転左右
                //マウス（非アクティブ時は動かない）
                if (Cursor.lockState == CursorLockMode.Locked)
                {
                    if (Input.GetAxis("Mouse X") != 0)
                    {
                        //■規定値（DB.angleJagFloat）まで貯める
                        nowMouseCameraYJagFloat += Input.GetAxis("Mouse X") * DB.userMouseCameraSensitivityFlt;
                        nowMouseCameraYJagFloat = Mathf.Clamp(nowMouseCameraYJagFloat, -DB.angleJagFloat, DB.angleJagFloat);

                        ////初回のみ即貯まる
                        //if (isMouseAngleYJagAddFirst == false)
                        //{
                        //    if (Input.GetAxis("Mouse X") * DB.userMouseCameraSensitivityFlt > 0.7f)
                        //    { nowMouseCameraYJagFloat = DB.angleJagFloat; isMouseAngleYJagAddFirst = true; }
                        //    else if (Input.GetAxis("Mouse X") * DB.userMouseCameraSensitivityFlt < -0.7f)
                        //    { nowMouseCameraYJagFloat = -DB.angleJagFloat; isMouseAngleYJagAddFirst = true; }
                        //}

                        //貯まったら
                        if (nowMouseCameraYJagFloat >= DB.angleJagFloat || nowMouseCameraYJagFloat <= -DB.angleJagFloat)
                        {
                            //代入して
                            userCameraControlEul
                                += new Vector3(0, nowMouseCameraYJagFloat, 0);
                            nowMouseCameraYJagFloat = 0;//リセット
                            isMouseAngleYJagAddFirst = true;
                        }
                    }
                    //離したら貯めた分はリセット
                    else
                    {
                        if (nowMouseCameraYJagFloat != 0) { nowMouseCameraYJagFloat = 0; }
                        if (isMouseAngleYJagAddFirst) { isMouseAngleYJagAddFirst = false; }
                    }
                }
                #endregion

                //上下は設定オン時のみ
                if (DB.isUserVRUpDownRotate)
                {
                    #region スティック上下
                    if (cameraStickAxisY != 0)
                    {
                        //■規定値（DB.angleJagFloat）まで貯める
                        nowCameraXJagFloat += cameraStickAxisY * DB.userStickCameraSensitivity;
                        nowCameraXJagFloat = Mathf.Clamp(nowCameraXJagFloat, -DB.angleJagFloat, DB.angleJagFloat);

                        //初回のみスティック強めに倒したら即貯まる
                        if (isAngleXJagAddFirst == false)
                        {
                            if (cameraStickAxisY > 0.7f)
                            { nowCameraXJagFloat = DB.angleJagFloat; isAngleXJagAddFirst = true; }
                            else if (cameraStickAxisY < -0.7f)
                            { nowCameraXJagFloat = -DB.angleJagFloat; isAngleXJagAddFirst = true; }
                        }

                        //貯まったら
                        if (nowCameraXJagFloat >= DB.angleJagFloat || nowCameraXJagFloat <= -DB.angleJagFloat)
                        {
                            //代入して
                            userCameraControlEul
                                += new Vector3(nowCameraXJagFloat, 0, 0);
                            nowCameraXJagFloat = 0;//リセット
                            isAngleXJagAddFirst = true;
                        }
                    }
                    //スティック離したら貯めた分はリセット
                    else
                    {
                        if (nowCameraXJagFloat != 0) { nowCameraXJagFloat = 0; }
                        if (isAngleXJagAddFirst) { isAngleXJagAddFirst = false; }
                    }
                    #endregion
                    #region マウス刻み回転上下
                    //マウス（非アクティブ時は動かない）
                    if (Cursor.lockState == CursorLockMode.Locked)
                    {
                        if (Input.GetAxis("Mouse Y") != 0)
                        {
                            //■規定値（DB.angleJagFloat）まで貯める
                            nowMouseCameraXJagFloat += -Input.GetAxis("Mouse Y") * DB.userMouseCameraSensitivityFlt;
                            nowMouseCameraXJagFloat = Mathf.Clamp(nowMouseCameraXJagFloat, -DB.angleJagFloat, DB.angleJagFloat);

                            ////初回のみ即貯まる
                            //if (isMouseAngleXJagAddFirst == false)
                            //{
                            //    if (-Input.GetAxis("Mouse Y") * DB.userMouseCameraSensitivityFlt > 0.7f)
                            //    { nowMouseCameraXJagFloat = DB.angleJagFloat; isMouseAngleXJagAddFirst = true; }
                            //    else if (-Input.GetAxis("Mouse Y") * DB.userMouseCameraSensitivityFlt < -0.7f)
                            //    { nowMouseCameraXJagFloat = -DB.angleJagFloat; isMouseAngleXJagAddFirst = true; }
                            //}

                            //貯まったら
                            if (nowMouseCameraXJagFloat >= DB.angleJagFloat || nowMouseCameraXJagFloat <= -DB.angleJagFloat)
                            {
                                //代入して
                                userCameraControlEul
                                    += new Vector3(nowMouseCameraXJagFloat, 0, 0);
                                nowMouseCameraXJagFloat = 0;//リセット
                                isMouseAngleXJagAddFirst = true;
                            }
                        }
                        //離したら貯めた分はリセット
                        else
                        {
                            if (nowMouseCameraXJagFloat != 0) { nowMouseCameraXJagFloat = 0; }
                            if (isMouseAngleXJagAddFirst) { isMouseAngleXJagAddFirst = false; }
                        }
                    }
                    #endregion
                }
            }
            //刻みなし　PC時 または 設定オン時
            else if (XRSettings.enabled == false || DB.isUserVRSmoothRotate)
            {
                #region スティック左右
                //スティック
                if (cameraStickAxisX != 0)
                { userCameraControlEul.y += cameraStickAxisX * DB.userStickCameraSensitivity; }
                #endregion
                #region マウス左右
                //マウス（非アクティブ時は動かない）
                if (Cursor.lockState == CursorLockMode.Locked)
                {
                    ////かつNoVRの時のみ
                    //if (XRSettings.enabled == false)
                    //{
                    //xy反対なのは、マウスXの移動量がY軸回転なため。
                    if (Input.GetAxis("Mouse X") != 0)
                    { userCameraControlEul.y += Input.GetAxis("Mouse X") * DB.userMouseCameraSensitivityFlt; }
                    //}
                }
                #endregion

                //上下はPC時 または 設定オン時のみ
                if (XRSettings.enabled == false || DB.isUserVRUpDownRotate)
                {
                    #region スティック上下
                    if (cameraStickAxisY != 0)
                    { userCameraControlEul.x += cameraStickAxisY * DB.userStickCameraSensitivity; }
                    #endregion
                    #region マウス上下
                    //（非アクティブ時は動かない）
                    if (Cursor.lockState == CursorLockMode.Locked)
                    {
                        ////かつNoVRの時のみ
                        //if (XRSettings.enabled == false)
                        //{
                        if (Input.GetAxis("Mouse Y") != 0)
                        { userCameraControlEul.x -= Input.GetAxis("Mouse Y") * DB.userMouseCameraSensitivityFlt; }
                        //}
                    }
                    #endregion
                }
            }

            #region ボタンで回転
            if (Input.GetKeyDown(KeyCode.E) && isFreeCameraModeSystem == false)
            { userCameraControlEul += new Vector3(0, 22.5f, 0); }
            if (Input.GetKeyDown(KeyCode.Q) && isFreeCameraModeSystem == false)
            { userCameraControlEul += new Vector3(0, -22.5f, 0); }
            //if (Input.GetKeyDown(KeyCode.C))
            //{ CameraAnchorTrs.Rotate(22.5f, 0, 0, Space.Self); }
            //if (Input.GetKeyDown(KeyCode.Z))
            //{ CameraAnchorTrs.Rotate(-22.5f, 0, 0, Space.Self); }
            #endregion

            #region スクリプトなどで直接カメラ回転させたい用
            //値が入っていたら加算して0に戻す
            if (ChokusetsuNyuuryokuUserCameraControlEul != Vector3.zero)
            {
                userCameraControlEul += ChokusetsuNyuuryokuUserCameraControlEul;
                ChokusetsuNyuuryokuUserCameraControlEul = Vector3.zero;
            }
            #endregion

            //X（縦回転）のみclampして代入
            userCameraControlEul.x = Mathf.Clamp(userCameraControlEul.x, -89, 89);
            CameraUserControlTrs.localEulerAngles += userCameraControlEul;

        }

        //カメラリセット
        if (isCameraResetDown || Input.GetKeyDown(KeyCode.C)) //ひとまずキーボードではC
        {
            CameraReset(null, null, true);

            if (isMenuSystem)
            {
                //■メニューウインドウの位置を見てる方向に
                GameObject defMenuObj = Resources.Load("EventSystem/Menu/Prefab/MenuFolder") as GameObject;
                MenuFolder.transform.SetParent(VRCameraTrs);
                MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
                MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;
                MenuFolder.transform.SetParent(CameraAnchorTrs);
            }
        }
    }



    //スティックレートをメニューのスライダーで操作する用
    public void SetStickRate(float rate)
    { DB.userStickCameraSensitivity = rate + 0.1f; }//0だとスライダーが処理できない & マウス止まってしまうので+0.1基準

    //マウスレートをメニューのスライダーで操作する用
    public void SetMouseRate(float rate)
    { DB.userMouseCameraSensitivityFlt = rate + 1; }//0だとスライダーが処理できない & マウス止まってしまうので+1基準

    #endregion


    #region ■フキダシシステム Serihuテキスト 選択肢 セリフログ残し

    #region 変数
    [HeaderAttribute("■フキダシシステム")]
    public bool
        isHukidashiSystem;
    #region フキダシ
    public Transform
        MouthTargetTrs;

    public Transform //hukiAreaDistanceObjはフキダシがカメラのサイズ変更の影響を受けないために必要（カメラにペアレントして位置だけ取得する）
        HukiAreaTrs,
        HukiAreaDistanceTrs;

    //フキダシの存在リスト化
    public List<GameObject>
        hukidasis = new List<GameObject>();

    //テキスト読み込みDictionary化
    TextAsset
        serihu;
    public Dictionary<string, string>
        serihuDict = new Dictionary<string, string>();
    public List<string>
        serihuKeys,
        serihuValues;
    #region テキスト読み込みDictionary化英語用

    public Dictionary<string, string>
        engSerihuDict = new Dictionary<string, string>();
    public List<string>
        engSerihuKeys,
        engSerihuValues;
    #endregion


    //Position代入用
    public Vector3
        hukiAreaPos;

    //hukiAreaDistanceObjが智恵理より奥に行かないように取得用
    public Vector3
        hukiAreaDistanceObjPos;

    //hukiAreaDistanceObjの最低距離設定用
    public float
        hAAnearMin;
    public Vector3
        tempPlayerScl;

    //口からフキダシ出す用 hukiPoint1~4とそれらのdefPosとbool
    public List<GameObject>
        hukiPoint0123 = new List<GameObject>();//タグ追加だと順不同なのでListでAdd
    public Vector3[]
        hukiPointNormalLocalPoss,
        hukiPointNovelLocalPoss,
        hukiPointHWLocalPoss;
    bool //hukiPoint切り替え用
        isHukiPointNormal,
        isHukiPointNovel,
        isHukiPointHW;
    public bool[]
        hukiPointBools;
    Tweener[]
        hukiPointTweeners;

    #endregion

    #region 選択肢
    //選択肢の存在リスト化
    [HeaderAttribute("・選択肢")]
    public List<GameObject> sentakushis = new List<GameObject>();

    public GameObject
        SentakushiPoints,
        SentakushiPointA,
        SentakushiPointB,
        SentakushiPointC,
        SentakushiPointD,
        NovelSentakushiPoints,
        NovelSentakushiPointA,
        NovelSentakushiPointB,
        NovelSentakushiPointC,
        NovelSentakushiPointD;
    //[HideInInspector]
    public Vector3
        sentakushiPointsPos,
        SentakushiPointPos;

    //演出で選択肢選択後 智恵理フキダシ消さない用（trueなら自動で消える）
    bool sentakushiEndHukidashiEraseBool = true;
    #endregion

    #region 台詞ログ残し
    //選択肢一時保持用List（選択した後色変えてログに書き込むため）
    [HeaderAttribute("・セリフログ残し")]
    public List<string> sentakushiTempLogList;

    public RectTransform
        //scrollRectとMaskが入った以下全部の親RectTrs。
        TalkLogScrollViewRectTrs,
        //入れるエレメントのプロトタイプのオブジェクト
        TalkLogGirlProtRectTrs, TalkLogSentakuNoProtRectTrs, TalkLogSentakuYesProtRectTrs,
        //ログエレメントの親オブジェクト
        TalkLogContentRectTrs;

    //ログ用エレメントのリスト
    public List<RectTransform> currentTalkLogElementRectTrsList;
    public List<string> talkLogStringList = new List<string>();//ログString保存リスト

    //順替え用Int
    public int
        currentTalkLogElementTopInt,
        currentTalkLogElementBottomInt,
        currentTalkLogChangeInt;

    //順替え位置取得用
    public Transform
        TopLineTrs,
        BottomLineTrs;

    //ScrollRect
    public ScrollRect TalkLogScrollViewScrollRect;

    #endregion

    #endregion □変数


    IEnumerator HukidashiSystem()//フキダシの動きなど
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isHukidashiSystem) { yield break; }
        isHukidashiSystem = true;

        #region 初期化
        #region 元事前取得にあった フキダシ・テキスト・選択肢

        #region フキダシ 口ターゲットやポイント
        NullJudgeFind(ref MouthTargetTrs, "MouthTarget");

        NullJudgeFind(ref HukiAreaTrs, "HukiArea");
        NullJudgeFind(ref HukiAreaDistanceTrs, "HukiAreaDistanceObj");

        //フキダシ口から出す用
        //要素数初期値設定
        Array.Resize(ref hukiPointNormalLocalPoss, 4);
        Array.Resize(ref hukiPointNovelLocalPoss, 4);
        Array.Resize(ref hukiPointHWLocalPoss, 4);
        Array.Resize(ref hukiPointBools, 4);
        Array.Resize(ref hukiPointTweeners, 4);

        //hukiPoint本体1~4取得
        hukiPoint0123.Clear();
        for (int i = 0; i <= 3; i++)
        { hukiPoint0123.Add(GameObject.Find("HukiPoint" + i).gameObject); }
        #endregion

        #region 選択肢　point読み込み

        NullJudgeFind(ref SentakushiPoints, "SentakushiPoints");
        SentakushiPointA = SentakushiPoints.transform.Find("SentakushiPointA").gameObject;
        SentakushiPointB = SentakushiPoints.transform.Find("SentakushiPointB").gameObject;
        SentakushiPointC = SentakushiPoints.transform.Find("SentakushiPointC").gameObject;
        SentakushiPointD = SentakushiPoints.transform.Find("SentakushiPointD").gameObject;

        NullJudgeFind(ref NovelSentakushiPoints, "NovelSentakushiPoints");
        NovelSentakushiPointA = NovelSentakushiPoints.transform.Find("NovelSentakushiPointA").gameObject;
        NovelSentakushiPointB = NovelSentakushiPoints.transform.Find("NovelSentakushiPointB").gameObject;
        NovelSentakushiPointC = NovelSentakushiPoints.transform.Find("NovelSentakushiPointC").gameObject;
        NovelSentakushiPointD = NovelSentakushiPoints.transform.Find("NovelSentakushiPointD").gameObject;

        #endregion

        #region 台詞ログ残し
        TalkLogScrollViewRectTrs = TalkLogScrollViewObj.GetComponent<RectTransform>();
        TalkLogScrollViewScrollRect = TalkLogScrollViewRectTrs.GetComponent<ScrollRect>();
        TalkLogContentRectTrs = TalkLogScrollViewRectTrs.Find("TalkLogContent").GetComponent<RectTransform>();
        TopLineTrs = TalkLogScrollViewRectTrs.Find("TopLine");
        BottomLineTrs = TalkLogScrollViewRectTrs.Find("BottomLine");

        //プロット
        Transform tmpTalkLogContentProtTrs = TalkLogScrollViewRectTrs.Find("TalkLogContentProt");
        TalkLogGirlProtRectTrs = tmpTalkLogContentProtTrs.Find("TalkLogGirlProt").GetComponent<RectTransform>();
        TalkLogSentakuNoProtRectTrs = tmpTalkLogContentProtTrs.Find("TalkLogSentakuNoProt").GetComponent<RectTransform>();
        TalkLogSentakuYesProtRectTrs = tmpTalkLogContentProtTrs.Find("TalkLogSentakuYesProt").GetComponent<RectTransform>();


        currentTalkLogElementRectTrsList.Clear();
        foreach (Transform i in TalkLogContentRectTrs)
        {
            if (i.name.IndexOf("TalkLog") == 0)
            {
                currentTalkLogElementRectTrsList.Add(i.GetComponent<RectTransform>());
            }
        }
        currentTalkLogElementRectTrsList.Reverse();//順番逆に
        #endregion

        #region 右下テキスト
        RightUnderText = NullJudgeFind("RightUnderText").GetComponent<Text>();
        SkipPose01 = NullJudgeFind("SkipPoseText").GetComponent<Text>();
        #endregion

        #endregion フキダシ・テキスト・選択肢

        #region 元Startにあった フキダシ・テキスト・選択肢

        #region テキスト読み込みDictionary化
        //■まず「＊改行」区切りで全部配列に読み込み
        //StreamingAssets読み込み
        string tmpStr = SerihuTxtLoad("JP");

        string[]
            tmpSerihuDataArray = tmpStr.Split(new string[] { "＊\r\n" }, System.StringSplitOptions.None);

        //全角の＠がついているものはKey扱い
        foreach (string j in tmpSerihuDataArray)
        {
            if (j.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
            {
                serihuKeys.Add(j.Remove(0, 1));//先頭1文字（全角＠）を消したうえでAdd
            }

        }

        //全角の＠がついていないものはValue（本文）
        foreach (string j in tmpSerihuDataArray)
        {
            if (j.IndexOf("＠") == 0 || j.IndexOf("//") == 0)
            {
                continue;//「＠」と「//」がついてたら次のループへ
            }

            serihuValues.Add(j);
        }

        //Dictionaryに代入
        for (int i = 0; i < serihuKeys.Count; i++)
        {
            serihuDict[serihuKeys[i]] = serihuValues[i];
        }
        #endregion
        #region 英語テキスト読み込みDictionary化
        //■まず「＊改行」区切りで全部配列に読み込み
        //StreamingAssets読み込み用変数
        string tmpEngStr;

        //デバッグ中で英語ノベル読み込まないモードなら
        if (DB.isDebugEngUnLoad)
        {
            //日本語読み込んでおく
            tmpEngStr = SerihuTxtLoad("JP");
        }
        else
        {
            //英語読み込み
            tmpEngStr = SerihuTxtLoad("EN");
        }



        string[]
            tmpEngSerihuDataArray = tmpEngStr.Split(new string[] { "＊\r\n" }, StringSplitOptions.None);

        //全角の＠がついているものはKey扱い
        foreach (string j in tmpEngSerihuDataArray)
        {
            if (j.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
            {
                engSerihuKeys.Add(j.Remove(0, 1));//先頭1文字（全角＠）を消したうえでAdd
            }

        }

        //全角の＠がついていないものはValue（本文）
        foreach (string j in tmpEngSerihuDataArray)
        {
            if (j.IndexOf("＠") == 0 || j.IndexOf("//") == 0)
            {
                continue;//「＠」と「//」がついてたら次のループへ
            }

            engSerihuValues.Add(j);
        }

        //Dictionaryに代入
        for (int i = 0; i < engSerihuKeys.Count; i++)
        {
            engSerihuDict[engSerihuKeys[i]] = engSerihuValues[i];
        }
        #endregion

        //localPositionは直接指定できないから代入用
        hukiAreaPos = HukiAreaTrs.position;

        //hukiPointのデフォ位置取得
        for (int i = 0; i <= 3; i++)
        { hukiPointNormalLocalPoss[i] = GameObject.Find("HukiPointDef" + i).gameObject.transform.localPosition; }

        //ノベル時位置取得
        for (int i = 0; i <= 3; i++)
        { hukiPointNovelLocalPoss[i] = GameObject.Find("HukiPointNovel" + i).gameObject.transform.localPosition; }

        //HW見てる時用位置取得
        for (int i = 0; i <= 3; i++)
        { hukiPointHWLocalPoss[i] = GameObject.Find("HukiPointHW" + i).gameObject.transform.localPosition; }

        //mouthTargetObj初期ローカル座標を保持し、智恵理口へペアレント
        MouthTargetTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head"), false);

        //トークログ系 初期化
        TalkLogContentRectTrs.sizeDelta = new Vector2(TalkLogContentRectTrs.sizeDelta.x, 0);
        currentTalkLogElementTopInt = 14;
        currentTalkLogElementBottomInt = 0;
        currentTalkLogChangeInt = 0;
        TalkLogGirlProtRectTrs.gameObject.SetActive(false);
        TalkLogSentakuNoProtRectTrs.gameObject.SetActive(false);
        TalkLogSentakuYesProtRectTrs.gameObject.SetActive(false);

        #endregion

        #endregion

        //Debug.Log("フキダシシステム初期化完了");

        #region ループ

        while (isHukidashiSystem)
        {
            //メニュー中 ノベルログ中は動かさない
            if (isMenuSystem || isNovelLogVisIng) { }
            else
            {
                #region 距離変更BoolついたらHukiArea近くしたり遠くしたり（共通メソッドで変えられる）
                if (isHukiAreaDistanceChange)
                {
                    HukiAreaTrs.DOLocalMove(newHukiAreaLclPos, newHukidashiNovelDistanceChangeDuration);
                    HukiAreaTrs.DOScale(newHukiAreaLclScl, newHukidashiNovelDistanceChangeDuration);

                    isHukiAreaDistanceChange = false;
                }
                #endregion

                #region //フキダシ・テキスト・選択肢 (以前のカメラにHukiAreaペアレントしない仕様)
                ////■プレイヤーを智恵理の手にペアレント時などに対応するためLateAction化 //ただ、毎フレームListに入れたりとかはアレなので独立化すべきか。
                //LateAction(() =>
                //{

                //    //hukiAreaDistanceObjはフキダシがカメラのサイズ変更の影響を受けないために必要（カメラにペアレントして位置だけ取得する）
                //    #region ■hukiAreaDistanceObj挙動 （大きさと 智恵理より奥に行かないように）
                //    //見える大きさ一定
                //    nearSizeAjust(HukiAreaDistanceTrs, 0.7f * GameObjectsTrs.localScale.z);

                //    //■ノベルシステムONなら
                //    if (isNovelFadeTween)
                //    {
                //        //カメラからノベルまでのZ距離に変更
                //        hukiAreaDistanceObjPos.z =
                //            (VRUICamera.worldToCameraMatrix.MultiplyPoint(NovelSystemObj.transform.position).z * -1 / nowPlayerLocalScl.y)
                //            / GameObjectsTrs.localScale.z;

                //        //プレイヤーサイズに合わせて数値調整
                //        if (tempPlayerScl != nowPlayerLocalScl) //大きさ変化していたら
                //        {
                //            tempPlayerScl = nowPlayerLocalScl;//ローカルの大きさ更新して
                //            hAAnearMin = 0.3f * nowPlayerLocalScl.y;//hukiAreaDistanceObj位置調整に当てはめる
                //        }
                //        //hukiAreaDistanceObj設置し続ける。
                //        HukiAreaDistanceTrs.localPosition = new Vector3(
                //            HukiAreaDistanceTrs.localPosition.x,
                //            HukiAreaDistanceTrs.localPosition.y,
                //            Mathf.Clamp(hukiAreaDistanceObjPos.z - hAAnearMin, NovelSystemObj.transform.GetChild(0).localPosition.z, 99999)
                //            );
                //    }
                //    //■デフォルトなら
                //    else
                //    {
                //        //まずカメラから智恵理までのZ距離を取り（↓は離れる＝マイナスの計算なので、マイナス1をかけてプラスにしている）(サイズが縮むと比率？も縮むので、最後に大きさを割るとうまくいった（若干理解してない）)
                //        hukiAreaDistanceObjPos.z = (VRUICamera.worldToCameraMatrix.MultiplyPoint(MouthTargetTrs.position).z * -1 / nowPlayerLocalScl.y)
                //            / GameObjectsTrs.localScale.z;//Gameobjectsのサイズに合わせて割る（100倍なら100で割る）

                //        //プレイヤーサイズに合わせて数値調整
                //        if (tempPlayerScl != nowPlayerLocalScl) //大きさ変化していたら
                //        {
                //            tempPlayerScl = nowPlayerLocalScl;//ローカルの大きさ更新して
                //            hAAnearMin = 0.5f * nowPlayerLocalScl.y;//hukiAreaDistanceObj位置調整に当てはめる
                //        }

                //        //智恵理より少し離れた位置にhukiAreaDistanceObj設置し続ける。（後ろ向き時の逆転を防ぐためClampをかけている

                //        if (isHHHHHHHHHHHHHHHHHHHHHH)//試しにずっと距離最近
                //        {
                //            HukiAreaDistanceTrs.localPosition = new Vector3(
                //                HukiAreaDistanceTrs.localPosition.x,
                //                HukiAreaDistanceTrs.localPosition.y,
                //                HukiAreaDistanceTrs.localPosition.z
                //                //Mathf.Clamp(hukiAreaDistanceObjPos.z - hAAnearMin, 0.5f, 99999)//hAAnearMin分離れ、最小値もhAAnearMin分
                //                //                                                               //↑智恵理から離れる位置、最小値、最大値は適当にでかい数値
                //                );

                //        }
                //        else
                //        {
                //            HukiAreaDistanceTrs.localPosition = new Vector3(
                //                HukiAreaDistanceTrs.localPosition.x,
                //                HukiAreaDistanceTrs.localPosition.y,
                //                Mathf.Clamp(hukiAreaDistanceObjPos.z - hAAnearMin, 0.5f, 99999)//hAAnearMin分離れ、最小値もhAAnearMin分
                //                                                                               //↑智恵理から離れる位置、最小値、最大値は適当にでかい数値
                //                );
                //        }
                //    }

                //    #endregion
                //    #region ■hukiAreaObj挙動 （大きさと回転と hukiAreaDistanceObjへSlerp移動）

                //    //nearSizeAjust
                //    nearSizeAjust(HukiAreaTrs, 2f * GameObjectsTrs.localScale.z);

                //    //カメラと同じ回転
                //    HukiAreaTrs.rotation = VRCameraTrs.rotation;

                //    ////Slerp移動
                //    //やめ
                //    //hukiAreaPos = Vector3.Slerp(hukiAreaPos, HukiAreaDistanceTrs.position, 3f * Time.deltaTime);

                //    //直接移動
                //    hukiAreaPos = HukiAreaDistanceTrs.position;

                //    //代入
                //    HukiAreaTrs.position = hukiAreaPos;

                //    #endregion

                //    #region//↑の解説文
                //    /*
                //    まずカメラの子オブジェクトに
                //    hukiAreaDistanceObjが存在する

                //    hukiAreaDistanceObjは智恵理口より奥に行かないように動く

                //    hukiAreaDistanceObjに合わせて
                //    ふんわり動くhukiAreaが存在する。

                //    フキダシは
                //    HukiPointの子になっており、HukiPointの挙動に従う。
                //    */
                //    #endregion


                //});

                #endregion

                #region hukiPoint0123が智恵理の口から移動してくる

                //boolがONになったらoffして処理する（1フレ処理）
                HukiPointMove(0);
                HukiPointMove(1);
                HukiPointMove(2);
                HukiPointMove(3);

                #endregion

                #region リアルタイムにhukiPoint切り替え
                //■デフォルト
                if (isNovelFadeTween == false
                    && isHukiPointNormal == false)
                {
                    //Bool切り替え
                    isHukiPointNormal = true;
                    isHukiPointNovel =
                    isHukiPointHW = false;
                    //Debug.Log("Def");

                    //現在動いてるTweener切り替え
                    for (int i = 0; i < hukiPointTweeners.Length; i++)
                    {
                        if (hukiPointTweeners[i] != null
                            && hukiPointTweeners[i].IsActive() == true)
                        {
                            hukiPointTweeners[i].ChangeEndValue(
                                hukiPointNormalLocalPoss[i]
                                , true)
                                .Restart();
                        }
                    }
                }
                ////■HomeWork
                //else if (playerSeeHomeWorkRayHit.collider == HomeworkCollder
                //    && isHukiPointHW == false)
                //{
                //    //Bool切り替え
                //    isHukiPointHW = true;
                //    isHukiPointNormal = 
                //    isHukiPointNovel = false;

                //    //現在動いてるTweener切り替え
                //    for (int i = 0; i < hukiPointTweeners.Length; i++)
                //    {
                //        if (hukiPointTweeners[i] != null
                //            && hukiPointTweeners[i].IsActive() == true)
                //        {
                //            hukiPointTweeners[i].ChangeEndValue(
                //                hukiPointHWLocalPoss[i]
                //                , true)
                //                .Restart();
                //        }
                //    }
                //}

                //■ノベル
                else if (isNovelFadeTween == true
                    && isHukiPointNovel == false)
                {
                    //Bool切り替え
                    isHukiPointNovel = true;
                    isHukiPointNormal =
                    isHukiPointHW = false;
                    //Debug.Log("Novel");

                    //現在動いてるTweener切り替え
                    for (int i = 0; i < hukiPointTweeners.Length; i++)
                    {
                        if (hukiPointTweeners[i] != null
                            && hukiPointTweeners[i].IsActive() == true)
                        {
                            hukiPointTweeners[i].ChangeEndValue(
                                hukiPointNovelLocalPoss[i]
                                , true)
                                .Restart();
                        }
                    }
                }
                #endregion

                #region 台詞ログ残し エレメント上下入れ替え

                //上ライン越えて・現在のログが0じゃなければ実行
                if (TopLineTrs.position.y <= currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].position.y
                    && currentTalkLogChangeInt != 0)
                {
                    TalkLogEllementMove("top");
                }

                //下ライン超えて・残りのログ総数が15以上あれば実行
                if (currentTalkLogElementRectTrsList[currentTalkLogElementBottomInt].position.y <= BottomLineTrs.position.y
                    && talkLogStringList.Count - currentTalkLogChangeInt > 15)
                {
                    TalkLogEllementMove("bottom");
                }

                //デバッグ　ログ表示ONOFF
                if (Input.GetKeyDown("l"))
                {
                    TalkLogActiveSet();
                }

                //デバッグ　ログ表示位置1
                if (Input.GetKeyDown("j"))
                {
                    TalkLogScrollViewScrollRect.verticalNormalizedPosition = 0;
                }

                #endregion

            }
            yield return null;
        }

        #endregion

        #region 終了処理

        #endregion

        Debug.Log("フキダシシステム終了処理化完了");

        yield break;
    }

    #region メソッド群 フキダシ・テキスト・選択肢・ボタン ■■■■Canvas処理本体

    #region Canvasフキダシ■■■■

    public void Hukidashi(string serihuKey)
    { StartCoroutine(CanvasHukidashiAndSentakushiCor(serihuKey, false, 10f, false, "選択肢タイトル引数用")); }
    public void SHukidashi(string serihuKey)
    { StartCoroutine(CanvasHukidashiAndSentakushiCor(serihuKey, false, 10f, true, "選択肢タイトル引数用")); }
    public void Sentakushi(string serihuKey, string sentakushiTitle = "選択肢タイトル未設定")
    { StartCoroutine(CanvasHukidashiAndSentakushiCor(serihuKey, true, 10f, false, sentakushiTitle)); }
    public void Sentakushi(string serihuKey, float sentakuNoTimeMAXFloat, string sentakushiTitle = "選択肢タイトル未設定")
    { StartCoroutine(CanvasHukidashiAndSentakushiCor(serihuKey, true, sentakuNoTimeMAXFloat, false, sentakushiTitle)); }

    //■■■■■■■■■■■■本体
    public IEnumerator CanvasHukidashiAndSentakushiCor(string serihuKey, bool isSentakushi, float sentakuNoTimeMAXFloat, bool tempSentakuWait, string sentakushiTitle, bool isDebugDoubleHukidashi = false)
    {


        //宣言
        int listNum;

        ////まずHukidashiCanvas生成
        //GameObject HukidashiCanvasObj =
        //    Instantiate(Resources.Load("EventSystem/Hukidashi/Prefab/HukidashiCanvas") as GameObject);

        //↑↓FontAssetを変更できるように、DBに置いた
        //まずHukidashiCanvas生成
        GameObject HukidashiCanvasObj =
            Instantiate(DB.hukidashiCanvasObj);


        #region 言語設定からDict入れかえ と デバッグ用に追加フキダシ
        Dictionary<string, string> tmpSerihuDict;

        if (DB.isEnglish)
        {
            //英語に該当台詞あるかチェック
            if (engSerihuDict.Keys.Contains(serihuKey))
            { tmpSerihuDict = engSerihuDict; }
            //無ければ日本語
            else
            {
                tmpSerihuDict = serihuDict;
                Debug.Log(serihuKey.ToString() + "の英語台詞がない");
            }
        }
        else
        { tmpSerihuDict = serihuDict; }

        //#if UNITY_EDITOR
        //デバッグなら
        if (DB.isLanguageDebug)
        {
            //これが追加の対言語台詞でないなら
            if (isDebugDoubleHukidashi == false)
            {
                //選択肢なら抜け
                if (isSentakushi) { goto 抜け; }
                //trueにして再実行
                yield return null;
                StartCoroutine(
                    CanvasHukidashiAndSentakushiCor(serihuKey, isSentakushi, sentakuNoTimeMAXFloat, tempSentakuWait, sentakushiTitle
                    , true));
                //これで現言語と対言語が二つ表示される
            }
            else
            {
                //追加の場合対言語に入れ替え
                if (DB.isEnglish)
                { tmpSerihuDict = serihuDict; }
                else
                {
                    //英語版があるかないかチェック
                    if (engSerihuDict.Keys.Contains(serihuKey)) { tmpSerihuDict = engSerihuDict; }
                    //無ければ日本語
                    else { tmpSerihuDict = serihuDict; }
                }

                //マテリアル変更
                HukidashiCanvasObj.GetComponent<Image>().material
                    = Instantiate(Resources.Load("EventSystem/Hukidashi/Materials/DebugHukidashiCanvasMat") as Material);

            }
        }
        抜け:

        //#endif


        #endregion

        //台詞のキーをオブジェクト名に（既読スキップ（KeyOrWaitで使用）、既選択肢など用に）
        HukidashiCanvasObj.name = serihuKey;

        //選択肢なら選択肢処理に飛ぶ
        if (isSentakushi == true) { goto 選択肢の場合; }

        #region 智恵理フキダシ
        //フキダシ満杯だったら消してから
        if (hukidasis.Count >= 4)
        { DelAll_Hukidashi(); }

        //■現表示フキダシリストに入れる処理
        if (hukidasis.IndexOf(null) == -1)//空きインデックスがひとつもなければ、配列数カウント数の所に「挿入」する（容量を増やす。書き換えるわけじゃない）
        {
            listNum = hukidasis.Count;
            hukidasis.Insert(listNum, HukidashiCanvasObj);
        }
        else//空きインデックスがあればそこに入れる
        {
            listNum = hukidasis.IndexOf(null);
            hukidasis[listNum] = HukidashiCanvasObj;
        }

        //セリフログ残しメソッド（智恵理台詞なので頭に＠つける）
        TalkLogStringListAdd("＠" + tmpSerihuDict[serihuKey]);

        //リッチテキストのタグを取り除いたテキストも生成
        string tmpNoTagString = tmpSerihuDict[serihuKey];
        tmpNoTagString = new Regex("<.*?>", RegexOptions.Singleline).Replace(tmpNoTagString, "");

        //ペアレント
        hukidasis[listNum].transform.SetParent(hukiPoint0123[listNum].transform);

        //位置スケール設定
        hukidasis[listNum].transform.localPosition =
        hukidasis[listNum].transform.localEulerAngles = Vector3.zero;
        hukidasis[listNum].transform.localScale = new Vector3(0.002f, 0.002f, 0.002f);

        //■口から出す用Boolをtrue
        hukiPointBools[listNum] = true;

        #region hukiPointの1フレーム目の位置を設定するためここで設置

        //■到着位置から口の方向取得して
        Vector3 direction = new Vector3();
        //HukiPointの位置で分岐
        if (isHukiPointNormal)
        {
            direction =
             hukiPoint0123[listNum].transform.InverseTransformPoint(MouthTargetTrs.position)
            - hukiPointNormalLocalPoss[listNum];
        }
        else if (isHukiPointNovel)
        {
            direction =
             hukiPoint0123[listNum].transform.InverseTransformPoint(MouthTargetTrs.position)
            - hukiPointNovelLocalPoss[listNum];
        }
        //ノーマライズ
        direction = direction.normalized;


        //■到着位置から20距離Posに設置（そこから飛んでくる）
        hukiPoint0123[listNum].transform.Translate
            ((direction * 20)
            * nowPlayerLocalScale.z
            , Space.Self);

        #endregion


        //セリフをフキダシに（リッチタグ付き）
        string tmpSerihuString = tmpSerihuDict[serihuKey];

        //変数あれば置換
        StringVarChange(ref tmpSerihuString);

        #region ノベルログにフキダシの台詞入れる
        //色付けのため、一度変数に入れて置き換えしてから
        string tmpNovelLogSerihuString
            = "#colorGirl#『" + tmpSerihuString + "』</color>";

        StringVarChange(ref tmpNovelLogSerihuString);

        //Add
        novelLogList.Add(tmpNovelLogSerihuString);
        #endregion

        hukidasis[listNum].transform.GetChild(0).GetComponent<TextMeshProUGUI>().text = tmpSerihuString;
        SEPlay(HukidashiSEObj, "UI_kyu", MouthTargetTrs.gameObject);

        //■文字数に合わせて口パクカウントタイマーに代入
        //（「・」「！」「？」「、」「。」「…」改行、空白 を排除）
        string tempKutipakuString = Regex.Replace(tmpNoTagString, "・|、|！|？|、|。|…|\r|\n|　| ", "");
        if (DB.isEnglish)
        {
            kutipakuTimerFloat = tempKutipakuString.Length * 0.07f;//英語の場合は短く
        }
        else
        {
            kutipakuTimerFloat = tempKutipakuString.Length * 0.2f;//前は0.13fだったけど、一文字で口動かないので0.2fにした
        }


        #region////旧 文字数に合わせて口パクアニメーション //カウントダウン式にする前の
        //ChieriMotion("口パク", 0.3f, 3, 0);
        ////文字数分ウェイトして口パクやめ
        //MotionChangeDelay(tempNoTagString.Length * 0.13f, "_noData", 0.3f, 3);//時間差表情戻し
        #endregion

        //■SHukidashi（選択肢直前など）だった時は自動削除せず★追加
        if (tempSentakuWait == true)
        {
            if (hukidasis.Count != 0)//エラーがあったので一応存在確認if
            {
                //ContentSizeFitterをオフにするとsizeDeltaが0になるので、1フレーム後に取得しオフにしたら適用
                yield return null;
                Vector2 tmpSizeDelta = hukidasis[listNum].transform.GetComponent<RectTransform>().sizeDelta;

                //記号つける ImageObj版
                hukidasis[listNum].transform.GetChild(0).Find("KoudouTaikiImage").gameObject.SetActive(true);

                //コンテンツサイズフィルターオフ
                hukidasis[listNum].transform.GetComponent<ContentSizeFitter>().enabled = false;
                hukidasis[listNum].transform.GetComponent<RectTransform>().sizeDelta = tmpSizeDelta;

                ////記号ついてなければつける 旧★版
                //if (hukidasis[listNum].transform.GetChild(0).GetComponent<Text>().text.IndexOf("★") == -1)
                //{
                //    hukidasis[listNum].transform.GetChild(0).GetComponent<Text>().text
                //      += "<size=30><color=#3FF330>★</color></size>";
                //}

            }
        }
        else //■普通フキダシなら自動削除コルーチン実行
        {
            //自動削除コルーチンをリストにいれつつ実行（後で動的にやめれるように）
            hukidashiAutoDelCoroutineList.Add
                (StartCoroutine(HukidashiAutoDelCor(tmpNoTagString, listNum, serihuKey)));

            //■ボタン待ちモードじゃなく、既読じゃなければ既読リストに(ボタン待ち時はボタン待ち時に処理)
            if (DB.isButtonWaitMode == false &&
                DB.kidokuSerihuKeyList.Contains(serihuKey) == false)
            { DB.kidokuSerihuKeyList.Add(serihuKey); }
        }


        #endregion

        yield break;


        選択肢の場合:
        //ひとまずスキップ全部止めて
        isSkipLock = true;
        #region 選択肢
        if (sentakushis.IndexOf(null) == -1)//空きインデックスがひとつもなければ、配列数カウント数の所に「挿入」する（容量を増やす。書き換えるわけじゃない）
        {
            listNum = sentakushis.Count;
            sentakushis.Insert(listNum, HukidashiCanvasObj);
        }
        else//空きインデックスがあればそこに入れる
        {
            listNum = sentakushis.IndexOf(null);
            sentakushis[listNum] = HukidashiCanvasObj;
        }

        //セリフログ残し用に一時Listに文字列入れる（選択後に色を変えて書き込むため）
        sentakushiTempLogList.Add("■" + tmpSerihuDict[serihuKey]);//選択肢は頭に■をつける（色変え判定のため）

        //Listの番号で、何番選択肢なのか取得（最後にTimeLineに渡す）
        int tempSentakuListNum = listNum;

        //レイヤーを変更
        sentakushis[listNum].layer = LayerMask.NameToLayer("seeRaySentakushi");

        //ペアレント
        sentakushis[listNum].transform.SetParent(HukiAreaTrs);
        //位置スケール設定
        sentakushis[listNum].transform.localPosition =
        sentakushis[listNum].transform.localEulerAngles = Vector3.zero;
        sentakushis[listNum].transform.localScale = new Vector3(0.002f, 0.002f, 0.002f);

        //マテリアル変更
        sentakushis[listNum].GetComponent<Image>().material
            = Instantiate(Resources.Load("EventSystem/Hukidashi/Materials/sentakushiCanvasMat") as Material);

        //枠のマテリアル追加（リソースから追加するクローンじゃないと、マテリアルは共有されてしまうので）
        sentakushis[listNum].transform.GetChild(0).GetChild(2).GetChild(0).GetComponent<Image>().material
            = Instantiate(Resources.Load("EventSystem/Hukidashi/Materials/sentakushiWakuMat") as Material);

        //表示セリフ代入（リッチタグ付き）
        sentakushis[listNum].transform.GetChild(0).GetComponent<TextMeshProUGUI>().text = tmpSerihuDict[serihuKey];

        #region■選択肢リストナンバーで位置チェンジ）
        switch (tempSentakuListNum)
        {
            case 0: SentakushiPointPos = SentakushiPointA.transform.position; break;
            case 1: SentakushiPointPos = SentakushiPointB.transform.position; break;
            case 2: SentakushiPointPos = SentakushiPointC.transform.position; break;
            case 3: SentakushiPointPos = SentakushiPointD.transform.position; break;
        }

        //■ノベルシステムONならノベル用位置に書き換え
        if (true)
        {
            switch (tempSentakuListNum)//選択肢リストナンバーで位置チェンジ）
            {
                case 0: SentakushiPointPos = NovelSentakushiPointA.transform.position; break;
                case 1: SentakushiPointPos = NovelSentakushiPointB.transform.position; break;
                case 2: SentakushiPointPos = NovelSentakushiPointC.transform.position; break;
                case 3: SentakushiPointPos = NovelSentakushiPointD.transform.position; break;
            }
        }
        #endregion
        //↑の位置を代入
        sentakushis[listNum].transform.position = SentakushiPointPos;//point　と　points　の表記間違えないように注意

        //選択肢追従止める
        yield return new WaitForSeconds(0.3f);
        LateAction(() =>
        {
            //■プレイヤー智恵理の手にペアレント時などのためにLateActionで処理
            sentakushis[listNum].transform.SetParent(VRCameraTrs);
        });

        #region 選択肢コントローラーコルーチン準備
        //コリダー追加
        BoxCollider tempCollider = sentakushis[listNum].AddComponent<BoxCollider>();
        tempCollider.size = sentakushis[listNum].GetComponent<RectTransform>().sizeDelta;

        //選択 非選択 カウンター宣言　//1フレーム実行用にPrevCount
        float sentakuOnCountFloat = 0,
              sentakuNoCountFloat = 0;

        //スライダー取得
        Slider sentakuNoSlider = sentakushis[listNum].transform.GetChild(0).GetChild(0).GetComponent<Slider>(),
               sentakuOnSlider = sentakushis[listNum].transform.GetChild(0).GetChild(1).GetComponent<Slider>(),
               sentakuWakuSlider = sentakushis[listNum].transform.GetChild(0).GetChild(2).GetComponent<Slider>();

        //スライダーの枠を利用して選択肢の枠に
        Material tempWakuMaterial = sentakuWakuSlider.transform.GetChild(0).GetComponent<Image>().material;
        Color tempWakuMaterialDefColor = tempWakuMaterial.color;


        //非選択 制限時間設定
        sentakuNoSlider.maxValue = sentakuNoTimeMAXFloat;

        #endregion

        //選択肢コントローラーコルーチン発動
        SentakushiController(sentakushiTitle);

        //※元々ここに視線選択ループと後処理があったが、↑のコントローラーコルーチンに依存して無限ループになっていたので削除（後処理もコントローラーコルーチンに入ってる）

        #endregion
    }

    //フキダシ自動消しコルーチン化　//フキダシ自動削除は別コルーチンにし、リスト化して、動的に削除をやめれるようにする
    public List<Coroutine> hukidashiAutoDelCoroutineList = new List<Coroutine>();
    public IEnumerator HukidashiAutoDelCor(string tempNoTagString, int listNum, string serihuKey)
    {

        //文字数分待ってから(英語なら早く)
        if (DB.isEnglish) { yield return new WaitForSeconds(tempNoTagString.Length * 0.07f + 3); }
        else { yield return new WaitForSeconds(tempNoTagString.Length * 0.2f + 3); }

        //（消滅エフェクト入れるならここ）

        //hukiPoint接近Tweener消し
        hukiPointTweeners[listNum].Kill();

        //そして消す(エラー多いので念入りに)
        if (hukidasis.Count != 0)
        {
            if (hukidasis[listNum] != null)
            {
                Destroy(hukidasis[listNum]);
                hukidasis[listNum] = null;
            };
        }

    }

    //■選択肢コントローラー操作コルーチン 
    public bool sentakuControllerCorBool;//重複起動しない用 ＆ 止める用bool
    void SentakushiController(string sentakushiTitle)
    {
        if (sentakuControllerCorBool == false)
        {
            sentakuControllerCorBool = true; StartCoroutine(SentakushiControllerCor(sentakushiTitle));
        }
    }
    public IEnumerator SentakushiControllerCor(string sentakushiTitle)
    {
        //Axis入力ボタンダウン化用bool
        bool tempUpBool = false, tempDownBool = false;
        //上下ボタンを一度押すまでは選択しない用
        bool sentakushiControllerFirstPushBool = false;

        //枠色変え戻しのために、現在選択ナンバーと直前選択ナンバーINT
        int tempSentakuInt = 0;
        int tempSentakuPrevInt = 0;
        bool tempSentakuIntEqualBool = false;

        //枠色変えのためsentakushisからImageをListで取得
        List<Material> sentakushisImageMaterialList = new List<Material>();
        for (int i = 0; i < sentakushis.Count; i++)
        {
            sentakushisImageMaterialList.Add
                (sentakushis[i].transform.GetChild(0).GetChild(2).GetComponent<Slider>().transform.GetChild(0).GetComponent<Image>().material);
        }
        //枠デフォルトカラー取得（0個目には入っているだろうし、選択肢別で色変えはないだろうからとりあえずこれで済ます）
        Color tempWakuMaterialDefColor = sentakushisImageMaterialList[0].color;


        //ノベルログONOFF用カウンター
        float novelLogLockTimer = 0;

        //■選択肢がリストの中に存在する間　重複用Bool解除されるまでループ
        while (sentakushis.Count != 0 && sentakuControllerCorBool == true)
        {
            //ポーズ中は動かさない
            if (isGamePause) { }
            else
            {
                #region 上下入力ボタンダウン化しint1ずつ操作

                //コントローラー
                if (tempUpBool == false && sentakuAxisY > 0.3f)
                {
                    tempSentakuInt--;
                    tempUpBool = sentakushiControllerFirstPushBool = true;
                }
                if (tempDownBool == false && sentakuAxisY < -0.3f)
                {
                    tempSentakuInt++;
                    tempDownBool = sentakushiControllerFirstPushBool = true;
                }

                //マウスホイール
                if (tempUpBool == false && mouseWheelFloat > 0)
                {
                    tempSentakuInt--;
                    tempUpBool = sentakushiControllerFirstPushBool = true;
                }
                if (tempDownBool == false && mouseWheelFloat < 0)
                {
                    tempSentakuInt++;
                    tempDownBool = sentakushiControllerFirstPushBool = true;
                }

                //両方とも押されてなければbollをfalse
                if (sentakuAxisY == 0f && sentakuAxisY == 0f && mouseWheelFloat == 0)
                {
                    tempUpBool = tempDownBool = false;
                }
                #endregion

                //選択肢の数の間でのみint上下
                if (tempSentakuInt >= sentakushis.Count - 1) { tempSentakuInt = sentakushis.Count - 1; }
                else if (tempSentakuInt < 0) { tempSentakuInt = 0; }

                #region ■↑の操作で増減するint値で選択肢操作
                //直前のintと比較で1フレームだけ処理
                //※先に、のっけから直前Intと現在Intが被っていた時用にboolで一回だけ処理
                if (tempSentakuIntEqualBool == false && tempSentakuPrevInt == tempSentakuInt)
                {
                    SEPlay(UISEObj, "UI_pin");
                    //選択枠色ON (元々透明（0）なので、不透明にして割り当て)
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    //次選択した時用に0に戻しておく
                    tempWakuMaterialDefColor.a = 0;

                    tempSentakuIntEqualBool = true;
                }
                //次から現在Intが動いた時だけ↓が実行される
                if (tempSentakuPrevInt != tempSentakuInt)
                {
                    SEPlay(UISEObj, "UI_pin");
                    //直前の選択枠色OFF
                    sentakushisImageMaterialList[tempSentakuPrevInt].color = tempWakuMaterialDefColor;
                    //選択枠色ON (元々透明（0）なので、不透明にして割り当て)
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    //次選択した時用に0に戻しておく
                    tempWakuMaterialDefColor.a = 0;

                    tempSentakuPrevInt = tempSentakuInt;
                    tempSentakuIntEqualBool = true;//のっけ用被り用boolもtrueに
                }


                //決定が押されたら現在Intを選択ナンバーとして送信処理
                if (isKetteiDown)
                {

                    //■フラッシング・消滅演出
                    //決定音キュチ
                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");

                    #region これ以外の選択肢縮小
                    //※■なぜかforのiをそのままindex指定してもアニメーションしなかったり、一つしか動かなかったりしたのでひとつひとつif
                    //（DOTweenが同じ命令文の重複に対応してない？）

                    //まず対象のリストにnullを5個くらい追加（範囲外指定エラーをなくすため）
                    sentakushis.Add(null); sentakushis.Add(null); sentakushis.Add(null); sentakushis.Add(null); sentakushis.Add(null);

                    //■5個くらい手動ifで判定
                    //0がこれ以外で、Nullじゃなければ縮小
                    if (tempSentakuInt != 0 && sentakushis[0] != null)
                    {
                        DOTween.To(() => sentakushis[0].transform.localScale, (x) => sentakushis[0].transform.localScale = x,
                            Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                    }
                    //1がこれ以外で、Nullじゃなければ縮小
                    if (tempSentakuInt != 1 && sentakushis[1] != null)
                    {
                        DOTween.To(() => sentakushis[1].transform.localScale, (x) => sentakushis[1].transform.localScale = x,
                            Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                    }
                    //2がこれ以外で、Nullじゃなければ縮小
                    if (tempSentakuInt != 2 && sentakushis[2] != null)
                    {
                        DOTween.To(() => sentakushis[2].transform.localScale, (x) => sentakushis[2].transform.localScale = x,
                            Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                    }
                    //3がこれ以外で、Nullじゃなければ縮小
                    if (tempSentakuInt != 3 && sentakushis[3] != null)
                    {
                        DOTween.To(() => sentakushis[3].transform.localScale, (x) => sentakushis[3].transform.localScale = x,
                            Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                    }
                    //4がこれ以外で、Nullじゃなければ縮小
                    if (tempSentakuInt != 4 && sentakushis[4] != null)
                    {
                        DOTween.To(() => sentakushis[4].transform.localScale, (x) => sentakushis[4].transform.localScale = x,
                            Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                    }

                    #endregion

                    #region フラッシング（枠マテリアル）
                    tempWakuMaterialDefColor.a = 0;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 0;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 0;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 0;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    yield return new WaitForSeconds(0.04f);
                    tempWakuMaterialDefColor.a = 1;
                    sentakushisImageMaterialList[tempSentakuInt].color = tempWakuMaterialDefColor;
                    #endregion

                    //選択した番号をTimeLineに送信
                    sentakuListNum = tempSentakuInt;

                    #region トークログ（スマホの）送信
                    //一時保持したListの、選択した選択肢テキスト文頭に「□」追加（ログ上で色変え判定のために（だったが、コマデータ用にも利用できそう））
                    sentakushiTempLogList[tempSentakuInt] = sentakushiTempLogList[tempSentakuInt].Insert(0, "□");

                    //一時保持した選択肢Listのテキストを全部ログに書き込む
                    for (int i = 0; i < sentakushiTempLogList.Count; i++)
                    { TalkLogStringListAdd(sentakushiTempLogList[i]); }


                    #endregion


                    #region ■フローチャートコマデータに選択肢データObj追加
                    //一旦■□マーク削除（スマホトークログとは処理かえるため）
                    for (int i = 0; i < sentakushiTempLogList.Count; i++)
                    {
                        if (sentakushiTempLogList[i].IndexOf("□") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
                        { sentakushiTempLogList[i] = sentakushiTempLogList[i].Remove(0, 1); }//先頭一文字消す
                        if (sentakushiTempLogList[i].IndexOf("■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
                        { sentakushiTempLogList[i] = sentakushiTempLogList[i].Remove(0, 1); }//先頭一文字消す
                    }


                    #region イベントコマデータObj取得（サブイベントの場合メインイベントを取得）
                    //現在イベントコマデータObj変数
                    GameObject nowEvKomaDataObj;

                    //メインイベントが何番かを取得
                    int mainEventNum =
                        DB.eventNamesList.IndexOf
                        (
                            FlowChartKomaDataFolder.transform.GetChild(DB.nowEventNum)
                            .GetComponent<FlowChartKoma>().mainEventName
                        );

                    //↑が-1(null)だった場合、現在イベントがメインイベントなので現在イベントObj取得
                    if (mainEventNum == -1)
                    {
                        nowEvKomaDataObj =
                            FlowChartKomaDataFolder.transform.GetChild(DB.nowEventNum).gameObject;
                    }
                    //-1以外ならメインイベントをその数字から取得
                    else
                    {
                        nowEvKomaDataObj =
                            FlowChartKomaDataFolder.transform.GetChild(mainEventNum).gameObject;
                    }

                    #endregion

                    #region 選択肢データをコマデータのListに保存

                    //コマデータ取得
                    FlowChartKoma tmpKomaData =
                        nowEvKomaDataObj.GetComponent<FlowChartKoma>();

                    //■同じ名前の選択肢データがなかったらAdd
                    if (tmpKomaData.sentakushiTitleList.Contains("S_" + sentakushiTitle) == false)
                    {
                        //選択肢Strings生成（1行で選択肢複数）
                        string tmpSentakushisStr = "";
                        for (int i = 0; i < sentakushiTempLogList.Count; i++)
                        { tmpSentakushisStr += sentakushiTempLogList[i] + "_s"; }

                        //タイトルAdd
                        tmpKomaData.sentakushiTitleList.Add("S_" + sentakushiTitle);
                        tmpKomaData.sentakushisList.Add(tmpSentakushisStr);

                    }

                    #region それぞれ選択肢のName先頭にマーク付与更新
                    //（□＝現在選択されている選択肢　■＝一度選んだ選択肢）

                    //該当タイトルの選択肢sListを処理
                    int index = tmpKomaData.sentakushiTitleList.IndexOf("S_" + sentakushiTitle);

                    //選択肢sを配列に
                    string[] tmpSentakushisArray =
                        tmpKomaData.sentakushisList[index].Split(new string[] { "_s" }, StringSplitOptions.None);

                    //入れなおすので削除
                    tmpKomaData.sentakushisList[index] = "";

                    //配列にしたのを今までどおりの処理
                    for (int k = 0; k < tmpSentakushisArray.Length - 1; k++)//Split配列だと最後空白が入るので-1
                    {
                        //前回選択した選択肢なら、□削除
                        if (tmpSentakushisArray[k].IndexOf("□") == 0)//0文字目にあった場合
                        { tmpSentakushisArray[k] = tmpSentakushisArray[k].Remove(0, 1); }

                        //今回選択した選択肢が
                        if (k == tempSentakuInt)
                        {
                            //未選択（空）だった場合、「□■」追加
                            if (tmpSentakushisArray[k].IndexOf("□") == -1 //その文字が何文字目にあるか調べて、-1（なかった）だった場合
                                && tmpSentakushisArray[k].IndexOf("■") == -1)
                            { tmpSentakushisArray[k] = tmpSentakushisArray[k].Insert(0, "□■"); }

                            //選択済みだった場合「□」のみ追加
                            else if (tmpSentakushisArray[k].IndexOf("■") == 0) //0文字目だった場合
                            { tmpSentakushisArray[k] = tmpSentakushisArray[k].Insert(0, "□"); }
                        }

                        //選択肢sに戻していく
                        tmpKomaData.sentakushisList[index] += tmpSentakushisArray[k] + "_s";
                    }


                    #endregion

                    #endregion

                    #region //旧（オブジェで選択肢データ保存してた時の物）

                    ////タイトルオブジェ変数
                    //GameObject addSentakusiTitleObj = null;
                    ////■既に同じ名前の選択肢データObjがあったら更新へ
                    //if (nowEvKomaDataObj.transform.Find("S_" + sentakushiTitle) != null)
                    //{
                    //    //タイトルオブジェ取得
                    //    addSentakusiTitleObj = nowEvKomaDataObj.transform.Find("S_" + sentakushiTitle).gameObject;
                    //}
                    //else//同じ名前なかったら、新規作成
                    //{
                    //    //タイトルオブジェ生成
                    //    addSentakusiTitleObj = new GameObject();
                    //    //ペアレント
                    //    addSentakusiTitleObj.transform.SetParent(nowEvKomaDataObj.transform);
                    //    //名前付け
                    //    addSentakusiTitleObj.name = "S_" + sentakushiTitle;
                    //    //子に選択肢Obj追加
                    //    for (int i = 0; i < sentakushiTempLogList.Count; i++)
                    //    {
                    //        GameObject addSentakushiObj = new GameObject();
                    //        addSentakushiObj.transform.SetParent(addSentakusiTitleObj.transform);
                    //        addSentakushiObj.name = sentakushiTempLogList[i];
                    //    }
                    //}

                    //#region それぞれ選択肢ObjのName先頭にマーク付与更新
                    ////（□＝現在選択されている選択肢　■＝一度選んだ選択肢）

                    //for (int i = 0; i < addSentakusiTitleObj.transform.childCount; i++)
                    //{
                    //    //前回選択テキストは、□削除
                    //    if (addSentakusiTitleObj.transform.GetChild(i).name.IndexOf("□") == 0)//その文字が何文字目にあるか調べて、0（先頭（0文字目））だった場合
                    //    { addSentakusiTitleObj.transform.GetChild(i).name = addSentakusiTitleObj.transform.GetChild(i).name.Remove(0, 1); }

                    //    //今回選択した選択肢のObjが
                    //    if (i == tempSentakuInt)
                    //    {
                    //        //未選択（空）だった場合、「□■」追加
                    //        if (addSentakusiTitleObj.transform.GetChild(i).name.IndexOf("□") == -1 //その文字が何文字目にあるか調べて、-1（なかった）だった場合
                    //            && addSentakusiTitleObj.transform.GetChild(i).name.IndexOf("■") == -1)
                    //        { addSentakusiTitleObj.transform.GetChild(i).name = addSentakusiTitleObj.transform.GetChild(i).name.Insert(0, "□■"); }

                    //        //選択済みだった場合「□」のみ追加
                    //        else if (addSentakusiTitleObj.transform.GetChild(i).name.IndexOf("■") == 0) //その文字が何文字目にあるか調べて、0（先頭（0文字目））だった場合
                    //        { addSentakusiTitleObj.transform.GetChild(i).name = addSentakusiTitleObj.transform.GetChild(i).name.Insert(0, "□"); }

                    //    }
                    //}


                    //#endregion

                    #endregion

                    #endregion

                    //一時保持選択肢Listクリア
                    sentakushiTempLogList.Clear();
                    //智恵理フキダシ消し
                    if (sentakushiEndHukidashiEraseBool == true) { DelAll_Hukidashi(); }

                    //ポインタ外し
                    SeePointTrs.position = Vector3.zero;

                    //スキップロック解除
                    isSkipLock = false;


                    //消す(消す命令はエラーが起こりやすいので一か所でまとめて念入りに)
                    yield return DelAll_SentakushisCor();
                    //消したことでwhileループ抜ける
                }
                #endregion

                #region ノベルログ ON OFF設定

                //選択肢1番以外の場合はノベルログを出さない
                if (tempSentakuInt > 0)
                {
                    isNovelLogLock = true;
                    novelLogLockTimer = 0;
                }
                //選択肢1番に1秒以上いたらノベルログを出せるように
                if (tempSentakuInt == 0)
                {
                    if (novelLogLockTimer < 0.8f)
                    {
                        novelLogLockTimer += 1 * Time.deltaTime;
                        if (novelLogLockTimer >= 0.8f) { isNovelLogLock = false; }
                    }
                }

                #endregion

            }
            yield return null;
        }
        yield return null;
        //抜けたら重複防止Boolfalse
        sentakuControllerCorBool = false;
        //視点で選択時に抜けた時用に枠全部透明
        for (int i = 0; i < sentakushisImageMaterialList.Count; i++)
        {
            if (sentakushisImageMaterialList[i] == null) { yield break; }//コントローラー選択で抜けたときは大元が削除されてるのでnull判定で抜ける
            sentakushisImageMaterialList[i].color = tempWakuMaterialDefColor;
        }
        //ノベルログロック解除
        isNovelLogLock = false;
    }


    void DelAll_Hukidashi()//フキダシ全消し
    {
        foreach (GameObject x in hukidasis)
        {
            Destroy(x);
        }
        hukidasis.Clear();

        //hukiPoint接近Tweener消し
        hukiPointTweeners[0].Kill();
        hukiPointTweeners[1].Kill();
        hukiPointTweeners[2].Kill();
        hukiPointTweeners[3].Kill();

        //自動削除一覧も消す
        for (int i = 0; i < hukidashiAutoDelCoroutineList.Count; i++)
        { StopCoroutine(hukidashiAutoDelCoroutineList[i]); }
        hukidashiAutoDelCoroutineList.Clear();
    }
    void DelAll_Sentakushi()//選択肢消し
    {
        //空かどうかチェックして
        if (sentakushis.Count != 0)
        {//空じゃなければ一個目がnullかチェックして
            if (sentakushis[0] != null)
            {//nullじゃなければnull以外実削除してクリア
                foreach (GameObject x in sentakushis)
                {
                    if (x != null) { Destroy(x); }
                }
                sentakushis.Clear();

            }
            else//nullならクリア
                sentakushis.Clear();

        }//空ならなにもしない

    }
    IEnumerator DelAll_SentakushisCor()//選択肢リスト消しコルーチン
    {
        //空かどうかチェックして
        if (sentakushis.Count != 0)
        {//空じゃなければ一個目がnullかチェックして
            if (sentakushis[0] != null)
            {//nullじゃなければnull以外実削除してクリア
                foreach (GameObject x in sentakushis)
                {
                    if (x != null) { Destroy(x); }
                }
                sentakushis.Clear();

            }
            else//nullならクリア
                sentakushis.Clear();

        }//空ならなにもしない

        //yield return new WaitForSeconds(1);

        ////■1秒待ってもう一度
        ////空かどうかチェックして
        //if (sentakushis.Count != 0)
        //{//空じゃなければ一個目がnullかチェックして
        //    if (sentakushis[0] != null)
        //    {//nullじゃなければnull以外実削除してクリア
        //        foreach (GameObject x in sentakushis)
        //        {
        //            if (x != null) { Destroy(x); }
        //        }
        //        sentakushis.Clear();

        //    }
        //    else//nullならクリア
        //        sentakushis.Clear();

        //}//空ならなにもしない

        yield break;
    }

    #endregion

    //フキダシ位置調整（hukiPoint）
    bool //顔判定用
        seeHeadHukidashiPointBool = false;
    float //顔の範囲調整用
        hukiPointMoveFaceWeightUpFloat = 0,
        hukiPointMoveFaceWeightDownFloat = 0;

    void HukiPointMove_Old(int i)
    {
        //hukiPointBoolがfalseかつhukiPointがmouthにない場合、mouth位置に置いとく
        if (hukiPointBools[i] == false &&
            hukiPoint0123[i].transform.position != MouthTargetTrs.position)
        { hukiPoint0123[i].transform.position = MouthTargetTrs.position; }

        //boolがtrueになったら、条件で特定位置にSlerp移動
        if (hukiPointBools[i] == true)
        {
            //宿題・選択肢・顔見ていたら離れる

            //■顔見てる具合のbool判定
            //サークルレイの頭部分の結果を持ってきて（値が小さすぎたので50000倍）
            //それが1.2以上なら宿題見位置に、0.6以下ならデフォルトに
            if (seeHeadNomFlt * 50000 >= 1.2f + hukiPointMoveFaceWeightUpFloat)
            { seeHeadHukidashiPointBool = true; }
            else if (seeHeadNomFlt * 50000 <= 0.6f + hukiPointMoveFaceWeightDownFloat)
            { seeHeadHukidashiPointBool = false; }


            //■判定
            if (playerSeeHomeWorkRayHit.collider != null
                || sentakushiRayHit.collider != null
                || seeHeadHukidashiPointBool == true
                )
            {
                hukiPoint0123[i].transform.localPosition
                    = Vector3.Lerp(hukiPoint0123[i].transform.localPosition,
                    hukiPointHWLocalPoss[i],
                    3f * Time.deltaTime);

                //直入力//hukiPoint0123[i].transform.localPosition = hukiPointHWLocalPoss[i];
            }
            else //デフォ位置にSlerp移動
            {
                hukiPoint0123[i].transform.localPosition
                    = Vector3.Lerp(hukiPoint0123[i].transform.localPosition,
                    hukiPointNormalLocalPoss[i],
                    3 * Time.deltaTime);

                //直入力//hukiPoint0123[i].transform.localPosition = hukiPointDefLocalPoss[i];
            }

        }

    }
    void HukiPointMove(int i)
    {
        //boolがtrueになったら、設定位置から口方向に20距離の場所（CanvasHukidashiAndSentakushiCorで設定）"から"設定位置へ移動
        if (hukiPointBools[i] == true)
        {
            hukiPointBools[i] = false;//1フレ処理

            //■Tweenで接近（変更・キャンセル用にTweener化している）
            //デフォルト表示ノベル表示かで切り替え
            if (isHukiPointNormal)
            {
                hukiPointTweeners[i] =
                hukiPoint0123[i].transform.DOLocalMove
                    (hukiPointNormalLocalPoss[i], 1)
                    .SetAutoKill(false);
            }
            //else if (isHukiPointHW)
            //{
            //    hukiPointTweeners[i] =
            //    hukiPoint0123[i].transform.DOLocalMove
            //        (hukiPointHWLocalPoss[i], 1)
            //        .SetAutoKill(false);
            //}
            else if (isHukiPointNovel)
            {
                hukiPointTweeners[i] =
                hukiPoint0123[i].transform.DOLocalMove
                    (hukiPointNovelLocalPoss[i], 1)
                    .SetAutoKill(false);
            }
        }

    }


    #region ボタンコリダーレイ(sentakuListNumを利用する)

    //コントローラー操作に渡すためにコリダーのList
    public List<Collider> buttonColliderList = new List<Collider>();

    //デフォルトのチェンジカラー
    Color buttonColliderRayDefColor = new Color(255f / 255f, 164f / 255, 0f / 255f);

    void ButtonColliderRay(int sentakuListNum, Collider tempCollider)
    { StartCoroutine(ButtonColliderRayCor(sentakuListNum, tempCollider, buttonColliderRayDefColor, false)); }
    void ButtonColliderRay(int sentakuListNum, Collider tempCollider, bool childWakuBool)
    { StartCoroutine(ButtonColliderRayCor(sentakuListNum, tempCollider, buttonColliderRayDefColor, childWakuBool)); }
    void ButtonColliderRay(int sentakuListNum, Collider tempCollider, Color tempChangeColor)
    { StartCoroutine(ButtonColliderRayCor(sentakuListNum, tempCollider, tempChangeColor, false)); }
    void ButtonColliderRay(int sentakuListNum, Collider tempCollider, Color tempChangeColor, bool childWakuBool)
    { StartCoroutine(ButtonColliderRayCor(sentakuListNum, tempCollider, tempChangeColor, childWakuBool)); }
    //本体■
    IEnumerator ButtonColliderRayCor(int tempSentakuListNum, Collider tempCollider, Color tempChangeColor, bool childWakuBool)
    {
        //まずコントローラー操作用にListにAdd
        buttonColliderList.Add(tempCollider);

        //枠の場合はマテリアルを子から取得
        Material tempMaterial;
        if (childWakuBool == true)
        { tempMaterial = tempCollider.transform.GetChild(0).GetComponent<Renderer>().material; }
        else { tempMaterial = tempCollider.GetComponent<Renderer>().material; }

        Color tempDefColor = tempMaterial.color;
        RaycastHit tempHit;
        float tempTimeFloat = 0, tempTimeMaxFloat = 3;
        bool tempBool = false;

        //ボタンコリダーをコントローラーで選択コルーチン発動
        ButtonColliderController();


        //ループでレイ処理開始
        //カウントMAX・選択肢ナンバー変更・コリダー消滅　で抜ける（ほかの選択肢が選ばれても抜ける仕様）
        while
            (tempTimeFloat < tempTimeMaxFloat &&
            sentakuListNum == 99 &&
            tempCollider != null)
        {
            //スマホ見てるときは動かない
            if (playerSmartPhoneVisBool == true) { }
            else
            {
                if (tempCollider.Raycast(playerSeeRay, out tempHit, Mathf.Infinity))
                {
                    //■見た1フレームだけ実行（色・音）
                    if (tempBool == false)
                    {
                        SEPlay(UISEObj, "UI_pin");

                        //ポインタースライダー設定
                        SeePointHitSlider.maxValue = tempTimeMaxFloat;

                        //選択肢コントローラーコルーチン停止 停止時に色消すので1フレーム待つ
                        buttonColliderControllerCorBool = false; yield return null;

                        //DOTweenでカラー変更
                        DOTween.To(() => tempMaterial.color, (x) => tempMaterial.color = x,
                            tempChangeColor, 0.3f);

                        tempBool = true;

                    }

                    //■見てる間
                    //Floatカウント
                    tempTimeFloat += 1 * Time.deltaTime;

                    // Rayの衝突地点に、オブジェクトSeePointを移動させる　スライダー
                    SeePointTrs.position = tempHit.point;
                    SeePointTrs.LookAt(PlayerTargetTrs, Vector3.forward);
                    nearSizeAjust(SeePointTrs, 8000);
                    SeePointHitSlider.value = tempTimeFloat;

                    //ボタンを押したら即決定（カウントMAX）
                    if (isKetteiDown)
                    { tempTimeFloat = tempTimeMaxFloat; }

                    //■カウントMAXで選択ナンバー変更して抜ける
                    if (tempTimeFloat >= tempTimeMaxFloat)
                    {
                        //■フラッシング・消滅演出
                        //決定音キュチ
                        SEPlay(UISEObj, "ui_scifi_hightech_confirm");

                        #region//これ以外の選択肢縮小
                        //※■なぜかforのiをそのままindex指定してもアニメーションしなかったり、一つしか動かなかったりしたのでひとつひとつif
                        //（DOTweenが同じ命令文の重複に対応してない？）

                        //まず対象のリストにnullを5個くらい追加（範囲外指定エラーをなくすため）
                        buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null);

                        //4つくらい手動ifで判定
                        //0がこれ以外で、Nullじゃなければ縮小
                        if (tempSentakuListNum != 0 && buttonColliderList[0] != null)
                        {
                            DOTween.To(() => buttonColliderList[0].transform.localScale, (x) => buttonColliderList[0].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //1がこれ以外で、Nullじゃなければ縮小
                        if (tempSentakuListNum != 1 && buttonColliderList[1] != null)
                        {
                            DOTween.To(() => buttonColliderList[1].transform.localScale, (x) => buttonColliderList[1].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //2がこれ以外で、Nullじゃなければ縮小
                        if (tempSentakuListNum != 2 && buttonColliderList[2] != null)
                        {
                            DOTween.To(() => buttonColliderList[2].transform.localScale, (x) => buttonColliderList[2].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //3がこれ以外で、Nullじゃなければ縮小
                        if (tempSentakuListNum != 3 && buttonColliderList[3] != null)
                        {
                            DOTween.To(() => buttonColliderList[3].transform.localScale, (x) => buttonColliderList[3].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //4がこれ以外で、Nullじゃなければ縮小
                        if (tempSentakuListNum != 4 && buttonColliderList[4] != null)
                        {
                            DOTween.To(() => buttonColliderList[4].transform.localScale, (x) => buttonColliderList[4].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        #endregion

                        #region//フラッシング（マテリアル）
                        tempMaterial.color = tempChangeColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempChangeColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempChangeColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempChangeColor;
                        yield return new WaitForSeconds(0.04f);
                        tempMaterial.color = tempDefColor;
                        #endregion


                        //ポインタゼロ位置
                        SeePointTrs.position = Vector3.zero;
                        SeePointHitSlider.value = 0;

                        //選択したナンバーに変更
                        sentakuListNum = tempSentakuListNum;
                    }

                }
                else //目離したらリセット
                {
                    //■目離した1フレームだけリセット処理
                    if (tempBool == true)
                    {
                        tempTimeFloat = 0;
                        //ポインタゼロ位置
                        SeePointTrs.position = Vector3.zero;
                        SeePointHitSlider.value = 0;
                        //DOTweenでカラー戻し
                        DOTween.To(() => tempMaterial.color, (x) => tempMaterial.color = x,
                            tempDefColor, 0.3f);

                        //選択肢コントローラーコルーチン再発動
                        ButtonColliderController();

                        tempBool = false;
                    }
                }
            }
            yield return null;

        }
        //コリダーリスト削除
        yield return DelAll_ButtonColliderListCor();


    }

    //↑ボタンコリダーをコントローラーで選択するコルーチン
    public bool buttonColliderControllerCorBool;//重複起動しない用 ＆ 止める用bool
    void ButtonColliderController()
    {
        if (buttonColliderControllerCorBool == false)
        {
            buttonColliderControllerCorBool = true; StartCoroutine(ButtonColliderControllerCor());
        }
    }//命令短縮目的でメソッド経由にしたが、この方がboolがきちんと取れた（コルーチン内でbool重複判定うまくいかなかった）

    //本体■
    public IEnumerator ButtonColliderControllerCor()
    {
        //Axis入力ボタンダウン化用bool
        bool tempRightBool = false, tempLeftBool = false;
        //左右ボタンを一度押すまでは選択しない用
        bool ButtonColliderControllerFirstPushBool = false;
        //枠色変え戻しのために、現在選択ナンバーと直前選択ナンバーINT
        int sentakuButtonInt = 0;
        int tempButtonPrevInt = 0;
        bool tempButtonIntEqualBool = false;

        //枠色変えのためbuttonColliderListからMaterialをListで取得
        List<Material> buttonColliderMaterialList = new List<Material>();
        yield return null;//早すぎると一個目しか取得できなかったので1フレーム待つ
        foreach (Collider k in buttonColliderList)
        {
            buttonColliderMaterialList.Add
                (k.transform.GetChild(0).GetComponent<Renderer>().material);
        }
        //枠デフォルトカラー取得（0個目には入っているだろうし、選択肢別で色変えはないだろうからとりあえずこれで済ます）
        Color tempWakuMaterialDefColor = buttonColliderMaterialList[0].color;
        //透明に
        tempWakuMaterialDefColor.a = 0;

        //■ボタンコリダーがリストの中に存在する間　& 重複用Bool解除されるまでループ
        while (buttonColliderList.Count != 0 && buttonColliderControllerCorBool == true)
        {
            //スマホ中は動かさない
            if (playerSmartPhoneVisBool == true) { }
            else
            {
                #region 左右入力ボタンダウン化しint1ずつ操作
                //左右コントローラー
                if (tempRightBool == false && Input.GetAxisRaw(DB.inputDict["選択左右"]) == 1f)
                {
                    sentakuButtonInt++;
                    tempRightBool = ButtonColliderControllerFirstPushBool = true;
                }
                if (tempLeftBool == false && Input.GetAxisRaw(DB.inputDict["選択左右"]) == -1f)
                {
                    sentakuButtonInt--;
                    tempLeftBool = ButtonColliderControllerFirstPushBool = true;
                }
                //左右キーボード
                if (tempRightBool == false && Input.GetAxisRaw(DB.inputDict["選択左右"]) == 1f)
                {
                    sentakuButtonInt++;
                    tempRightBool = ButtonColliderControllerFirstPushBool = true;
                }
                if (tempLeftBool == false && Input.GetAxisRaw(DB.inputDict["選択左右"]) == -1f)
                {
                    sentakuButtonInt--;
                    tempLeftBool = ButtonColliderControllerFirstPushBool = true;
                }
                //上下マウス
                if (tempRightBool == false && mouseWheelFloat < 0)
                {
                    sentakuButtonInt++;
                    tempRightBool = ButtonColliderControllerFirstPushBool = true;
                }
                if (tempLeftBool == false && mouseWheelFloat > 0)
                {
                    sentakuButtonInt--;
                    tempLeftBool = ButtonColliderControllerFirstPushBool = true;
                }

                //どれも押されてなければbollをfalse
                if (Input.GetAxisRaw(DB.inputDict["選択左右"]) == 0f && Input.GetAxisRaw(DB.inputDict["選択左右"]) == 0f && mouseWheelFloat == 0)
                {
                    tempRightBool = tempLeftBool = false;
                }
                #endregion

                //選択肢の数の間でのみint増減（Clampでよさそう）
                if (sentakuButtonInt >= buttonColliderList.Count - 1)
                { sentakuButtonInt = buttonColliderList.Count - 1; }
                else if (sentakuButtonInt < 0)
                { sentakuButtonInt = 0; }

                #region//■↑の操作で増減するint値でボタン選択操作
                //左右ボタンが一度押されたらコントローラー選択開始
                if (ButtonColliderControllerFirstPushBool == true)
                {
                    //直前のintと比較で1フレームだけ処理
                    //※先に、のっけから直前Intと現在Intが被っていた時用にboolで一回だけ処理
                    if (tempButtonIntEqualBool == false &&
                        tempButtonPrevInt == sentakuButtonInt)
                    {
                        SEPlay(UISEObj, "UI_pin");
                        //選択枠色ON (元々透明（0）なので、不透明にして割り当て)
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        //次選択した時用に0に戻しておく
                        tempWakuMaterialDefColor.a = 0;

                        tempButtonIntEqualBool = true;
                    }
                    //次から現在Intが動いた時だけ↓が実行される
                    else if (tempButtonPrevInt != sentakuButtonInt)
                    {
                        SEPlay(UISEObj, "UI_pin");
                        //直前の選択枠色OFF
                        buttonColliderMaterialList[tempButtonPrevInt].color = tempWakuMaterialDefColor;
                        //選択枠色ON (元々透明（0）なので、不透明にして割り当て)
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        //次選択した時用に0に戻しておく
                        tempWakuMaterialDefColor.a = 0;

                        tempButtonPrevInt = sentakuButtonInt;
                        tempButtonIntEqualBool = true;//のっけ用被り用boolもtrueに
                    }


                    //決定が押されたら現在Intを選択ナンバーとして送信処理
                    if (isKetteiDown == true)
                    {
                        //■フラッシング・消滅演出
                        //決定音キュチ
                        SEPlay(UISEObj, "ui_scifi_hightech_confirm");

                        #region//これ以外の選択肢縮小
                        //※■なぜかforのiをそのままindex指定してもアニメーションしなかったり、一つしか動かなかったりしたのでひとつひとつif
                        //（DOTweenが同じ命令文の重複に対応してない？）

                        //まず対象のリストにnullを5個くらい追加（範囲外指定エラーをなくすため）
                        buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null); buttonColliderList.Add(null);

                        //4つくらい手動ifで判定
                        //0がこれ以外で、Nullじゃなければ縮小
                        if (sentakuButtonInt != 0 && buttonColliderList[0] != null)
                        {
                            DOTween.To(() => buttonColliderList[0].transform.localScale, (x) => buttonColliderList[0].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //1がこれ以外で、Nullじゃなければ縮小
                        if (sentakuButtonInt != 1 && buttonColliderList[1] != null)
                        {
                            DOTween.To(() => buttonColliderList[1].transform.localScale, (x) => buttonColliderList[1].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //2がこれ以外で、Nullじゃなければ縮小
                        if (sentakuButtonInt != 2 && buttonColliderList[2] != null)
                        {
                            DOTween.To(() => buttonColliderList[2].transform.localScale, (x) => buttonColliderList[2].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //3がこれ以外で、Nullじゃなければ縮小
                        if (sentakuButtonInt != 3 && buttonColliderList[3] != null)
                        {
                            DOTween.To(() => buttonColliderList[3].transform.localScale, (x) => buttonColliderList[3].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        //4がこれ以外で、Nullじゃなければ縮小
                        if (sentakuButtonInt != 4 && buttonColliderList[4] != null)
                        {
                            DOTween.To(() => buttonColliderList[4].transform.localScale, (x) => buttonColliderList[4].transform.localScale = x,
                                Vector3.zero, 0.5f).SetEase(Ease.OutBack);
                        }
                        #endregion

                        #region//フラッシング（枠マテリアル）
                        tempWakuMaterialDefColor.a = 0;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 0;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 0;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 0;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        yield return new WaitForSeconds(0.04f);
                        tempWakuMaterialDefColor.a = 1;
                        buttonColliderMaterialList[sentakuButtonInt].color = tempWakuMaterialDefColor;
                        #endregion

                        //選択した番号をTimeLineに送信
                        sentakuListNum = sentakuButtonInt;

                        //ポインタゼロ位置
                        SeePointTrs.position = Vector3.zero;

                        //コリダーリスト削除
                        yield return DelAll_ButtonColliderListCor();

                        //消したことでwhileループ抜ける
                    }
                }
                #endregion
            }
            yield return null;
        }
        //抜けたら重複防止Boolfalse
        buttonColliderControllerCorBool = false;

        //視点で選択時に抜けた時用に枠全部透明//注意
        for (int i = 0; i < buttonColliderMaterialList.Count; i++)
        {
            if (buttonColliderMaterialList[i] == null) { yield break; }//コントローラー選択で抜けたときは大元が削除されてるのでnull判定で抜ける
            buttonColliderMaterialList[i].color = tempWakuMaterialDefColor;
        }


    }

    //ボタンコリダーリスト消し
    IEnumerator DelAll_ButtonColliderListCor()
    {
        //まず空かどうかチェックして削除
        if (buttonColliderList.Count != 0)
        { buttonColliderList.Clear(); }
        //yield return new WaitForSeconds(1);

        ////1秒待ってもう一度
        //if (buttonColliderList.Count != 0)
        //{ buttonColliderList.Clear(); }

        yield break;
    }
    #endregion


    #region セリフログ残し
    //文字追加
    public void TalkLogStringListAdd(string serihu)
    {
        //0が最新になるようにインサートで
        talkLogStringList.Insert(0, serihu);


        //大きさ計算する前にリッチテキストのタグを取り除くためにtempString
        string tempString;
        tempString = new Regex("<.*?>", RegexOptions.Singleline).Replace(serihu, "");

        if (serihu != null)
        {
            string[] tateArray;
            tateArray = tempString.Split(new string[] { "\r\n" }, System.StringSplitOptions.None);

            TalkLogContentRectTrs.sizeDelta
                += new Vector2(0, (tateArray.Length * 72) + 45);

            //最下段ならそのまま追加、でなければサイズ分ポジションも一緒に移動
            if (TalkLogScrollViewScrollRect.verticalNormalizedPosition <= 0)
            {
                //追加と同時に表示
                TalkLogEllementVisible(serihu);
            }
            else
            {
                //追加と同時に表示
                TalkLogEllementVisible(serihu);

                //currentTalkLogChangeInt++;

                //TalkLogEllementVisible(serihu);
                //TalkLogContentRectTrs.localPosition -= tempV3;
            }
        }

    }
    //ONOFF
    public void TalkLogActiveSet()
    {
        //trueだったらfalse
        if (TalkLogScrollViewRectTrs.gameObject.activeSelf == true)
        {
            TalkLogScrollViewRectTrs.gameObject.SetActive(false);
        }
        else//falseだったらtrueと共に最新ログから表示
        {
            TalkLogScrollViewRectTrs.gameObject.SetActive(true);
            TalkLogEllementVisible(null);
        }

    }
    //14個までのリアルタイム追加
    public void TalkLogEllementVisible(string serihu)
    {
        //現在一番下のログエレメントの番号取得(0から始まるとは限らないので)
        int tempBottomInt = currentTalkLogElementBottomInt;

        //表示用ログエレメントの数分繰り返す
        for (int k = 0; k < currentTalkLogElementRectTrsList.Count; k++)
        {
            //オーバー防ぎ
            if (tempBottomInt + k == 15)
            {
                tempBottomInt -= 15;
            }

            //ログの最新から存在する分だけ順に
            if (talkLogStringList.Count - k > 0)
            {
                //アクティブにして
                currentTalkLogElementRectTrsList[tempBottomInt + k].gameObject.SetActive(true);
                //テキストコンポーネント取得
                Text tempText = currentTalkLogElementRectTrsList[tempBottomInt + k].GetChild(0).GetComponent<Text>();
                //ログ文字列取得
                tempText.text = talkLogStringList[k];

                //文字から色変え(プロットから生成してるわけではないので毎回pivotや色指定する)
                #region//選択肢だった場合色変え
                if (tempText.text.IndexOf("■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
                {
                    //エレメント色とテキスト色（マテリアルそのままだとマスクされない）
                    currentTalkLogElementRectTrsList[tempBottomInt + k].GetComponent<Image>().color
                        = TalkLogSentakuNoProtRectTrs.GetComponent<Image>().material.color;
                    tempText.color
                        = TalkLogSentakuNoProtRectTrs.GetChild(0).GetComponent<Text>().color;
                    //先頭1文字を消す
                    tempText.text = tempText.text.Remove(0, 1);
                    //違う方に寄せられていたらプロトと同じ寄せ
                    if (currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                        != TalkLogSentakuNoProtRectTrs.pivot)
                    {
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMin
                            = TalkLogSentakuNoProtRectTrs.anchorMin;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMax
                            = TalkLogSentakuNoProtRectTrs.anchorMax;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                            = TalkLogSentakuNoProtRectTrs.pivot;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition
                            = new Vector2(TalkLogSentakuNoProtRectTrs.localPosition.x,
                            currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition.y);
                    }
                }
                #endregion
                #region//選んだ選択肢だった場合色変え
                if (tempText.text.IndexOf("□■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
                {
                    //先頭2文字を消す
                    tempText.text = tempText.text.Remove(0, 2);

                    //エレメント色とテキスト色（マテリアルそのままだとマスクされない）
                    currentTalkLogElementRectTrsList[tempBottomInt + k].GetComponent<Image>().color
                        = TalkLogSentakuYesProtRectTrs.GetComponent<Image>().material.color;
                    tempText.color
                        = TalkLogSentakuYesProtRectTrs.GetChild(0).GetComponent<Text>().color;
                    //違う方に寄せられていたらプロトと同じ寄せ
                    if (currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                        != TalkLogSentakuYesProtRectTrs.pivot)
                    {
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMin
                            = TalkLogSentakuYesProtRectTrs.anchorMin;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMax
                            = TalkLogSentakuYesProtRectTrs.anchorMax;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                            = TalkLogSentakuYesProtRectTrs.pivot;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition
                            = new Vector2(TalkLogSentakuYesProtRectTrs.localPosition.x,
                            currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition.y);
                    }
                }
                #endregion
                #region//智恵理の言葉の場合色変え右へ寄せ
                if (tempText.text.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
                {
                    //先頭2文字を消す
                    tempText.text = tempText.text.Remove(0, 1);
                    //エレメント色とテキスト色（マテリアルそのままだとマスクされない）
                    currentTalkLogElementRectTrsList[tempBottomInt + k].GetComponent<Image>().color
                        = TalkLogGirlProtRectTrs.GetComponent<Image>().material.color;
                    tempText.color
                        = TalkLogGirlProtRectTrs.GetChild(0).GetComponent<Text>().color;
                    //違う方に寄せられていたらプロトと同じ寄せ
                    if (currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                        != TalkLogGirlProtRectTrs.pivot)
                    {
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMin
                            = TalkLogGirlProtRectTrs.anchorMin;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].anchorMax
                            = TalkLogGirlProtRectTrs.anchorMax;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].pivot
                            = TalkLogGirlProtRectTrs.pivot;
                        currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition
                            = new Vector2(TalkLogGirlProtRectTrs.localPosition.x,
                            currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition.y);
                    }
                }
                #endregion

                //■■■文字内容に合わせて大きさを変える
                //■大きさ計算する前にリッチテキストのタグを取り除くためにtempString
                string tempString = tempText.text;
                tempString = new Regex("<.*?>", RegexOptions.Singleline).Replace(tempString, "");

                //各行をList化することで行数と各行の文字数を取り出せる
                string[] tateArray;
                tateArray = tempString.Split(new string[] { "\r\n" }, System.StringSplitOptions.None);
                //各行の文字数を読み取り、一番大きいのが横幅になるようにする
                int yokoInt = 0;
                foreach (string e in tateArray)
                {
                    if (yokoInt < e.Length)
                    {
                        yokoInt = e.Length;
                    }
                }
                //サイズ当てはめ
                currentTalkLogElementRectTrsList[tempBottomInt + k].sizeDelta
                    = new Vector2((yokoInt * 64) + 30, (tateArray.Length * 72) + 30);


                //位置をボトムから順にサイズに合わせて上へ
                //最初のみ位置最下段　それ以降は1ループ前に設置したエレメントの場所と大きさ取得してそれのひとつ上に設置
                if (k != 0)
                {
                    Vector3 tempLogV3LPos = Vector3.zero;
                    //オーバー防ぎ
                    if (tempBottomInt + k - 1 == -1)//-1になってたら14
                    {
                        tempLogV3LPos
                            = currentTalkLogElementRectTrsList[14].localPosition;
                        tempLogV3LPos.y += currentTalkLogElementRectTrsList[14].sizeDelta.y + 15;
                    }
                    else
                    {
                        tempLogV3LPos
                            = currentTalkLogElementRectTrsList[tempBottomInt + k - 1].localPosition;
                        tempLogV3LPos.y += currentTalkLogElementRectTrsList[tempBottomInt + k - 1].sizeDelta.y + 15;
                    }
                    //当てはめ
                    currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition = new Vector3(currentTalkLogElementRectTrsList[tempBottomInt + k].localPosition.x, tempLogV3LPos.y, tempLogV3LPos.z); ;

                }
                else
                {
                    //Contentのサイズ分マイナスを取ることで最下段へ(なぜか加算されるし、そのままでうまくいくので一旦コメントアウト)
                    /*
                    tempLogV3LPos.y
                        = TalkLogContentV3RectTrs.sizeDelta.y + 15;
                    //当てはめ
                    currentTalkLogElementV3RectTrsList[tempBottomInt].localPosition
                        = new Vector3(currentTalkLogElementV3RectTrsList[tempBottomInt].localPosition.x, tempLogV3LPos.y, tempLogV3LPos.z); ;
                    */
                }

            }
            else//ログがなければいらない分アクティブをFalse
            {
                currentTalkLogElementRectTrsList[tempBottomInt + k].gameObject.SetActive(false);
            }
        }



        //Debug.Log("リアルタイム追加");
    }
    //エレメント上下入れ替え
    public void TalkLogEllementMove(string topOrBottom)
    {
        //変えるRectTrs取得
        RectTransform changeRectTrs = new RectTransform(); //protの位置保存用(色変えの前にそれぞれを当てはめる)
        if (topOrBottom == "top")
        {
            changeRectTrs = currentTalkLogElementRectTrsList[currentTalkLogElementTopInt];
        }
        if (topOrBottom == "bottom")
        {
            changeRectTrs = currentTalkLogElementRectTrsList[currentTalkLogElementBottomInt];
        }

        //その後文字取得
        Text tempText = changeRectTrs.GetChild(0).GetComponent<Text>();
        if (topOrBottom == "top")
        {
            tempText.text = talkLogStringList[currentTalkLogChangeInt - 1];
        }
        if (topOrBottom == "bottom")
        {
            tempText.text = talkLogStringList[currentTalkLogChangeInt + 15];
        }

        //文字から色変え(プロットから生成してるわけではないので毎回pivotや色指定する)
        RectTransform protRectTrs = new RectTransform(); //protの位置保存用(色変えの前にそれぞれを当てはめる)
        #region//選択肢だった場合のプロット取得 文字消し
        if (tempText.text.IndexOf("■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
        {
            //プロットRectTrs取得
            protRectTrs = TalkLogSentakuNoProtRectTrs;
            //先頭1文字を消す
            tempText.text = tempText.text.Remove(0, 1);
        }
        #endregion
        #region//選んだ選択肢だった場合のプロット取得 文字消し
        if (tempText.text.IndexOf("□■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
        {
            //プロットRectTrs取得
            protRectTrs = TalkLogSentakuYesProtRectTrs;
            //先頭2文字を消す
            tempText.text = tempText.text.Remove(0, 2);
        }
        #endregion
        #region//智恵理の言葉の場合のプロット取得 文字消し
        if (tempText.text.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
        {
            //プロットRectTrs取得
            protRectTrs = TalkLogGirlProtRectTrs;
            //先頭2文字を消す
            tempText.text = tempText.text.Remove(0, 1);
        }
        #endregion
        //エレメント色とテキスト色
        changeRectTrs.GetComponent<Image>().color
                = protRectTrs.GetComponent<Image>().material.color;
        tempText.color
            = protRectTrs.GetChild(0).GetComponent<Text>().color;
        //違う方に寄せられていたらプロトと同じ寄せ
        if (changeRectTrs.pivot
            != protRectTrs.pivot)
        {
            changeRectTrs.anchorMin
                = protRectTrs.anchorMin;
            changeRectTrs.anchorMax
                = protRectTrs.anchorMax;
            changeRectTrs.pivot
                = protRectTrs.pivot;
            changeRectTrs.localPosition
                = new Vector2(protRectTrs.localPosition.x, changeRectTrs.localPosition.y);
        }


        //■■■文字内容に合わせて大きさを変える
        //■大きさ計算する前にリッチテキストのタグを取り除くためにtempString
        string tempString = tempText.text;
        tempString = new Regex("<.*?>", RegexOptions.Singleline).Replace(tempString, "");

        //各行をList化することで行数と各行の文字数を取り出せる
        string[] tateArray;
        tateArray = tempString.Split(new string[] { "\r\n" }, System.StringSplitOptions.None);
        //各行の文字数を読み取り、一番大きいのが横幅になるようにする
        int yokoInt = 0;
        foreach (string e in tateArray)
        {
            if (yokoInt < e.Length)
            {
                yokoInt = e.Length;
            }
        }
        //サイズ当てはめ
        changeRectTrs.sizeDelta
            = new Vector2((yokoInt * 64) + 30, (tateArray.Length * 72) + 30);


        #region//トップ時の位置調整
        if (topOrBottom == "top")
        {
            //位置をボトムへ
            //Yに、ボトムの位置-トップのサイズの数値を入れる（ボトムのひとつ下に行く）
            changeRectTrs.localPosition
                = new Vector3(protRectTrs.localPosition.x,
                currentTalkLogElementRectTrsList[currentTalkLogElementBottomInt].localPosition.y
                - changeRectTrs.sizeDelta.y - 15);


            //入れた文字列がログリストの最新だったら
            if (currentTalkLogChangeInt - 1 == 0)
            {
                //ログエレメント達を移動（最新ログエレメントをcontentのゼロ位置にして他もそれに合わせる）
                for (int k = 0; k < currentTalkLogElementRectTrsList.Count; k++)
                {
                    //一個目を0位置に（最新ログは必ずリスト0番目になるはず）
                    if (k == 0)
                    {
                        currentTalkLogElementRectTrsList[k].localPosition
                            = new Vector3(
                                currentTalkLogElementRectTrsList[k].localPosition.x,
                                45);
                    }
                    else//それ以外は
                    {
                        //一つ前の位置＋サイズ値分上位置へ
                        Vector3 tempV3
                            = currentTalkLogElementRectTrsList[k - 1].localPosition;
                        tempV3.y += currentTalkLogElementRectTrsList[k - 1].sizeDelta.y + 15;

                        currentTalkLogElementRectTrsList[k].localPosition =
                            new Vector2(currentTalkLogElementRectTrsList[k].localPosition.x, tempV3.y);
                    }
                }
            }



            //現在ナンバー減算
            currentTalkLogElementTopInt--;
            currentTalkLogElementBottomInt--;
            currentTalkLogChangeInt--;
            //オーバー防ぎ
            if (currentTalkLogElementTopInt == -1)
            {
                currentTalkLogElementTopInt = 14;
            }
            if (currentTalkLogElementBottomInt == -1)
            {
                currentTalkLogElementBottomInt = 14;
            }

        }

        #endregion
        #region//ボトム時の位置調整
        if (topOrBottom == "bottom")
        {
            //位置をトップへ
            //Yに、トップの位置＋トップサイズの数値を入れる（トップのひとつ上に行く）
            changeRectTrs.localPosition
                = new Vector3(protRectTrs.localPosition.x,
                currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].localPosition.y
                + currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].sizeDelta.y + 15);

            //現在ナンバー加算
            currentTalkLogElementTopInt++;
            currentTalkLogElementBottomInt++;
            currentTalkLogChangeInt++;
            //オーバー防ぎ
            if (currentTalkLogElementTopInt == 15)
            {
                currentTalkLogElementTopInt = 0;
            }
            if (currentTalkLogElementBottomInt == 15)
            {
                currentTalkLogElementBottomInt = 0;
            }



            //TopLine位置調整（ログトップエレメントの位置に）
            TopLineTrs.position
                = new Vector3(TopLineTrs.position.x,
                currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].position.y
                , TopLineTrs.position.z);

            //入れた文字列がログリストの最後だったら
            if (currentTalkLogChangeInt + 15 == talkLogStringList.Count)
            {
                //Contentサイズ調整　TopLine位置調整
                TalkLogContentRectTrs.sizeDelta
                    = new Vector2(0,
                    currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].localPosition.y
                    + currentTalkLogElementRectTrsList[currentTalkLogElementTopInt].sizeDelta.y + 30);
            }

        }
        #endregion



        //Debug.Log("上下入れ替え");
    }


    #endregion//セリフログ残しendregion

    #region サブタイトル表示
    bool isSubTitleVising = false;
    public void SubTitleVis(bool vis)
    { StartCoroutine(SubTitleVisCor(vis, null, 3)); }
    public void SubTitleVis(bool vis, float fadeTime)
    { StartCoroutine(SubTitleVisCor(vis, null, fadeTime)); }
    public void SubTitleVis(bool vis, string visText)
    { StartCoroutine(SubTitleVisCor(vis, visText, 3)); }
    public void SubTitleVis(bool vis, string visText, float fadeTime)
    { StartCoroutine(SubTitleVisCor(vis, visText, fadeTime)); }
    public void SubTitleVis(bool vis, string visText, float fadeTime, bool isAutoKill = false, float autoVisTime = 2, float autoFadeOutTime = 1)
    { StartCoroutine(SubTitleVisCor(vis, visText, fadeTime, isAutoKill, autoVisTime, autoFadeOutTime)); }
    public IEnumerator SubTitleVisCor(bool isVis, string visText, float fadeTime, bool isAutoKill = false, float autoVisTime = 2, float autoFadeOutTime = 1)
    {
        if (isVis == true)
        {
            //既にあったら消去してから
            if (isSubTitleVising)
            {
                subTitleTween.Kill();
                Destroy(subTitleTextObj);
            }

            isSubTitleVising = true;

            //サブタイトル割り当て
            subTitleTextObj = Instantiate(Resources.Load("EventSystem/Hukidashi/SubTitleText01") as GameObject
                , MessageCanvasTrs, false);
            DB.evMoveDelObjList.Add(subTitleTextObj);

            subTitleText = subTitleTextObj.GetComponent<Text>();
            subTitleText.text = visText;
            subTitleText.lineSpacing = 0.65f;

            //Tween設置
            subTitleTween =
                subTitleText.DOColor(new Color(1, 1, 1, 1), fadeTime) //フェードイン
                .OnComplete(() =>
                {
                    //オート消去がONだったら
                    if (isAutoKill)
                    {
                        //ウェイトダミー
                        subTitleText.DOColor(new Color(1, 1, 1, 1), autoVisTime)
                        .OnComplete(() =>
                        {
                            SubTitleVis(false, autoFadeOutTime);
                        });
                    }
                });
        }
        //消しの場合
        else
        {
            //既にあったら消去してから
            if (isSubTitleVising)
            {
                subTitleTween.Kill();
                Destroy(subTitleTextObj);
            }
            isSubTitleVising = true;

            subTitleTween =
                subTitleText.DOColor(new Color(1, 1, 1, 0), fadeTime)
                .OnComplete(() =>
                {
                    if (subTitleTextObj != null) { Destroy(subTitleTextObj); }
                    isSubTitleVising = false;
                    subTitleTween.Kill();
                });
        }


        yield break;
    }
    #endregion サブタイトル表示

    #endregion


    #endregion
    #region フキダシとノベル共通変数とメソッド

    #region streamingAssetからのテキストデータ読み込みが複数個所で行われるのでメソッド化
    public string SerihuTxtLoad(string country, bool isUTLKaburiCheck = false)
    {
        //\r\nはUTF-8での改行っぽい。\rや\nだけではだめ


        string txt = "";

        txt += "//＊";//ダミー（↓書式統一するため）

#if UNITY_EDITOR
        txt += ""
            + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/BotuSerihu.txt", Encoding.UTF8);
#endif

        //国別
        if (country == "JP")
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/JapaneseSerihu.txt", Encoding.UTF8)
                + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/JapaneseUnityTimelineSerihu.txt", Encoding.UTF8);
        }
        else if (country == "EN")
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/EnglishSerihu.txt", Encoding.UTF8)
                + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/EnglishUnityTimelineSerihu.txt", Encoding.UTF8);
        }

#if UNITY_EDITOR
        //UTLの被りチェックTrueなら、tempも読み込む
        if (isUTLKaburiCheck)
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/UnityTimelineTempSerihu.txt", Encoding.UTF8);
        }

        txt +=
            "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/UnityTimelineTempSerihu.txt", Encoding.UTF8);
#endif

        txt +=
            "\r\n" + "＠dummy＊" + "\r\n" + "ダミー＊";//ダミーを手動で入れた


        return txt;
    }
    public string NovelTxtLoad(string country, bool isUTLKaburiCheck = false)
    {
        //\r\nはUTF-8での改行っぽい。\rや\nだけではだめ


        string txt = "";

        txt += "//＊";//ダミー（↓書式統一するため）

#if UNITY_EDITOR
        txt += ""
            + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/BotuNovel.txt", Encoding.UTF8);
#endif

        //国別
        if (country == "JP")
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/JapaneseNovel.txt", Encoding.UTF8)
                + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/JapaneseUnityTimelineNovel.txt", Encoding.UTF8);
        }
        else if (country == "EN")
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/EnglishNovel.txt", Encoding.UTF8)
                + "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/EnglishUnityTimelineNovel.txt", System.Text.Encoding.UTF8);
        }

#if UNITY_EDITOR
        //UTLの被りチェックTrueなら、tempも読み込む
        if (isUTLKaburiCheck)
        {
            txt +=
                "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/UnityTimelineTempNovel.txt", Encoding.UTF8);
        }

        txt +=
            "\r\n" + File.ReadAllText(Application.streamingAssetsPath + "/Text/UnityTimelineTempNovel.txt", Encoding.UTF8);
#endif

        txt +=
            "\r\n" + "＠dummy＊" + "\r\n" + "ダミー＊";//ダミーを手動で入れた

        return txt;
    }
    #endregion

    #region  フキダシとノベルのプレイヤーからの距離設定

    //■解説■ 変更メソッドで値更新しBoolをTrueにし、フキダシノベルそれぞれシステム上で更新してBoolをfalse
    bool
        isHukiAreaDistanceChange = false,
        isNovelDistanceChange = false;

    Vector3
        newHukiAreaLclPos = new Vector3(),
        newNovelLclPos = new Vector3();
    Vector3
        newHukiAreaLclScl = new Vector3(),
        newNovelLclScl = new Vector3();

    float
        newHukidashiNovelDistanceChangeDuration = 0;

    void HukidashiNovelDistanceChange(float zPos = 0.5f, float duration = 0)
    {
        //指定のzPosから位置とスケール割り出し
        newHukiAreaLclPos = new Vector3(0, 0, zPos);
        newNovelLclPos = new Vector3(0, (-0.4f * zPos), zPos);

        newHukiAreaLclScl = new Vector3((0.5f * zPos), (0.5f * zPos), (0.5f * zPos));
        newNovelLclScl = new Vector3((2f * zPos), (2f * zPos), (2f * zPos));

        newHukidashiNovelDistanceChangeDuration = duration;

        isHukiAreaDistanceChange =
        isNovelDistanceChange = true;

        #region デバッグ時はコメントやデバッグシステムに送信
        if (DB.isDebugMode)
        {
            //Debug.Log("スクリプトでノベル距離変更" + zPos);
            debugHukidashiNovelDistanceChangeFloat = zPos;
        }
        #endregion

    }
    #endregion

    #endregion
    #region ■ノベルシステム 変数と入れ子コルーチン群

    #region ■変数
    [HeaderAttribute("・ノベルシステム")]
    public GameObject //開始時にリソースから読み、終了時に消す用
        NovelSystemObj;
    IEnumerator //コルーチン一時停止・終了用
        NovelSystemLoadIEnum;
    bool //全終了用Bool
        isNovelSystem;

    //テキスト読み込みDictionary化
    public List<string>
        novelKeys,
        novelValues;
    public Dictionary<string, string> novelDict = new Dictionary<string, string>();

    //Obj
    GameObject
        NovelTextObj,
        NovelLogTextObj,
        NovelKeyWaitIconObj,
        NovelAutoIconObj;

    //TextコンポーネントとImageコンポーネント
    TextMeshProUGUI
        novelText,
        novelLogText;

    Image
        novelBackImage,
        novelKeyWaitIconImage;
    //フェードインアウト関係
    bool
        isNovelSetVisIng;
    Color
        novelTextDefColor,
        backImageDefColor;
    bool
        isNovelFadeTween = false;




    bool //選択肢待ち用Bool
        isNovelSentakushiWait = false;

    //ログ表示関係
    public List<String>
        novelLogList = new List<string>();
    public bool
        novelVisBool = true,
        isNovelLogVisIng = false,
        isNovelLogVisCancel = false,
        isNovelLogInputWait = false;//ログ表示時に操作受付ワンテンポ待つ用
    public int
        novelLogCount = 0,
        nowNovelLogInt = 0;
    float //マウスとコントローラーでログ移動量変更用
        novelLogMoveSpeed = 0.1f;

    public bool //ノベル中ポーズするよう
        isNovelLogGamePause = false;
    public bool //ノベルログ表示できないようにする（選択肢の最中などに操作）
        isNovelLogLock = false;
    public bool //WASD時でもノベルログ表示させる用（とびかかりでのTimeScaleいじってないシーンのみの特例）
        isANWASDLogLockCancel = false;

    int //■イベント途中で進行させる用
        //現在ページ番号とページ数をクラス変数に
        novelCurrentPageInt = 0,
        novelCurrentLastPageInt = 0;
    bool //最終ページ送り時に、追加文ある場合消さないようbool
        isNovelLastPageTurn = false;
    bool //ノベルがオート表示中かどうかの判定
        isNowNovelAutoVis = false;

    string // 現在のページ文字列（変数置換されたあとのNovelテキストまま）
        currentTextStr = string.Empty;


    #region 翻訳用

    //■英語テキスト読み込みDictionary化
    TextAsset engNovel;
    string[] tempEngNovelDataList;
    public List<string>
        engNovelKeys,
        engNovelValues;
    public Dictionary<string, string> engNovelDict = new Dictionary<string, string>();


    #endregion


    #endregion //変数

    //■メインシステムコルーチン（ログモード切替など）
    IEnumerator NovelSystemLoad()
    {
        #region 初期化
        //■ノベルシステムPrefabなければ生成
        if (GameObject.Find("NovelSystem") == null)
        {
            //NovelSystemObj = Instantiate(Resources.Load("EventSystem/Novel/NovelSystem") as GameObject);
            //↑↓FontAssetを変更できるように、DBに置いた
            NovelSystemObj = Instantiate(DB.novelSystem);

            NovelSystemObj.transform.SetParent(VRCameraTrs, false);
        }
        //編集用にすでに配置してある場合
        else { NovelSystemObj = GameObject.Find("NovelSystemObj"); }
        //最初はオフのはずだが、もしONだったらオフにする（初期化後ON）
        if (NovelSystemObj.activeSelf == true) { NovelSystemObj.SetActive(false); }

        //■終了処理用コルーチン起動(Boolをfalseで終了する)
        StartCoroutine(NovelSystemUnLoad());

        //CanvasとRectTransform取得
        Canvas
            NovelCanvasObj = NovelSystemObj.transform.GetChild(0).GetComponent<Canvas>();
        RectTransform
            rectTrs = NovelCanvasObj.GetComponent<RectTransform>();
        //Obj取得
        NovelTextObj = NovelCanvasObj.transform.Find("NovelText").gameObject;
        NovelLogTextObj = NovelCanvasObj.transform.Find("NovelLogText").gameObject;

        NovelKeyWaitIconObj = NovelCanvasObj.transform.Find("NovelKeyWaitIcon").gameObject;
        NovelAutoIconObj = NovelCanvasObj.transform.Find("NovelAutoIcon").gameObject;

        //初期Y位置取得(ログ表示用)
        float
            defNovelTextObjLocalPosY = NovelTextObj.transform.localPosition.y,
            defNovelLogTextObjLocalPosY = NovelLogTextObj.transform.localPosition.y;

        //ログ表示位置制限Y位置（ログ表示用）(開いたときに計算して取得)
        float
            limitNovelTextObjLocalPosY = 0;

        //テキストコンポーネント取得
        novelText = NovelTextObj.GetComponent<TextMeshProUGUI>();
        novelLogText = NovelLogTextObj.GetComponent<TextMeshProUGUI>();
        //バックイメージコンポーネント取得
        novelBackImage = NovelSystemObj.transform.GetChild(0).Find("NovelBackImage").GetComponent<Image>();

        #region ノベルテキスト読み込みDictionary化
        //クリア
        novelKeys.Clear();
        novelValues.Clear();
        novelDict.Clear();

        //StreamingAssetsに
        string tmpStr = NovelTxtLoad("JP");

        //まず「＊改行」区切りで全部配列に読み込み
        var tmpNovelDataArray
            = tmpStr.Split(new string[] { "＊\r\n" }, System.StringSplitOptions.None);

        //全角の＠がついているものはKey扱い
        foreach (string j in tmpNovelDataArray)
        {
            if (j.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
            {
                novelKeys.Add(j.Remove(0, 1));//先頭1文字（全角＠）を消したうえでAdd
            }
        }

        //全角の＠がついていないものはValue（本文）
        foreach (string j in tmpNovelDataArray)
        {
            if (j.IndexOf("＠") == 0 || j.IndexOf("//") == 0)
            {
                continue;//「＠」と「//」がついてたら次のループへ
            }
            novelValues.Add(j);
        }

        //Dictionaryに代入
        for (int i = 0; i < novelKeys.Count; i++)
        {
            novelDict[novelKeys[i]] = novelValues[i];
        }
        #endregion
        #region 英語ノベルテキスト読み込みDictionary化
        //クリア
        engNovelKeys.Clear();
        engNovelValues.Clear();
        engNovelDict.Clear();

        //StreamingAssetsから読み出す用変数
        string tmpEngStr;

        //デバッグ中で英語ノベル読み込まないモードなら
        if (DB.isDebugEngUnLoad)
        {
            //日本語読み込んでおく
            tmpEngStr = NovelTxtLoad("JP");
        }
        else
        {
            //英語読み込み
            tmpEngStr = NovelTxtLoad("EN");
        }

        //まず「＊改行」区切りで全部配列に読み込み
        var tmpEngNovelDataArray
            = tmpEngStr.Split(new string[] { "＊\r\n" }, System.StringSplitOptions.None);

        //全角の＠がついているものはKey扱い
        foreach (string j in tmpEngNovelDataArray)
        {
            if (j.IndexOf("＠") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
            {
                engNovelKeys.Add(j.Remove(0, 1));//先頭1文字（全角＠）を消したうえでAdd
            }
        }

        //全角の＠がついていないものはValue（本文）
        foreach (string j in tmpEngNovelDataArray)
        {
            if (j.IndexOf("＠") == 0 || j.IndexOf("//") == 0)
            {
                continue;//「＠」と「//」がついてたら次のループへ
            }
            engNovelValues.Add(j);
        }

        //Dictionaryに代入
        for (int i = 0; i < engNovelKeys.Count; i++)
        {
            engNovelDict[engNovelKeys[i]] = engNovelValues[i];
        }
        #endregion

        //■フェード表示関係
        //フェード用Colorデフォ値取得
        novelTextDefColor = novelText.color;
        backImageDefColor = novelBackImage.color;

        //最初は透明に
        Color tmpColor = novelTextDefColor;
        tmpColor.a = 0;
        novelText.color = tmpColor;

        tmpColor = backImageDefColor;
        tmpColor.a = 0;
        novelBackImage.color = tmpColor;

        bool
            tmpIsFade = false;//フェード命令1フレ化用

        //フェードのTween（フェード中にフェード命令来た時のため）
        Tweener
            textFadeTweener = null,
            backImageFadeTweener = null;


        //ノベルログ挙動Tweener
        Tweener
            //オープンクローズ（最初はクローズで）
            logOpenCloseTweener = rectTrs.DOSizeDelta(new Vector2(rectTrs.sizeDelta.x, 0.1f), 0.001f)
            .SetAutoKill(false)
            .SetUpdate(true);



        //初期化終了したのでON
        NovelSystemObj.SetActive(true);

        #endregion 初期化
        //Debug.Log("ノベルシステム初期化");

        #region ループ
        while (isNovelSystem == true)
        {
            //メニュー時　登り操作WASD時　は何もしない
            if (isMenuSystem)
            { goto 次フレームへ; }


            #region ■距離変更BoolついたらNovelCanvas近くしたり遠くしたり（共通メソッドで変えられる）
            if (isNovelDistanceChange)
            {
                NovelCanvasObj.transform.DOLocalMove(newNovelLclPos, newHukidashiNovelDistanceChangeDuration);
                NovelCanvasObj.transform.DOScale(newNovelLclScl, newHukidashiNovelDistanceChangeDuration);

                isNovelDistanceChange = false;
            }
            #endregion

            #region フェードインフェードアウト
            //フェードイン
            if (isNovelFadeTween == true)
            {
                if (tmpIsFade == false)
                {
                    tmpIsFade = true;

                    //初期化
                    textFadeTweener.Kill();
                    backImageFadeTweener.Kill();

                    //テキスト
                    textFadeTweener =
                    DOTween.ToAlpha(
                        () => novelText.color,
                        color => novelText.color = color,
                        novelTextDefColor.a,
                        0.5f)
                        .SetUpdate(true);
                    //バック
                    backImageFadeTweener =
                    DOTween.ToAlpha(
                        () => novelBackImage.color,
                        color => novelBackImage.color = color,
                        backImageDefColor.a,
                        0.5f)
                        .SetUpdate(true);
                }
            }
            //フェードアウト
            else if (isNovelFadeTween == false)
            {
                if (tmpIsFade == true)
                {
                    tmpIsFade = false;

                    //初期化
                    textFadeTweener.Kill();
                    backImageFadeTweener.Kill();

                    //テキスト
                    textFadeTweener =
                    DOTween.ToAlpha(
                        () => novelText.color,
                        color => novelText.color = color,
                        0,
                        0.5f)
                        .SetUpdate(true);
                    //バック
                    backImageFadeTweener =
                    DOTween.ToAlpha(
                        () => novelBackImage.color,
                        color => novelBackImage.color = color,
                        0,
                        0.5f)
                        .SetUpdate(true)

                        //■20200125 どうやらこれが、連続でノベル来た時に文字を消してた原因（いらなそうなのでコメントアウト）
                        //.OnComplete(() => //テキストが空でなければ消す
                        //{
                        //    if (novelText.text != "")
                        //    {
                        //        //novelText.text = "";
                        //    }
                        //})
                        ;

                }

            }
            #endregion //フェードインフェードアウト

            #region ログモード操作（色々なコントローラーが混ざるので、ログモード動作自体とは別管理に）
            float logInputFloat = 0;

            //マウスホイール
            if (mouseWheel1FUpDownFloat >= 0.1f || mouseWheel1FUpDownFloat <= -0.1f)
            {
                logInputFloat = mouseWheel1FUpDownFloat;
                novelLogMoveSpeed = 0.1f;
            }
            //コントローラーAxis
            if (sentakuAxisY >= 0.3 || sentakuAxisY <= -0.3)
            {
                logInputFloat = sentakuAxisY;
                novelLogMoveSpeed = 0.02f;
            }
            #endregion

            #region ログビュー

            //ノベルログモードON
            if (isNovelLogVisIng == false //既に出ているときはしない
                && isNovelLogLock == false //ロック時はしない
                && (logInputFloat >= 0.1f || Input.GetButtonDown(DB.inputDict["ノベルログ"]))//上キーかログ表示ボタンでON
                )
            {
                #region WASD時無効
                if (AN_isWASDControll)
                {
                    //ただし特例時ならOK（専用Bool） ※今の所とびかかりでのTimeScale操作時が特例
                    if (isANWASDLogLockCancel)
                    { goto 処理開始; }

                    goto 次フレームへ;
                }
                #endregion

                処理開始:
                #region ログモードON処理
                //■ノベルログ読み込み
                //ログが一個もなければなにもせず
                if (novelLogList.Count == 0) { goto 次フレームへ; }

                //ポーズ
                isNovelLogGamePause = true;

                //メインのノベル表示消し（ログが表示前に追加される新仕様になったので）
                novelText.enabled = false;

                //あれば開始 （Boolで1フレーム目）
                isNovelLogVisIng = true;
                //フェード
                isNovelFadeTween = true;
                //操作ワンテンポ待ち用（Tweenでfalseに）
                isNovelLogInputWait = true;

                //ログ表示テキスト書き換え

                ////■■■■どうもUnityでは15000文字以上を同時表示できない？　のでひとまず直近 数十個まででやる
                //Logリスト取得して順番反転し、お尻から並べていく
                var tmpLogList = new List<String>(novelLogList);
                tmpLogList.Reverse();
                string tmpLogStr = null;

                for (int i = 0; i < novelLogList.Count; i++)
                {
                    //個数制限
                    if (i < 25)
                    { tmpLogStr = tmpLogList[i] + "\n<size=20>\n</size>" + tmpLogStr; }
                }
                novelLogText.text = tmpLogStr;

                yield return null;

                #region もし登り時WASDだったらここでキャンセル
                if (AN_isWASDControll && isANWASDLogLockCancel == false)//特例boolついてたらキャンセルしない
                {
                    isNovelLogVisCancel = true;

                    //ポーズ
                    isNovelLogGamePause = false;

                    ////あれば開始 （Boolで1フレーム目）
                    //isNovelLogVisIng = false;
                    //操作ワンテンポ待ち用（Tweenでfalseに）
                    isNovelLogInputWait = false;
                    goto 次フレームへ;
                }
                #endregion

                //■ログテキストの大きさから制限位置割り出し
                //(自動で設定されたHeight * ローカルサイズ) のマイナス  に、少し余裕を持たす（0.4）
                limitNovelTextObjLocalPosY = -
                    (NovelLogTextObj.GetComponent<RectTransform>().sizeDelta.y * NovelLogTextObj.transform.localScale.y)
                    + 0.4f;

                //ウインドウ、ログ表示に切り替え
                logOpenCloseTweener.ChangeEndValue(new Vector2(rectTrs.sizeDelta.x, 0.4f), 0.3f, true)
                    .OnComplete(() => { isNovelLogInputWait = false; })
                    .Restart();
                #endregion
            }

            //■↑でログモードONでの2フレーム目以降
            //ノベルログページマイナス(上がる)
            else if (isNovelLogVisIng && isNovelLogInputWait == false
                && logInputFloat >= 0.1f)
            {
                //制限位置以上なら動く
                if (NovelLogTextObj.transform.localPosition.y > limitNovelTextObjLocalPosY)
                {
                    //テキスト移動
                    NovelTextObj.transform.DOLocalMoveY(NovelTextObj.transform.localPosition.y - novelLogMoveSpeed, 0.1f)
                        .SetUpdate(true);
                    NovelLogTextObj.transform.DOLocalMoveY(NovelLogTextObj.transform.localPosition.y - novelLogMoveSpeed, 0.1f)
                        .SetUpdate(true);
                }
            }

            //ノベルログページプラス（下がる）
            else if (isNovelLogVisIng && isNovelLogInputWait == false
                && logInputFloat <= -0.1)
            {
                //デフォルト位置以下なら動く
                if (NovelLogTextObj.transform.localPosition.y < defNovelTextObjLocalPosY + 0.08f)//少し遊び（本当はClampしたいがうまくいかない）
                {
                    //テキスト移動
                    NovelTextObj.transform.DOLocalMoveY(NovelTextObj.transform.localPosition.y + novelLogMoveSpeed, 0.1f)
                        .SetUpdate(true);
                    NovelLogTextObj.transform.DOLocalMoveY(NovelLogTextObj.transform.localPosition.y + novelLogMoveSpeed, 0.1f)
                        .SetUpdate(true);
                }
                //デフォルト位置より上になろうとしたらログモードキャンセル
                else if (NovelLogTextObj.transform.localPosition.y > defNovelTextObjLocalPosY)
                { isNovelLogVisCancel = true; }
            }

            //ログモード中にボタン押されたらログモードキャンセルbool
            else if (isNovelLogVisIng &&
                (isKetteiDown
                || Input.GetButtonDown(DB.inputDict["ノベルログ"]))//なぜか効かない
                )
            {
                isNovelLogVisCancel = true;
            }
            //ログモード中にキャンセルBoolついたらキャンセル
            else if (isNovelLogVisIng == true && isNovelLogVisCancel)
            {
                isNovelLogVisIng = false;
                isNovelLogVisCancel = false;

                //メインのノベル表示ON（ログが表示前に追加される新仕様になったので）
                novelText.enabled = true;

                //ウインドウ、ノベル表示に切り替え
                logOpenCloseTweener.ChangeEndValue(new Vector2(rectTrs.sizeDelta.x, 0.1f), 0.3f, true)
                    .OnComplete(() => { isNovelLogGamePause = false; })
                    .Restart();

                NovelTextObj.transform.DOLocalMoveY(defNovelTextObjLocalPosY, 0.1f);
                NovelLogTextObj.transform.DOLocalMoveY(defNovelLogTextObjLocalPosY, 0.1f);

                //次のノベルがセットされてなければフェードアウト
                if (isNovelSetVisIng == false) { isNovelFadeTween = false; }
            }

            #endregion //ログビュー

            次フレームへ:
            yield return null;
        }

        #endregion
    }
    IEnumerator NovelSystemUnLoad()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isNovelSystem == true) { yield break; }
        isNovelSystem = true;

        //false（終了）になるまで待機
        while (isNovelSystem) { yield return null; }

        //終了処理
        StopCoroutine(NovelSystemLoadIEnum);
        NovelSystemLoadIEnum = null;

        Destroy(NovelSystemObj);

        Debug.Log("ノベルシステム終了処理完了");

        yield break;
    }

    //■文章キーを受け取り、表示するメソッド群
    IEnumerator tmpNovelSetVisIEnum;

    public void NovelSetVis(string novelKey, bool isAuto = false, bool isWindowContinue = false)
    {
        //■再生中に来たら現在のノベルキャンセル
        if (tmpNovelSetVisIEnum != null)
        {
            //消えるときにログ入れる旧仕様の位置
            //if (currentTextStr != "")//空じゃなければ
            //{ novelLogList.Add(currentTextStr); }

            if (pageCharVisTweener != null) { pageCharVisTweener.Kill(); }//文字表示TweenerKILL

            StopCoroutine(tmpNovelSetVisIEnum);
            tmpNovelSetVisIEnum = null;

        }

        //■ノベルがセットされたBool（フラグ管理用）
        isNovelSetVisIng = true;
        //オートならtrue（イベント用）
        if (isAuto) { isNowNovelAutoVis = true; }
        else { isNowNovelAutoVis = false; }

        //■フェードイン
        isNovelFadeTween = true;

        //■ノベルシステム起動してなかったら起動
        if (isNovelSystem == false)
        {
            //ノベルシステム コルーチン始動
            NovelSystemLoadIEnum = NovelSystemLoad();
            StartCoroutine(NovelSystemLoadIEnum);
        }

        //■ログモード中だったらログモードキャンセルbool（表示開始したらfalseにする（テキスト更新時））
        if (isNovelLogVisIng == true) { isNovelLogVisCancel = true; }

        //■コルーチン起動
        StartCoroutine(tmpNovelSetVisIEnum = NovelSetVisCor(novelKey, isAuto, isWindowContinue));
    }

    Tweener //文字表示数Tweener
        pageCharVisTweener;
    IEnumerator NovelSetVisCor(string novelKey, bool isAuto = false, bool isWindowContinue = false)
    {
        #region 渡されたキーで初期化

        //まず本文空っぽに
        novelText.text = "";

        #region 渡されたキーの文章読み込み　ページごとにリスト化　//ここで翻訳Dictに切り替え
        //渡されたキーの文章読み込み　//ここで翻訳Dictに切り替え
        string
            tmpString;
        if (DB.isEnglish)
        {
            //英語に該当のあるかないかチェック
            if (engNovelDict.Keys.Contains(novelKey))
            {
                tmpString = engNovelDict[novelKey];
            }
            else //なければ日本語
            {
                tmpString = novelDict[novelKey];
                Debug.Log(novelKey.ToString() + "の英語ノベルがない");
            }
            //英語仕様のフォント設定（大きさと行数4）
            novelText.fontSize = 40;
            novelText.margin = new Vector4(0, -15, 0, 0);

        }
        else
        {
            tmpString = novelDict[novelKey];
            //日本語仕様のフォント設定
            novelText.fontSize = 48;
            novelText.margin = new Vector4(0, -9, 0, 0);
        }

        //変数あれば置換
        StringVarChange(ref tmpString);

        string //リッチテキストのタグを取り除いたのも生成
            tmpNoTagString
            = new Regex("<.*?>", RegexOptions.Singleline).Replace(tmpString, "");

        //■キー名0文字目に■があったら、選択肢ウェイトboolOn（選択肢のときは選択肢選ばれるまで終了しない（ウインドウ消さない））
        if (novelKey.IndexOf("■") == 0)//その文字が何文字目にあるか調べて、0（先頭）だった場合
        { isNovelSentakushiWait = true; }


        //頁ごとにリスト化
        List<String>
            tmpPageList = new List<string>(),
            tmpNoTagPageList = new List<string>();//タグ取り除き版

        #endregion

        #region 文章をページ分け
        novelCurrentLastPageInt = 0; //まず総ページ数初期化

        ページ分けループ:
        //まだ*があれば
        if (tmpString.IndexOf("*") >= 0)
        {
            //*までの文字をListに追加し、
            tmpPageList.Add(tmpString.Substring(0, tmpString.IndexOf("*")));
            //そこまでの文字 と *と改行 を消す
            tmpString = tmpString.Remove(0, tmpString.IndexOf("*") + 3);

            //上記処理のNoTag版
            tmpNoTagPageList.Add(tmpNoTagString.Substring(0, tmpNoTagString.IndexOf("*")));
            tmpNoTagString = tmpNoTagString.Remove(0, tmpNoTagString.IndexOf("*") + 3);
            //総ページ数に加算
            novelCurrentLastPageInt++;
            goto ページ分けループ;
        }
        //*がもうないなら
        else
        {
            //総ページ数に加算
            novelCurrentLastPageInt++;
            //最後のページなのでただ追加してループ抜ける
            tmpPageList.Add(tmpString);
            tmpNoTagPageList.Add(tmpNoTagString);
        }
        #endregion

        #region //#if UNITY_EDITOR デバッグ用両言語表示を一旦コメントアウト（UnityTimeLineでエラー出さないようにするため）（内部にもいくつかあるので注意（#if UNITY_EDITORで検索してコメントアウト外していけば復活））
        //#region ■デバッグ用に対の言語文章も同処理で読み込んでおく

        //#region デバッグ用キャンバスなど取得
        //var dbgCanvas
        //    = NovelSystemObj.transform.Find("DebugCanvas").GetComponent<Canvas>();

        //var dbgRectTrs
        //    = dbgCanvas.GetComponent<RectTransform>();
        ////Obj取得
        //var DbgNovelTextObj
        //    = dbgCanvas.transform.Find("NovelText").gameObject;

        ////テキストコンポーネント取得
        //var dbgNovelText
        //    = DbgNovelTextObj.GetComponent<TextMeshProUGUI>();

        //#endregion

        ////まず本文空っぽに
        //dbgNovelText.text = "";

        //#region 渡されたキーの文章読み込み　ページごとにリスト化　//ここで翻訳Dictに切り替え
        ////渡されたキーの文章読み込み　//ここで翻訳Dictに切り替え //処理が本物と逆なのに注意
        //string
        //    dbgTmpString;
        //if (DB.isEnglish)
        //{
        //    dbgTmpString = novelDict[novelKey];
        //    //日本語仕様のフォント設定
        //    dbgNovelText.fontSize = 48;
        //    dbgNovelText.margin = new Vector4(0, -9, 0, 0);
        //}
        //else
        //{
        //    //英語あるかチェック
        //    if (engNovelDict.Keys.Contains(novelKey))
        //    { dbgTmpString = engNovelDict[novelKey]; }
        //    //無ければ日本語
        //    else { dbgTmpString = novelDict[novelKey]; }

        //    //英語仕様のフォント設定（大きさと行数4）
        //    dbgNovelText.fontSize = 40;
        //    dbgNovelText.margin = new Vector4(0, -15, 0, 0);
        //}

        ////変数あれば置換
        //StringVarChange(ref dbgTmpString);

        //string //リッチテキストのタグを取り除いたのも生成
        //    dbgTmpNoTagString
        //    = new Regex("<.*?>", RegexOptions.Singleline).Replace(dbgTmpString, "");


        ////頁ごとにリスト化
        //List<String>
        //    dbgTmpPageList = new List<string>(),
        //    dbgTmpNoTagPageList = new List<string>();//タグ取り除き版

        //#endregion

        //#region 文章をページ分け
        //dbgページ分けループ:
        ////まだ*があれば
        //if (dbgTmpString.IndexOf("*") >= 0)
        //{
        //    //*までの文字をListに追加し、
        //    dbgTmpPageList.Add(dbgTmpString.Substring(0, dbgTmpString.IndexOf("*")));
        //    //そこまでの文字 と *と改行 を消す
        //    dbgTmpString = dbgTmpString.Remove(0, dbgTmpString.IndexOf("*") + 3);

        //    //上記処理のNoTag版
        //    dbgTmpNoTagPageList.Add(dbgTmpNoTagString.Substring(0, dbgTmpNoTagString.IndexOf("*")));
        //    dbgTmpNoTagString = dbgTmpNoTagString.Remove(0, dbgTmpNoTagString.IndexOf("*") + 3);
        //    goto dbgページ分けループ;
        //}
        ////*がもうないなら
        //else
        //{
        //    //最後のページなのでただ追加してループ抜ける
        //    dbgTmpPageList.Add(dbgTmpString);
        //    dbgTmpNoTagPageList.Add(dbgTmpNoTagString);
        //}
        //#endregion

        ////最初に表示するページテキスト読み込み
        //dbgNovelText.text =
        //    dbgTmpPageList[novelCurrentPageInt];  // 現在の文字列

        //#endregion
        #endregion //#endif

        #region 最初のページからウェイトページの場合の処理

        novelCurrentPageInt = 0;// 現在のページ番号(初期化)

        //ウェイトページならウェイトして次ページ
        次もウェイトか検証ループ:
        if (tmpPageList[novelCurrentPageInt] == "w")
        {
            novelText.text = currentTextStr = "";

            //キーウェイトアイコン非表示
            NovelKeyWaitIconObj.SetActive(false);
            yield return new WaitForSeconds(0.3f);//待ち時間

            novelCurrentPageInt++;//ページInt加算
            goto 次もウェイトか検証ループ;
        }
        #endregion

        #region 文字表示用Tweenerなどの設定
        //最初に表示するページテキスト読み込み
        novelText.text =
            currentTextStr =
            tmpPageList[novelCurrentPageInt];  // 現在の文字列

        //ログに入れる（ページ送り前に入れる新仕様の位置）
        novelLogList.Add(currentTextStr);

        bool //現在ページ表示完了検知用
            isPageVisComplete = false;
        float //文字表示スピード
            charVisSpeed = 0.03f;
        if (DB.isEnglish) { charVisSpeed = 0.015f; }//英語なら早く

        //文字表示数Tweener初期化
        pageCharVisTweener
            = novelText.DOMaxVisibleCharacters(0, 0)
            .SetEase(Ease.Linear)
            .SetAutoKill(false);

        //表示文字数Tweener更新
        pageCharVisTweener.ChangeValues
            (0 //0文字スタート
            , tmpNoTagPageList[novelCurrentPageInt].Length //最終表示文字数
            , tmpNoTagPageList[novelCurrentPageInt].Length * charVisSpeed)//表時時間（1文字当たりcharVisSpeed）
            .OnComplete(() => { isPageVisComplete = true; })//表示完了bool
            .Restart();


        isNovelLastPageTurn = false; //最終ページ送り判定

        #endregion



        #region オート読み進め用
        float autoTimeFlt = 0;//オート読み進め時の、文字数分のカウントタイマー（後で代入する）
        float autoPageSpeed = 0.15f;//一文字に対してのウェイト
        if (DB.isEnglish) { autoPageSpeed = 0.05f; }//英語なら早く

        bool isAutoWaitComplete = false;
        if (isAuto) { isAutoWaitComplete = true; } //オート時はTrueでスタート（文字表示完了時にfalseにして、待機してtrueにする）（trueにすると次のページに行く）

        bool isButtonLock = false;        //クリックできなくできる。（オート時などで応用）
        if (isAuto) { isButtonLock = true; } //オート時はTrueでスタート（文字表示完了時にfalseにして、待機してtrueにする）（trueにすると次のページに行く）
        #endregion

        #endregion



        #region ■文字表示・改ページループ

        while (true)
        {
            #region メニューやログ表示モード時はノベル処理しない
            //メニュー表示時は何もしない
            if (isMenuSystem)
            {
                if (pageCharVisTweener.IsPlaying()) { pageCharVisTweener.Pause(); }
            }
            //ログ表示モードであれば ノベル表示モードオフ
            else if (isNovelLogVisIng && novelVisBool)
            {
                novelVisBool = false;
                if (pageCharVisTweener.IsPlaying()) { pageCharVisTweener.Pause(); }
            }
            //ログ表示モード抜けてたら ノベル表示モードON 
            else if (isNovelLogVisIng == false && novelVisBool == false)
            {
                novelVisBool = true;
            }
            #endregion
            //ノベル表示モードであれば（■ログ表示モードから復帰に1フレームかけるためにelseになっている）
            else if (isNovelLogVisIng == false && novelVisBool)
            {
                #region オート表示を途中で切り替え処理（isNowNovelAutoVisで切り替えられる）
                if (isAuto && isNowNovelAutoVis == false)
                {
                    isAuto =
                    isButtonLock =
                    isAutoWaitComplete = false;
                }
                else if (isAuto == false && isNowNovelAutoVis)
                {
                    isAuto =
                    isButtonLock =
                    isAutoWaitComplete = true;
                }
                #endregion
                //Tweener復帰
                if (pageCharVisTweener.IsPlaying() == false) { pageCharVisTweener.Play(); }

                #region ■ノベル表示
                //文字の表示が完了しているなら
                if (isPageVisComplete)
                {
                    //最後のページでなければ
                    if (novelCurrentPageInt < tmpPageList.Count - 1)
                    {
                        #region ■オート時は文字数分待って自動で次のページを表示するフラグを立てる
                        if (isAuto)
                        {
                            //※ループを回さなきゃいけないのでこんなやり方

                            //オートならtrueでここに来るので、
                            if (isAutoWaitComplete)
                            {
                                //falseにして、文字数分タイム代入
                                isAutoWaitComplete = false;
                                autoTimeFlt = tmpNoTagPageList[novelCurrentPageInt].Length * autoPageSpeed;
                            }
                            else//ウェイト完了してなければ
                            {
                                //カウントダウンする。カウントダウンしきっていたらtrue
                                if (autoTimeFlt >= 0) { autoTimeFlt -= 1 * Time.deltaTime; }
                                else { isAutoWaitComplete = true; }//ここでtrueになれば下でクリック時と同じ処理が始まる
                            }
                        }

                        #endregion
                        #region ■クリック時に次のページを表示する
                        if ((isKetteiDown && isButtonLock == false) //クリック時(強制オートじゃなければ)
                            || isNowSkip == true || isNowSoSkip == true //スキップ時でも
                            || isAutoWaitComplete //オートウェイト完了時も
                            )
                        {
                            ////ログに入れる（ページ送り時に入れる旧仕様の位置）
                            //novelLogList.Add(currentTextStr);

                            //ページInt加算
                            novelCurrentPageInt++;

                            #region ■ウェイトページ処理
                            //ウェイトページならウェイトして次ページ
                            次もウェイトか検証ループ子:
                            if (tmpPageList[novelCurrentPageInt] == "w")
                            {
                                novelText.text = "";

                                //キーウェイトアイコン非表示
                                NovelKeyWaitIconObj.SetActive(false);

                                yield return new WaitForSeconds(0.3f);//待ち時間

                                novelCurrentPageInt++;//ページInt加算
                                goto 次もウェイトか検証ループ子;
                            }
                            #endregion

                            //■テキスト更新
                            novelText.text = currentTextStr = tmpPageList[novelCurrentPageInt];

                            //ログに入れる（ページ送り前に入れる新仕様の位置）
                            novelLogList.Add(currentTextStr);

                            //表示文字数0文字
                            novelText.maxVisibleCharacters = 0;
                            isPageVisComplete = false;
                            //表示文字数Tweener更新
                            pageCharVisTweener.ChangeValues
                                (0 //0文字スタート
                                , tmpNoTagPageList[novelCurrentPageInt].Length //表示文字数
                                , tmpNoTagPageList[novelCurrentPageInt].Length * charVisSpeed)//表時時間（1文字当たりcharVisSpeed）
                                .Restart();

                            //■表示開始したのでLogキャンセルboolオフ
                            isNovelLogVisCancel = false;
                        }
                        #endregion

                        #region //デバッグ用キャンバスに対の言語文章表示(無ければメッセージ表示)
                        ////#if UNITY_EDITOR
                        //if (novelCurrentPageInt > dbgTmpPageList.Count - 1)
                        //{ dbgNovelText.text = "<color=#FFE800FF>対の言語のページ終了</color>"; }
                        //else
                        //{ dbgNovelText.text = dbgTmpPageList[novelCurrentPageInt]; }
                        ////#endif
                        #endregion

                    }
                    //最後のページだったら
                    else if (novelCurrentPageInt == tmpPageList.Count - 1)
                    {
                        #region スキップ状態の場合、既読か強制スキップなら終了
                        if (isNowSkip == true || isNowSoSkip == true)
                        {
                            if (DB.isKidokuOnlySkip)
                            {
                                if (DB.kidokuNovelKeyList.Contains(novelKey))
                                {
                                    isNovelLastPageTurn = true;
                                    goto 最後ページか判定;
                                }
                            }
                            else
                            {
                                isNovelLastPageTurn = true;
                                goto 最後ページか判定;
                            }
                        }
                        #endregion

                        #region ■オート時は文字数分待って終了
                        //※ループを回さなきゃいけないのでこんなやり方

                        if (isAuto)
                        {
                            //オートならtrueでここに来るので、
                            if (isAutoWaitComplete == true)
                            {
                                //falseにして、文字数分タイム代入
                                isAutoWaitComplete = false;
                                autoTimeFlt = tmpNoTagPageList[novelCurrentPageInt].Length * autoPageSpeed;
                            }
                            else
                            {
                                if (autoTimeFlt >= 0) { autoTimeFlt -= 1 * Time.deltaTime; }
                                else { isAutoWaitComplete = true; }//ここでtrueになれば下でクリック時と同じ処理が始まる
                            }
                        }
                        #endregion

                        #region ボタンを押して終了
                        if (
                            (isKetteiDown && isButtonLock == false)
                            || isAutoWaitComplete //オートウェイト完了でも
                            )
                        {
                            isNovelLastPageTurn = true;
                            goto 最後ページか判定;
                        }
                        #endregion

                        #region 選択肢だったら押さなくても終了
                        else if (isNovelSentakushiWait)
                        {
                            isNovelLastPageTurn = true;
                            goto 最後ページか判定;
                        }
                        #endregion
                    }
                }
                else // 文字表示完了してないなら、決定で文字をすべて表示する
                {
                    if (isKetteiDown && isButtonLock == false)
                    {
                        //Tweener終了させ
                        pageCharVisTweener.Complete();
                    }
                }

                #region ■キーウェイトアイコン表示 非表示

                //■オートの場合、別アイコン？
                if (isAuto)
                {
                    //オートアイコン表示
                    if (NovelAutoIconObj.activeSelf != true)
                    { NovelAutoIconObj.SetActive(true); }
                }
                else if (isPageVisComplete)//全文字表示完了時
                {
                    //ただし、選択肢で最後のページだった場合 と 途中でノベル消えた場合は表示しない
                    if (isNovelSentakushiWait && novelCurrentPageInt == tmpPageList.Count
                        || isNovelSetVisIng == false)
                    {
                        //キーウェイトアイコン非表示
                        if (NovelKeyWaitIconObj.activeSelf != false)
                        { NovelKeyWaitIconObj.SetActive(false); }
                    }
                    else
                    {
                        //キーウェイトアイコン表示
                        if (NovelKeyWaitIconObj.activeSelf != true)
                        { NovelKeyWaitIconObj.SetActive(true); }
                    }

                    //オートアイコン非表示
                    if (NovelAutoIconObj.activeSelf != false)
                    { NovelAutoIconObj.SetActive(false); }

                }
                else if (isPageVisComplete == false)//文字表示中
                {
                    //キーウェイトアイコン非表示
                    if (NovelKeyWaitIconObj.activeSelf != false)
                    { NovelKeyWaitIconObj.SetActive(false); }

                    //オートアイコン非表示
                    if (NovelAutoIconObj.activeSelf != false)
                    { NovelAutoIconObj.SetActive(false); }
                }
                #endregion

                最後ページか判定:

                //最後のページめくりboolがONなら抜ける
                if (isNovelLastPageTurn)
                {
                    isNovelLastPageTurn = false;
                    goto 抜け;
                }
                #endregion //ノベル表示
            }

            #region //boolでデバッグ用キャンバスオンオフ
            ////#if UNITY_EDITOR
            //if (DB.isLanguageDebug && dbgCanvas.gameObject.activeSelf == false)
            //{ dbgCanvas.gameObject.SetActive(true); }
            //else if (DB.isLanguageDebug == false && dbgCanvas.gameObject.activeSelf)
            //{ dbgCanvas.gameObject.SetActive(false); }
            ////#endif
            #endregion

            yield return null;
        }

        抜け:

        #endregion

        #region 終了処理
        //既読リストに追加
        if (DB.kidokuNovelKeyList.Contains(novelKey) == false)
        { DB.kidokuNovelKeyList.Add(novelKey); }


        //終了処理
        //キーウェイト非表示
        if (NovelKeyWaitIconObj.activeSelf != false)
        { NovelKeyWaitIconObj.SetActive(false); }
        //オートアイコン非表示
        if (NovelAutoIconObj.activeSelf != false)
        { NovelAutoIconObj.SetActive(false); }

        pageCharVisTweener.Kill();


        //■選択肢だったら選択待ち
        if (isNovelSentakushiWait)
        {
            //boolオフでTimeLine進む（選択肢出る）
            isNovelSentakushiWait = false;
            //Debug.Log("ノベルで選択待ち");

            //選択肢選ばれるまでループ
            while (sentakuListNum == 99) { yield return null; }

            //Debug.Log("ノベルで選択待ち終了");
            yield break;
        }

        //ウインドウ残すboolがfalseなら自動でフェードアウト
        if (isWindowContinue == false) { isNovelFadeTween = false; }

        //（いらないかもなので一旦コメントアウト）
        ////同時に次の文章来ると全文字表示しっぱなしなので、1フレ待ってみる。
        //yield return null;

        ////ログに入れて消す(テキスト本体ではなく、ログ保存用のテキスト（フェード中に次のノベル来て重複保存されないように）)（消すときにログ入れる旧仕様の位置）
        //novelLogList.Add(currentTextStr);
        currentTextStr = "";


        isNovelSetVisIng = false;
        isNowNovelAutoVis = false;//イベント用に現在オート表示かどうかのフラグ

        #endregion

        #region //デバッグ用　対の言語に残りページがあったら表示　同じく無ければキャンバスオフ
        ////#if UNITY_EDITOR
        ////まだ文章残っていたら次ページ表示
        //if (novelCurrentPageInt < dbgTmpPageList.Count - 1)
        //{
        //    dbgNovelText.text =
        //        "<color=#FFE800FF>対の言語に残りページがあった</color>\n"
        //        + dbgTmpPageList[novelCurrentPageInt + 1];
        //}
        //else
        //{ dbgCanvas.gameObject.SetActive(false); }
        ////#endif
        #endregion

    }



    #endregion //ノベルシステム

    #region ■VRBlockシステム　カメラ埋まり対策（トラッキングキャンセル　・　暗転）
    #region 解説
    //・基本
    //VRカメラ親に、アジャスト（CameraAdjustTrackingTrs）がある。
    //VRカメラが指定コリダーにぶつかると、衝突直前の位置（VRBlockAreaPlayerStayPrevPos）
    //で計算し、埋まった分アジャストが反対方向に動く（＝その場でとどまる）
    //VRトラッキング位置は取得しておいてあるので（VRTrackingPosObj）、それがコリダーから離れたらアジャスト位置が0になる。
    //衝突判定なのでFixedで処理している。

    //・システム
    //システム起動時にVRTrackingPosObj とFadeBlackVRBlockQuadObj が生成される。
    //VRTrackingPosObjは、現在のVRトラッキング位置を取得しておく用
    //FadeBlackVRBlockQuadObjは、衝突時に暗幕用
    //boolで衝突時に暗幕かけるかどうか設定する。

    //・強制その場トラッキング固定
    //boolでONにする。システムがあると競合するので、システムは自動でUnLoadされる。
    //VRBlockAreaPlayerStayPrevPosはシステムが起動してなくても取得し続けられている。
    //オフにするとアジャスト位置は0になる。（＝現在のトラッキング位置に戻る）

    #endregion
    #region 変数
    [HeaderAttribute("・VRBlockシステム　カメラ埋まり対策")]
    public GameObject //開始時にリソースから読み、終了時に消す用
        VRTrackingPosObj; //止め時のVRカメラの動き保持用（これの子がコリダーから出たり入ったりで判定）
    public GameObject //開始時にリソースから読み、終了時に消す用
        FadeBlackVRBlockQuadObj; //暗転用

    IEnumerator //コルーチン一時停止・終了用
        VRBlockSystemLoadIEnum;
    bool //全終了用Bool
        isVRBlockSystem;


    public bool //■モード別Bool
        isVRBlockBlackOutMode = true,
        isVRTrackingCancelMode; //強制トラッキングキャンセル（360度カメラ状態）

    //■壁衝突用（トラッキングキャンセル）
    public bool //ぶつかっているものがあるかどうか判定
        isVRBlockStay;
    public List<Collider> //ぶつかっているコリジョンリスト
        nowVRBlockCollList = new List<Collider>();
    public Vector3 //ぶつかる直前のVRカメラ位置
        VRBlockAreaPlayerStayPrevPos;

    //■暗転用
    GameObject
        CameraVRBlockTextObj;
    public Renderer
        FadeBlackVRBlockRenderer;
    bool //暗転判定・処理1フレ用 
        isVRGrayOut;

    #endregion
    void VRBlockSystem()
    {
        //すでに起動してたらキャンセル
        if (isVRBlockSystem) { return; }

        //■VRBlockシステム コルーチン始動
        VRBlockSystemLoadIEnum = VRBlockSystemLoad();
        StartCoroutine(VRBlockSystemLoadIEnum);
    }
    IEnumerator VRBlockSystemLoad()
    {
        #region 初期化
        //■VRTrackingPosObj生成
        if (GameObject.Find("VRTrackingPosObj") == null)
        {
            VRTrackingPosObj = Instantiate(Resources.Load("EventSystem/VRBlock/VRTrackingPosObj") as GameObject);
            VRTrackingPosObj.transform.SetParent(CameraUserControlTrs, false);
        }
        //編集用にすでに配置してある場合
        else { VRTrackingPosObj = GameObject.Find("VRTrackingPosObj"); }

        //■FadeBlackVRBlockQuadObj生成
        if (GameObject.Find("FadeBlackVRBlockQuadObj") == null)
        {
            FadeBlackVRBlockQuadObj = Instantiate(Resources.Load("EventSystem/VRBlock/FadeBlackVRBlockQuad") as GameObject);
            FadeBlackVRBlockQuadObj.transform.SetParent(FadeCanvasObj.transform, false);
        }
        //編集用にすでに配置してある場合
        else { FadeBlackVRBlockQuadObj = GameObject.Find("FadeBlackVRBlockQuadObj"); }

        //■黒フェード用
        CameraVRBlockTextObj = FadeBlackVRBlockQuadObj.transform.Find("CameraVRBlockText").gameObject;
        FadeBlackVRBlockRenderer = FadeBlackVRBlockQuadObj.GetComponent<Renderer>();

        Image //アイコンImage
            cameraVRBlockIconImage = FadeBlackVRBlockQuadObj.transform.Find("CameraVRBlockIcon").GetComponent<Image>();
        //透明にしておく
        cameraVRBlockIconImage.color = new Color(1, 1, 1, 0);
        float //出現までの時間カウント用
            blockIconVisTimeFlt = 0;
        bool //出現したbool
            isBlockIconVis = false;

        Tweener //点滅Tweener
        iconFlashingTweener =
            cameraVRBlockIconImage.DOColor(new Color(1, 1, 1, 1), 1)
            .SetLoops(-1, LoopType.Yoyo)
            .SetAutoKill(false)
            .Pause();

        //hukiAreaにペアレント(位置をフキダシ ノベルと同じにするために 簡易)
        cameraVRBlockIconImage.transform.SetParent(HukiAreaTrs, false);

        //■終了処理用コルーチン起動(Boolをfalseで終了する)
        StartCoroutine(VRBlockSystemUnLoad());

        #endregion
        //Debug.Log("VRカメラブロックシステム初期化・設置完了");

        #region ループ //白黒になってアイコン表示など
        while (isVRBlockSystem == true)
        {
            #region コリダーEnterExit判定で作られるリストの数で判定

            if (nowVRBlockCollList.Count > 0)
            {
                if (isVRBlockStay == false)
                {
                    //boolオン
                    isVRBlockStay = true;
                }
            }

            else if (nowVRBlockCollList.Count == 0)
            {
                if (isVRBlockStay)
                {
                    //boolオフ CameraAdjustTrackingObj（親）を位置0（元）に
                    isVRBlockStay = false;
                    CameraAdjustTrackingTrs.localPosition = Vector3.zero;
                }
            }

            #endregion

            #region 暗転モードBoolONの場合
            if (isVRBlockBlackOutMode)
            {
                //カメラ埋まってたら
                if (isVRBlockStay)
                {
                    //暗転していなかったら
                    if (isVRGrayOut == false)
                    {
                        isVRGrayOut = true;

                        //黒アウトやめてグレースケールに
                        //FadeBlackVRBlockRenderer.material.color = new Color(0, 0, 0, 1);
                        PPv2Grayscale();
                        //CameraVRBlockTextObj.SetActive(true);
                    }
                    #region アイコン待機と点滅
                    //出現してなかったら
                    if (isBlockIconVis == false)
                    {
                        //2秒経ってなかったら
                        if (2 > blockIconVisTimeFlt)
                        {
                            cameraVRBlockIconImage.gameObject.SetActive(true);
                            //時間カウント
                            blockIconVisTimeFlt += 1 * Time.deltaTime;
                        }
                        //2秒経ったら
                        else
                        {
                            //点滅Tweener開始
                            iconFlashingTweener.Play().Restart();
                            //true
                            isBlockIconVis = true;
                        }
                    }
                    #endregion
                }
                else //カメラ埋まってない
                {
                    //暗転してたら 元に戻す
                    if (isVRGrayOut)
                    {
                        isVRGrayOut = false;
                        //FadeBlackVRBlockRenderer.material.color = new Color(0, 0, 0, 0);
                        PPv2Grayscale(false);
                        //CameraVRBlockTextObj.SetActive(false);

                        #region ■アイコンオフ
                        cameraVRBlockIconImage.gameObject.SetActive(false);
                        //Tweener
                        iconFlashingTweener.Pause();
                        //透明にしておく
                        cameraVRBlockIconImage.color = new Color(1, 1, 1, 0);
                        //カウントリセット
                        blockIconVisTimeFlt = 0;
                        //オフ
                        isBlockIconVis = false;
                        #endregion
                    }
                }
            }
            #endregion



            yield return null;
        }

        #endregion
        yield break;
    }
    IEnumerator VRBlockSystemUnLoad()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isVRBlockSystem == true) { yield break; }
        isVRBlockSystem = true;
        //false（終了）になるまで待機
        while (isVRBlockSystem) { yield return null; }

        //終了処理
        StopCoroutine(VRBlockSystemLoadIEnum);
        VRBlockSystemLoadIEnum = null;

        Destroy(VRTrackingPosObj);
        Destroy(FadeBlackVRBlockQuadObj);

        isVRBlockStay = false;
        nowVRBlockCollList.Clear();

        //埋まってる最中ならずらし元に戻し
        CameraAdjustTrackingTrs.localPosition = Vector3.zero;

        Debug.Log("VRカメラブロックシステム終了処理完了");
        yield break;
    }

    //■VRBlockAreaColliderSphere当たり判定
    public void OnCollisionEnter_VRBlockAreaColliderSphere(Collider collider)
    {
        if (
            collider.gameObject.layer == LayerMask.NameToLayer("seeRayBlock")
            //|| collider.tag == "TansakuObj"
            //|| collider.tag == "TansakuSeeCollOnObj"
            //|| collider.tag == "TansakuSeeCollOffObj"
            || collider.tag == "ChieriCollider"
            //|| collider.tag == "ReloadSkinMeshCollider" //Stay中に削除された場合の対処が難しいため一旦保留
            && collider.tag != "VRBlockThrough"//例外タグ
            )
        {
            //リストに入れる
            nowVRBlockCollList.Add(collider);
            Debug.Log("顔埋まり" + collider);
        }
    }
    public void OnCollisionExit_VRBlockAreaColliderSphere(Collider collider)
    {
        if (
            collider.gameObject.layer == LayerMask.NameToLayer("seeRayBlock")
            //|| collider.tag == "TansakuObj"
            //|| collider.tag == "TansakuSeeCollOnObj"
            //|| collider.tag == "TansakuSeeCollOffObj"
            || collider.tag == "ChieriCollider"
            //|| collider.tag == "ReloadSkinMeshCollider" //Stay中に削除された場合の対処が難しいため一旦保留
            && collider.tag != "VRBlockThrough"//例外タグ
            )
        {
            nowVRBlockCollList.Remove(collider);
            Debug.Log("顔埋まり" + collider);
        }
    }


    #endregion

    #region ■デバッグモードシステム

    #region 変数
    [HeaderAttribute("・デバッグモード")]
    [SerializeField, Range(0, 100)]
    public float debugMoveSpeed = 10f;

    [HideInInspector]
    public Transform DebugObjectsTrs;

    public int nowRunAllCoroutineInt;
    public List<IEnumerator> nowRunAllIEnumeratorList = new List<IEnumerator>();

    [HideInInspector]
    Text seeCountText;

    bool
        isDebugGamePause = false;

    #region デバッグ用智恵理アニメ情報リード変数（本システムの方と被っていると、ちゃんと動くか確認できないため）
    [HideInInspector]
    public float
       debugGirlAnimNomTime, debugGirlAnimNomPrevTime;
    [HideInInspector]
    public string debugNowGirlAnimClipName;

    #endregion

    #region FPS メモリ計測
    int FPSFrameCount;
    float FPSprevTime;
    float FPS;
    [HideInInspector]
    public Text FPSText, MemoryText;
    [HideInInspector]
    public GameObject FPSTextObj, MemoryTextObj;
    #endregion

    #region ビル破壊テスト01
    GameObject
        Debug_FracturingTest01Obj;

    GameObject
        F_IK_A,
        F_IK_B,
        G_IK_A,
        G_IK_B;


    #endregion

    //上下Arrowキーでフキダシノベル位置チェンジ用
    float debugHukidashiNovelDistanceChangeFloat = 0.5f;


    #endregion
    //本体
    IEnumerator DebugModeSystem()
    {
        DB.isDebugMode = true;

        //DebugObjectsが編集用に設置してあればそれを取得
        if (GameObject.Find("DebugObjects") != null) { DebugObjectsTrs = NullJudgeFind("DebugObjects").transform; }
        else
        {
            GameObject tmpObj = Instantiate(Resources.Load("Debug/DebugObjects"), GameObjectsTrs, false) as GameObject;
            DebugObjectsTrs = tmpObj.transform;
        }

        #region 初期化

        //スキップモードON
        DB.isSkipMode = true;
        //TPSON //TPSCameraシステム起動
        DB.isUserTPSMode = true;
        StartCoroutine(TPSCameraSystemIEnum());
        //メニュー閉じれるように
        DB.isUserInitialSetting = true;

        #region 見てる量デバッグスライダー
        seeCountText = NullJudgeFind("SeeCountText").GetComponent<Text>();
        seeHeadSlider = NullJudgeFind("HeadSlider").GetComponent<Slider>();
        seeBreastSlider = NullJudgeFind("BreastSlider").GetComponent<Slider>();
        seeSpineSlider = NullJudgeFind("SpineSlider").GetComponent<Slider>();
        seePantsSlider = NullJudgeFind("PantsSlider").GetComponent<Slider>();
        seeRHandSlider = NullJudgeFind("RHandSlider").GetComponent<Slider>();
        seeLHandSlider = NullJudgeFind("LHandSlider").GetComponent<Slider>();
        seeRFootSlider = NullJudgeFind("RFootSlider").GetComponent<Slider>();
        seeLFootSlider = NullJudgeFind("LFootSlider").GetComponent<Slider>();
        #endregion 見てる量スライダー取得

        //FPS
        NullJudgeFind(ref FPSTextObj, "FPSText");
        FPSText = FPSTextObj.GetComponent<Text>();
        NullJudgeFind(ref MemoryTextObj, "MemoryText");
        MemoryText = MemoryTextObj.GetComponent<Text>();

        #region イベント名 アニメーションクリップ名
        EvNameText = NullJudgeFind("EvNameText").GetComponent<Text>();//Text取得
        AnimClipNameText = NullJudgeFind("AnimClipNameText").GetComponent<Text>();//Text取得
        #endregion イベント名 アニメーションクリップ名

        #region ビル破壊テスト
        Debug_FracturingTest01Obj = DebugObjectsTrs.Find("Debug_FracturingTest01Obj").gameObject;

        F_IK_A = Debug_FracturingTest01Obj.transform.Find("F_IK_A").gameObject;
        F_IK_B = Debug_FracturingTest01Obj.transform.Find("F_IK_B").gameObject;
        G_IK_A = Debug_FracturingTest01Obj.transform.Find("G_IK_A").gameObject;
        G_IK_B = Debug_FracturingTest01Obj.transform.Find("G_IK_B").gameObject;


        #endregion

        #endregion

        #region ループ
        while (DB.isDebugMode)
        {
            #region //フェードイメージテスト
            //if (Input.GetKeyDown(KeyCode.RightAlt))
            //{ fadeImage.Range = 0.5f; }
            //if (Input.GetKeyUp(KeyCode.RightAlt))
            //{ fadeImage.Range = 0.0f; }
            #endregion

            #region 手製カメラ移動 サイズ操作（デバッグ）

            ////VR時、ホイールクリック+マウスドラッグで強制カメラアングル（アンカー）
            //if (UnityEngine.XR.XRSettings.enabled)
            //{ DebugMouseDragCameraAngle(); }


            //FPS移動（手がWASD操作じゃない場合のみ）
            if (AN_isWASDControll == false)
            {
                //上下AXIS兼用のため、今はキーボードのみに
                if (Input.GetKey("a"))//|| Input.GetAxis(DB.inputDict["選択左右"]) <= -0.1
                { CameraObjectsTrs.Translate(-debugMoveSpeed, 0, 0, Space.Self); }
                if (Input.GetKey("s"))//|| sentakuAxisY <= -0.1 
                { CameraObjectsTrs.Translate(0, 0, -debugMoveSpeed, Space.Self); }
                if (Input.GetKey("d"))//|| Input.GetAxis(DB.inputDict["選択左右"]) >= 0.1
                { CameraObjectsTrs.Translate(debugMoveSpeed, 0, 0, Space.Self); }
                if (Input.GetKey("w"))//|| sentakuAxisY >= 0.1
                { CameraObjectsTrs.Translate(0, 0, debugMoveSpeed, Space.Self); }


                ////VRカメラの見ている方向で移動するようにした。（最終的には物理（Rigidbody）で移動、かつ、単純な加算（斜めが早くなってしまう）じゃなくするべき）
                //if (Input.GetKey("a") || Input.GetAxis(DB.inputDict["選択左右"]) <= -0.1)
                //{
                //    Vector3
                //        cameraLeft = Vector3.Scale(
                //            -VRCameraTrs.right
                //            , new Vector3(1, 0, 1)).normalized;
                //    CameraObjectsTrs.Translate((cameraLeft * debugMoveSpeed) * Time.deltaTime);
                //}
                //if (Input.GetKey("s") || sentakuAxisY <= -0.1)
                //{
                //    Vector3
                //        cameraBack = Vector3.Scale(
                //            -VRCameraTrs.forward
                //            , new Vector3(1, 0, 1)).normalized;
                //    CameraObjectsTrs.Translate((cameraBack * debugMoveSpeed) * Time.deltaTime);
                //}
                //if (Input.GetKey("d") || Input.GetAxis(DB.inputDict["選択左右"]) >= 0.1)
                //{
                //    Vector3
                //        cameraRight = Vector3.Scale(
                //            VRCameraTrs.right
                //            , new Vector3(1, 0, 1)).normalized;
                //    CameraObjectsTrs.Translate((cameraRight * debugMoveSpeed) * Time.deltaTime);
                //}
                //if (Input.GetKey("w") || sentakuAxisY >= 0.1)
                //{
                //    Vector3
                //        cameraForward = Vector3.Scale(
                //            VRCameraTrs.forward
                //            , new Vector3(1, 0, 1)).normalized;
                //    CameraObjectsTrs.Translate((cameraForward * debugMoveSpeed) * Time.deltaTime);
                //}
            }

            #region 1と2で大きさ変更
            if (Input.GetKeyDown("1"))
            {
                nowPlayerLocalScale /= 2;
                SubTitleVis(true, nowPlayerLocalScale.x.ToString("f5"), 0f, true, 0.5f);
            }
            if (Input.GetKeyDown("2"))
            {
                nowPlayerLocalScale *= 2;
                SubTitleVis(true, nowPlayerLocalScale.x.ToString("f5"), 0f, true, 0.5f);
            }
            #endregion

            #region //旧 1と2で大きさ変更
            //if (Input.GetKeyDown("1"))
            //{
            //    if (nowPlayerLocalScale.y < 100f && nowPlayerLocalScale.y >= 0.1f)
            //    { nowPlayerLocalScale -= new Vector3(0.1f, 0.1f, 0.1f); }
            //    else if (nowPlayerLocalScale.y < 0.1f && nowPlayerLocalScale.y >= 0.01f)
            //    { nowPlayerLocalScale -= new Vector3(0.01f, 0.01f, 0.01f); }
            //    else if (nowPlayerLocalScale.y < 0.01f && nowPlayerLocalScale.y >= 0.001f)
            //    { nowPlayerLocalScale -= new Vector3(0.001f, 0.001f, 0.001f); }
            //    else if (nowPlayerLocalScale.y < 0.001f)
            //    { nowPlayerLocalScale -= new Vector3(0.0001f, 0.0001f, 0.0001f); }
            //}
            //if (Input.GetKeyDown("2"))
            //{
            //    if (nowPlayerLocalScale.y < 100f && nowPlayerLocalScale.y >= 0.09f)
            //    { nowPlayerLocalScale += new Vector3(0.1f, 0.1f, 0.1f); }
            //    else if (nowPlayerLocalScale.y < 0.1f && nowPlayerLocalScale.y >= 0.009f)
            //    { nowPlayerLocalScale += new Vector3(0.01f, 0.01f, 0.01f); }
            //    else if (nowPlayerLocalScale.y < 0.01f && nowPlayerLocalScale.y >= 0.0009f)
            //    { nowPlayerLocalScale += new Vector3(0.001f, 0.001f, 0.001f); }
            //    else if (nowPlayerLocalScale.y < 0.001f)
            //    { nowPlayerLocalScale += new Vector3(0.0001f, 0.0001f, 0.0001f); }
            //}
            #endregion
            // 3と4でメソッドを介した大きさ変更
            if (Input.GetKey("3"))
            { grow(); }
            if (Input.GetKey("4"))
            { SeeShrink(); }


            //　高さ　子オブジェクト（座りや立ち上がりなど、身長）
            if (Input.GetKey("5"))
            { CameraAnchorTrs.Translate(0, 0.5f, 0, Space.Self); }
            if (Input.GetKey("6"))
            { CameraAnchorTrs.Translate(0, -0.5f, 0, Space.Self); }

            //　高さ　親オブジェクト（着地位置の高さ）
            if (Input.GetKey("7"))
            { CameraObjectsTrs.Translate(0, 1f, 0, Space.Self); }
            if (Input.GetKey("8"))
            { CameraObjectsTrs.Translate(0, -1f, 0, Space.Self); }

            //// RightAltキーで位置トラッキング・位置・サイズをリセットする
            //if (Input.GetKeyDown(KeyCode.RightAlt))
            //{ CameraReset(); }


            //上下Arrowキーでフキダシノベル位置チェンジ
            if (Input.GetKeyDown(KeyCode.UpArrow))
            {
                debugHukidashiNovelDistanceChangeFloat += 0.05f;
                HukidashiNovelDistanceChange(debugHukidashiNovelDistanceChangeFloat);
                Debug.Log("デバッグ操作でノベル距離変更" + debugHukidashiNovelDistanceChangeFloat);
            }
            if (Input.GetKeyDown(KeyCode.DownArrow))
            {
                debugHukidashiNovelDistanceChangeFloat -= 0.05f;
                HukidashiNovelDistanceChange(debugHukidashiNovelDistanceChangeFloat);
                Debug.Log("デバッグ操作でノベル距離変更" + debugHukidashiNovelDistanceChangeFloat);
            }
            #endregion

            #region TimeLine
            //「」でイベント移動
            if (Input.GetKeyDown("[") && DB.nowEventNum > 0)
            {
                //シーン強制ロードを入れることで残留変数やコルーチンのバグを防ぐ
                DB.isDebugEventChange = true;
                EventMove(DB.nowEventNum - 1, true);
            }

            if (Input.GetKeyDown("]") && DB.nowEventNum < evs.Count)
            {
                //シーン強制ロードを入れることで残留変数やコルーチンのバグを防ぐ
                DB.isDebugEventChange = true;
                EventMove(DB.nowEventNum + 1, true);
            }

            //タイムスケール操作
            if (Input.GetKeyDown(KeyCode.R))
            {
                if (isGamePause)
                {
                    isGamePause = isUserGamePause = isMenuGamePause = isNovelLogGamePause = isDebugGamePause = false;
                }
                else
                {
                    isGamePause = isDebugGamePause = true;
                    Debug.Log("userCameraControlEul" + userCameraControlEul.ToString());
                    if (isGirlAnimReadSystem)
                    {
                        Debug.Log("anim" + girlAnimNomTime + nowGirlAnimClipName);

                        ////別レイヤーあれば //できなかった
                        //if(nowGirlAnimOtherLayerClipNameDict.Count >= 1)
                        //{
                        //    for(int i=0;i< nowGirlAnimOtherLayerClipNameDict.Count; i++)
                        //    {
                        //        Debug.Log(nowGirlAnimOtherLayerClipNameDict[i] + girlAnimOtherLayerNomTimeDict[i]);
                        //    }
                        //}

                    }
                    else { Debug.Log("anim" + debugGirlAnimNomTime + debugNowGirlAnimClipName); }
                }
            }

            //Oキーでスキップモード切替
            if (DB.isSkipMode == true && Input.GetKeyDown(KeyCode.O))
            { DB.isSkipMode = false; }
            else if (DB.isSkipMode == false && Input.GetKeyDown(KeyCode.O))
            { DB.isSkipMode = true; }

            #endregion

            #region アニメーション関係情報表示

            //■智恵理アニメーション情報読み取りシステムが動いていれば読み取りはそれに任せる。動いてなければ自前で読み取り
            if (isGirlAnimReadSystem)
            {
                //智恵理ONが前提
                if (GirlTrs.gameObject.activeSelf)
                { AnimClipNameText.text = nowGirlAnimClipName + " / " + girlAnimNomTime.ToString("f2"); }
                else
                {
                    if (AnimClipNameText.text != "activeOFF")
                    { AnimClipNameText.text = "activeOFF"; }
                }
            }
            else
            {
                //智恵理ONが前提
                if (GirlTrs.gameObject.activeSelf)
                {
                    //現在のモーションノーマライズタイム取得(Prevも)
                    debugGirlAnimNomPrevTime = debugGirlAnimNomTime;
                    debugGirlAnimNomTime = girlAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;

                    //■現在のアニメーションクリップ名取得
                    if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
                    { debugNowGirlAnimClipName = girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }

                    AnimClipNameText.text = debugNowGirlAnimClipName + " / " + debugGirlAnimNomTime.ToString("f2");
                }
                else
                {
                    if (AnimClipNameText.text != "activeOFF")
                    { AnimClipNameText.text = "activeOFF"; }
                }
            }


            #endregion

            #region サイズステータス、見ているカウント
            seeCountText.text = "身長(" + DB.sintyouFloat + "cm)"
                        + "\n" + nowPlayerSintyouFloat.ToString("f1") + "cm"
                        + "\nlocalScale\n" + nowPlayerLocalScale.ToString("f2")
                        + "\n■見ている量■"
                        + "\n顔:" + seeHeadFloat.ToString("f0")
                        + "\n胸:" + seeBreastFloat.ToString("f0")
                        + "\n腰:" + seeSpineFloat.ToString("f0")
                        + "\nパンツ:" + seePantsFloat.ToString("f0")
                        + "\n右手:" + seeRHandFloat.ToString("f0")
                        + "左手:" + seeLHandFloat.ToString("f0")
                        + "\n右足:" + seeRFootFloat.ToString("f0")
                        + "左足:" + seeLFootFloat.ToString("f0");

            //ついでにスライダーに代入
            seeHeadSlider.value = seeHeadFloat;
            seeBreastSlider.value = seeBreastFloat;
            seeSpineSlider.value = seeSpineFloat;
            seePantsSlider.value = seePantsFloat;
            seeRHandSlider.value = seeRHandFloat;
            seeLHandSlider.value = seeLHandFloat;
            seeRFootSlider.value = seeRFootFloat;
            seeLFootSlider.value = seeLFootFloat;
            #endregion

            #region FPS メモリ計測
            ++FPSFrameCount;
            float tmpTime = Time.realtimeSinceStartup - FPSprevTime;

            if (tmpTime >= 1f)
            {
                FPS = FPSFrameCount / tmpTime;
                FPSText.text = FPS.ToString("f0");
                FPSFrameCount = 0;
                FPSprevTime = Time.realtimeSinceStartup;

                //メモリ計測
                //MemoryText.text = "\n" + Profiler.usedHeapSize / 1048576 + " / " + SystemInfo.systemMemorySize + " MB";
                long
                    monoUsed = Profiler.GetMonoUsedSizeLong(),
                    monoSize = Profiler.GetMonoHeapSizeLong(),
                    totalUsed = Profiler.GetTotalAllocatedMemoryLong(), // == Profiler.usedHeapSize
                    totalSize = Profiler.GetTotalReservedMemoryLong();
                string
                    memoryText = string.Format
                    (
                        "mono:{0}/{1} mb({2:f1}%)\n" +
                        "total:{3}/{4} mb({5:f1}%)\n",
                        monoUsed / 1048576, monoSize / 1048576, 100.0 * monoUsed / monoSize,
                        totalUsed / 1048576, totalSize / 1048576, 100.0 * totalUsed / totalSize
                    );

                MemoryText.text = "\n" + memoryText;
            }
            #endregion

            #region システムロード

            //■智恵理表情デバッグモードロードアンロード(LShift+F)
            if (Input.GetKey(KeyCode.LeftShift) && Input.GetKeyDown(KeyCode.F) && isDebugFaceChange == false)
            { StartCoroutine(FaceDebugVis()); }
            else if (Input.GetKey(KeyCode.LeftShift) && Input.GetKeyDown(KeyCode.F) && isDebugFaceChange)
            { isDebugFaceChange = false; }

            //■智恵理モーションデバッグモードロードアンロード(LCtrl+M)
            if (Input.GetKey(KeyCode.LeftControl) && Input.GetKeyDown(KeyCode.M) && isDebugMotionChange == false)
            { StartCoroutine(MotionDebugVis()); }
            else if (Input.GetKey(KeyCode.LeftControl) && Input.GetKeyDown(KeyCode.M) && isDebugMotionChange)
            { isDebugMotionChange = false; }

            //■プレイヤーRigidbody監視システム ロードアンロード(LShift+R)
            if (Input.GetKey(KeyCode.LeftShift) && Input.GetKeyDown(KeyCode.R) && isRigidReadSystem == false)
            { StartCoroutine(RigidReadSystem()); }
            else if (Input.GetKey(KeyCode.LeftShift) && Input.GetKeyDown(KeyCode.R) && isRigidReadSystem)
            { isRigidReadSystem = false; }

            //■ダミーボディ表示非表示
            if (Input.GetKeyDown(KeyCode.F1))
            {
                if (Dummy_Body.activeSelf == false && Dummy_Hand.activeSelf == false)
                {
                    Dummy_Body.SetActive(true);
                    Dummy_Hand.SetActive(true);
                }

                else if (Dummy_Body.activeSelf && Dummy_Hand.activeSelf)
                { Dummy_Body.SetActive(false); }

                else if (Dummy_Body.activeSelf == false && Dummy_Hand.activeSelf)
                { Dummy_Hand.SetActive(false); }
            }

            //■脚登りシステムロードアンロード
            if (Input.GetKeyDown(KeyCode.F2) && isANSystem == false)
            {
                //バトルシステム停止
                isKBSystem = false;

                //■脚のぼりシステム コルーチン始動
                StartCoroutine(AsinoboriSystem());
            }
            else if (Input.GetKeyDown(KeyCode.F2) && isANSystem)
            { isANSystem = false; }

            //■バトルシステムロードアンロード
            if (Input.GetKeyDown(KeyCode.F3) && isKBSystem == false)
            {
                //脚のぼりシステム停止
                isANSystem = false;

                //■バトルシステム コルーチン始動
                KBSystemLoadIEnum = KaijuBattleSystemLoad();
                StartCoroutine(KBSystemLoadIEnum);
            }
            else if (Input.GetKeyDown(KeyCode.F3) && isKBSystem)
            {
                isKBSystem = false;
            }


            //■かくれおに移動システムロードアンロード
            if (Input.GetKeyDown(KeyCode.F4) && isKOSystem == false)
            {
                KO_KakurePointSerchCorCoroutine = StartCoroutine(KakureOniSystemLoad());
                //移動場所01オン
                KO_KakurePosObjsList[1].SetActive(true);
            }
            else if (Input.GetKeyDown(KeyCode.F4) && isKOSystem)
            { isKOSystem = false; }

            //■智恵理スキンメッシュコリダー生成システムロードアンロード
            if (Input.GetKeyDown(KeyCode.F5) && isReloadSkinMeshColliderSystem == false)
            {
                //■智恵理スキンメッシュコリダー生成システム コルーチン始動
                ReloadSkinMeshColliderSystemCor = StartCoroutine(ReloadSkinMeshColliderSystemIEnum());
            }
            else if (Input.GetKeyDown(KeyCode.F5) && isReloadSkinMeshColliderSystem)
            { isReloadSkinMeshColliderSystem = false; }

            //■VRカメラブロックシステムロードアンロード
            if (Input.GetKeyDown(KeyCode.F6) && isVRBlockSystem == false)
            { VRBlockSystem(); }
            else if (Input.GetKeyDown(KeyCode.F6) && isVRBlockSystem)
            { isVRBlockSystem = false; }

            //■智恵理見てる量計測システムロードアンロード
            if (Input.GetKeyDown(KeyCode.F7) && isSeeGirlSystem == false)
            {
                //■智恵理見てる量計測システム コルーチン始動
                StartCoroutine(SeeGirlSystem());
            }
            else if (Input.GetKeyDown(KeyCode.F7) && isSeeGirlSystem)
            {
                isSeeGirlSystem = false;
            }

            //■宿題システムロードアンロード
            if (Input.GetKeyDown(KeyCode.F8) && isHomeworkSystem == false)
            { StartCoroutine(HomeworkSystem()); }
            else if (Input.GetKeyDown(KeyCode.F8) && isHomeworkSystem)
            { isHomeworkSystem = false; }

            //■探索システムロードアンロード
            if (Input.GetKeyDown(KeyCode.F9) && isTansakuSystem == false)
            { StartCoroutine(TansakuSystemLoad()); }
            else if (Input.GetKeyDown(KeyCode.F9) && isTansakuSystem)
            { isTansakuSystem = false; }

            //■フキダシシステムロードアンロード
            if (Input.GetKeyDown(KeyCode.F10) && isHukidashiSystem == false)
            { StartCoroutine(HukidashiSystem()); }
            else if (Input.GetKeyDown(KeyCode.F10) && isHukidashiSystem)
            { isHukidashiSystem = false; }

            #endregion

            yield return null;
        }
        #endregion

        //終了処理
        Destroy(DebugObjectsTrs.gameObject);

        yield break;
    }

    #region ■智恵理 表情・モーション デバッグ表示
    //■表情デバッグ表示(Editor上限定)
    bool isDebugFaceChange = false;
    IEnumerator FaceDebugVis()
    {
#if UNITY_EDITOR
        //boolで重複キャンセル
        if (isDebugFaceChange == true) { yield break; };
        isDebugFaceChange = true;

        #region 初期化
        //■デバッグ表示テキストオブジェクト
        GameObject
            FaceDebugCanvas;
        if (GameObject.Find("FaceDebugCanvas") == null)
        { FaceDebugCanvas = Instantiate(Resources.Load("Debug/DebugFaceVis/FaceDebugCanvas") as GameObject, Bip001HeadTrs, false); }
        //編集用にすでに配置してある場合
        else { FaceDebugCanvas = GameObject.Find("FaceDebugCanvas"); }

        //テキスト
        GameObject
            FaceDebugTextObj = FaceDebugCanvas.transform.Find("FaceDebugText").gameObject;
        Text
            FaceDebugText = FaceDebugTextObj.GetComponent<Text>();

        //■ハッシュkey名前ValueのOrderdDictionary作成
        OrderedDictionary<string, int> faceHashNameDict = new OrderedDictionary<string, int>();
        //まずAnimatorからAnimatorControllerを取得
        UnityEditor.Animations.AnimatorController
            ac = girlAnim.runtimeAnimatorController as UnityEditor.Animations.AnimatorController;
        //foreachでAdd
        foreach (UnityEditor.Animations.ChildAnimatorState childAS in ac.layers[2].stateMachine.states)
        { faceHashNameDict.Add(childAS.state.name, childAS.state.nameHash); }

        //■現在の表情のインデックスを検索。
        //現在の表情のハッシュ取得
        int tmpNowStateHash = girlAnim.GetCurrentAnimatorStateInfo(2).shortNameHash;

        //ハッシュValueから名前Keyを検索
        string tmpkeyName = faceHashNameDict.First(x => x.Value == tmpNowStateHash).Key;

        //KeyValuePair変数生成（取得したハッシュと検索した名前を使ってDictにIndexOfをかけるため）
        KeyValuePair<string, int>
            tmpkeyValuePair = new KeyValuePair<string, int>(tmpkeyName, tmpNowStateHash);

        //■現在の表情のインデックスで、変数生成（現在の表情からデバッグ開始する）
        int //現在の表情と最大値
            nowFaceInt = faceHashNameDict.IndexOf(tmpkeyValuePair),
            faceMaxInt = faceHashNameDict.Count - 1; //0含むためカウント-1

        //■デバッグ開始時テキスト
        FaceDebugText.text =
            faceHashNameDict[nowFaceInt].Key + "\n" +
            nowFaceInt + " / " + faceMaxInt;

        #endregion //初期化
        Debug.Log("表情デバッグ設置・初期化完了");

        #region ループ
        while (isDebugFaceChange)
        {
            #region ホイールで数値と表情とテキスト変更
            if (mouseWheel1FUpDownFloat >= 0.1f)
            {
                if (nowFaceInt < faceMaxInt)
                {
                    ChieriMotion("_noData", 0f, 3);　//クチ開く様に

                    nowFaceInt++;
                    ChieriMotion(faceHashNameDict[nowFaceInt].Key, 0f, 2);
                    FaceDebugText.text =
                        faceHashNameDict[nowFaceInt].Key + "\n" +
                        nowFaceInt + " / " + faceMaxInt;
                }
            }
            else if (mouseWheel1FUpDownFloat <= -0.1f)
            {
                if (nowFaceInt > 0)
                {
                    ChieriMotion("_noData", 0f, 3);　//クチ開く様に

                    nowFaceInt--;
                    ChieriMotion(faceHashNameDict[nowFaceInt].Key, 0f, 2);
                    FaceDebugText.text =
                        faceHashNameDict[nowFaceInt].Key + "\n" +
                        nowFaceInt + " / " + faceMaxInt;
                }
            }
            #endregion //ホイールで数値と表情とテキスト変更

            //■リアルタイムで現表情変わったらデバッグに表示
            //現在表情があって（取得エラー防ぎ）
            if (girlAnim.GetCurrentAnimatorStateInfo(2).shortNameHash != -1)
            {
                tmpNowStateHash = girlAnim.GetCurrentAnimatorStateInfo(2).shortNameHash;
                //デバッグの表情と違ったら
                if (faceHashNameDict[nowFaceInt].Value != tmpNowStateHash)
                {
                    //取得してindex検索してテキストに当てはめ
                    tmpkeyName = faceHashNameDict.First(x => x.Value == tmpNowStateHash).Key;
                    tmpkeyValuePair = new KeyValuePair<string, int>(tmpkeyName, tmpNowStateHash);
                    nowFaceInt = faceHashNameDict.IndexOf(tmpkeyValuePair);
                    FaceDebugText.text =
                        faceHashNameDict[nowFaceInt].Key + "\n" +
                        nowFaceInt + " / " + faceMaxInt;
                }

            }

            yield return null;
        }
        #endregion //ループ

        //終了処理
        Destroy(FaceDebugCanvas);
        Debug.Log("表情デバッグ削除・終了処理完了");
#endif
        yield break;
    }

    //■ポーズ、モーションデバッグ表示(Editor上限定)
    bool isDebugMotionChange = false;

    public List<string> tmpStringList;
    public List<int> tmpIntList;

    IEnumerator MotionDebugVis()
    {
#if UNITY_EDITOR
        //boolで重複キャンセル
        if (isDebugMotionChange == true) { yield break; };
        isDebugMotionChange = true;

        #region 初期化
        //■デバッグ表示テキストオブジェクト
        GameObject
            MotionDebugCanvas;
        if (GameObject.Find("MotionDebugCanvas") == null)
        { MotionDebugCanvas = Instantiate(Resources.Load("Debug/DebugMotionVis/MotionDebugCanvas") as GameObject, Bip001Trs, false); }
        //編集用にすでに配置してある場合
        else { MotionDebugCanvas = GameObject.Find("MotionDebugCanvas"); }

        //テキスト
        GameObject
            MotionDebugTextObj = MotionDebugCanvas.transform.Find("MotionDebugText").gameObject;
        Text
            MotionDebugText = MotionDebugTextObj.GetComponent<Text>();

        //■ハッシュkey名前ValueのOrderdDictionary作成
        OrderedDictionary<string, int> MotionHashNameDict = new OrderedDictionary<string, int>();
        //まずAnimatorからAnimatorControllerを取得
        UnityEditor.Animations.AnimatorController
            ac = girlAnim.runtimeAnimatorController as UnityEditor.Animations.AnimatorController;
        //foreachでステートのリストをAdd（用意されてる）
        foreach (UnityEditor.Animations.ChildAnimatorState childAS in ac.layers[0].stateMachine.states)
        { MotionHashNameDict.Add(childAS.state.name, childAS.state.nameHash); }


        //■サブステートのもAdd
        //まずサブステートのリストも用意されてるので、そこからさらにForeach
        foreach (UnityEditor.Animations.ChildAnimatorStateMachine subSMachine in ac.layers[0].stateMachine.stateMachines)
        {
            //その中のステートのリストをAdd
            foreach (UnityEditor.Animations.ChildAnimatorState subChildAS in subSMachine.stateMachine.states)
            {
                MotionHashNameDict.Add(subChildAS.state.name, subChildAS.state.nameHash);

                ////※BakeIntoPoseなどの情報を拾えるかと思ったけど、このプロパティはアセットパスでFBXを指定して拾わないといけないので駄目だった。
                //UnityEditor.ModelImporterClipAnimation temp = new UnityEditor.ModelImporterClipAnimation();
            }
        }


        //■現在のモーションのインデックスを検索。
        //現在のモーションのハッシュ取得
        int tmpNowStateHash = girlAnim.GetCurrentAnimatorStateInfo(0).shortNameHash;
        //ハッシュValueから名前Keyを検索
        string tmpkeyName = MotionHashNameDict.First(x => x.Value == tmpNowStateHash).Key;

        //KeyValuePair変数生成（取得したハッシュと検索した名前を使ってDictにIndexOfをかけるため）
        KeyValuePair<string, int>
            tmpkeyValuePair = new KeyValuePair<string, int>(tmpkeyName, tmpNowStateHash);

        //■現在のモーションのインデックスで、変数生成（現在の表情からデバッグ開始する）
        int //現在の表情と最大値
            nowMotionInt = MotionHashNameDict.IndexOf(tmpkeyValuePair),
            motionMaxInt = MotionHashNameDict.Count - 1; //0含むためカウント-1

        //■デバッグ開始時テキスト
        MotionDebugText.text =
            MotionHashNameDict[nowMotionInt].Key + "\n" +
            nowMotionInt + " / " + motionMaxInt;

        #endregion //初期化
        Debug.Log("モーションデバッグ設置・初期化完了");

        #region ループ
        while (isDebugMotionChange)
        {
            #region ホイールで数値と表情とテキスト変更
            if (mouseWheel1FUpDownFloat >= 0.1f)
            {
                if (nowMotionInt < motionMaxInt)
                {
                    //ChieriMotion("_noData", 0f, 3);　//クチ開く様に

                    nowMotionInt++;
                    ChieriMotion(MotionHashNameDict[nowMotionInt].Key, 0f, 0);
                    MotionDebugText.text =
                        MotionHashNameDict[nowMotionInt].Key + "\n" +
                        nowMotionInt + " / " + motionMaxInt;
                }
            }
            else if (mouseWheel1FUpDownFloat <= -0.1f)
            {
                if (nowMotionInt > 0)
                {
                    //ChieriMotion("_noData", 0f, 3);　//クチ開く様に

                    nowMotionInt--;
                    ChieriMotion(MotionHashNameDict[nowMotionInt].Key, 0f, 0);
                    MotionDebugText.text =
                        MotionHashNameDict[nowMotionInt].Key + "\n" +
                        nowMotionInt + " / " + motionMaxInt;
                }
            }
            #endregion //ホイールで数値と表情とテキスト変更

            //■リアルタイムで現モーション変わったらデバッグに表示
            //現在モーションがあって（取得エラー防ぎ）
            if (girlAnim.GetCurrentAnimatorStateInfo(0).shortNameHash != -1)
            {
                tmpNowStateHash = girlAnim.GetCurrentAnimatorStateInfo(0).shortNameHash;
                //デバッグのモーションと違ったら
                if (MotionHashNameDict[nowMotionInt].Value != tmpNowStateHash)
                {
                    //取得してindex検索してテキストに当てはめ
                    tmpkeyName = MotionHashNameDict.First(x => x.Value == tmpNowStateHash).Key;
                    tmpkeyValuePair = new KeyValuePair<string, int>(tmpkeyName, tmpNowStateHash);
                    nowMotionInt = MotionHashNameDict.IndexOf(tmpkeyValuePair);
                    MotionDebugText.text =
                        MotionHashNameDict[nowMotionInt].Key + "\n" +
                        nowMotionInt + " / " + motionMaxInt;
                }

            }

            yield return null;
        }
        #endregion //ループ

        //終了処理
        Destroy(MotionDebugCanvas);
        Debug.Log("モーションデバッグ削除・終了処理完了");
#endif
        yield break;
    }
    #endregion

    #endregion

    #region ■智恵理肩ボーンツイストをIK時自動切りシステム
    #region 変数
    bool
        isTwistAutoOffSystem = false;

    //この機能を手動で切り替える用Bool
    bool
        isKataTwistAuto = true;
    #endregion

    IEnumerator TwistAutoOffSystemIEnum()
    {
        if (isTwistAutoOffSystem) { yield break; }
        isTwistAutoOffSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        //スクリプト取得
        TwistRelaxer_CustomV4
            rTwistRelaxer = Bip001_R_UpperArmTrs.GetComponent<TwistRelaxer_CustomV4>(),
            lTwistRelaxer = Bip001_L_UpperArmTrs.GetComponent<TwistRelaxer_CustomV4>();

        //デフォルトのRate取得
        List<float>
            rTwistDefRates = new List<float>(),
            lTwistDefRates = new List<float>();
        for (int i = 0; i < lTwistRelaxer.targets.Length; i++)
        { lTwistDefRates.Add(lTwistRelaxer.targets[i].rate); }
        for (int i = 0; i < rTwistRelaxer.targets.Length; i++)
        { rTwistDefRates.Add(rTwistRelaxer.targets[i].rate); }

        //IKのエフェクター取得されるまで待機
        while (IKLHandEf == null) { yield return null; }
        //直前のウェイト量変数
        float
            preIKLHandEfPosWeight = IKLHandEf.positionWeight,
            preIKRHandEfPosWeight = IKRHandEf.positionWeight;


        //即チェンジ用bool
        bool
            isRIKOn = false,
            isLIKOn = false;


        #endregion
        #region ■■■ループ
        while (isTwistAutoOffSystem)
        {
            //マッピングウェイト0.9999999テスト中
            //if (isKataTwistAuto == false)
            if (false)
            {
                #region IK少しでもONになったら即0
                //ウェイト0じゃなかったら
                if (isLIKOn == false && IKLHandEf.positionWeight != 0)
                {
                    isLIKOn = true;
                    //rateを0に
                    for (int i = 0; i < lTwistRelaxer.targets.Length; i++)
                    {
                        lTwistRelaxer.targets[i].rate = 0;
                    }
                }
                else if (isLIKOn && IKLHandEf.positionWeight == 0)
                {
                    isLIKOn = false;
                    //rateをDefに
                    for (int i = 0; i < lTwistRelaxer.targets.Length; i++)
                    {
                        lTwistRelaxer.targets[i].rate = lTwistDefRates[i];
                    }
                }

                //右
                if (isRIKOn == false && IKRHandEf.positionWeight != 0)
                {
                    isRIKOn = true;
                    for (int i = 0; i < rTwistRelaxer.targets.Length; i++)
                    {
                        rTwistRelaxer.targets[i].rate = 0;
                    }
                }
                else if (isRIKOn && IKRHandEf.positionWeight == 0)
                {
                    isRIKOn = false;
                    for (int i = 0; i < rTwistRelaxer.targets.Length; i++)
                    {
                        rTwistRelaxer.targets[i].rate = rTwistDefRates[i];
                    }
                }
                #endregion

                #region //rateをウェイト量に合わせて調節
                ////ウェイト量動いたら
                //if (preIKLHandEfPosWeight != IKLHandEf.positionWeight)
                //{
                //    //ウェイト量更新
                //    preIKLHandEfPosWeight = IKLHandEf.positionWeight;
                //    //rateをウェイト量に合わせて調節（ウェイト0 = 1　ウェイト1 = 0）
                //    for (int i = 0; i < lTwistRelaxer.targets.Length; i++)
                //    {
                //        lTwistRelaxer.targets[i].rate =
                //            Mathf.Lerp(lTwistDefRates[i], 0, preIKLHandEfPosWeight);
                //    }
                //}
                //if (preIKRHandEfPosWeight != IKRHandEf.positionWeight)
                //{
                //    preIKRHandEfPosWeight = IKRHandEf.positionWeight;
                //    for (int i = 0; i < rTwistRelaxer.targets.Length; i++)
                //    {
                //        rTwistRelaxer.targets[i].rate =
                //            Mathf.Lerp(rTwistDefRates[i], 0, preIKRHandEfPosWeight);
                //    }
                //}
                #endregion
            }


            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }


    #endregion
    #region ■智恵理を見てる量計測システム

    #region 変数
    [HeaderAttribute("・智恵理見てる量計測システム")]
    public bool
        isSeeGirlSystem;

    //一括で処理を与える場合用List（nearAjustSizeやLookAtなど）
    List<GameObject> HitCircleObjList = new List<GameObject>();

    Collider
        hitCircleHeadCollider,
        hitCircleBreastCollider,
        hitCircleSpineCollider,
        hitCirclePantsCollider,
        hitCircleRHandCollider,
        hitCircleLHandCollider,
        hitCircleRFootCollider,
        hitCircleLFootCollider;

    RaycastHit
        playerSeeHeadRayHit,
        playerSeeBreastRayHit,
        playerSeeSpineRayHit,
        playerSeePantsRayHit,
        playerSeeRHandRayHit,
        playerSeeLHandRayHit,
        playerSeeRFootRayHit,
        playerSeeLFootRayHit;

    MeshRenderer
        hitCircleHeadMeshrenderer,
        hitCircleBreastMeshrenderer,
        hitCircleSpineMeshrenderer,
        hitCirclePantsMeshrenderer,
        hitCircleRHandMeshrenderer,
        hitCircleLHandMeshrenderer,
        hitCircleRFootMeshrenderer,
        hitCircleLFootMeshrenderer;



    LayerMask
        seeRayCircleToPlayerLayerMask,
        seeRayPantsCircleToPlayerLayerMask;

    //後で消す用SkirtBoneQuadのList
    List<GameObject> SkirtBoneQuadList = new List<GameObject>();

    #endregion

    IEnumerator SeeGirlSystem()
    {
        if (isSeeGirlSystem) { yield break; }
        isSeeGirlSystem = true;

        #region 初期化

        #region Obj、MeshRenderer、Collider取得
        GameObject
            HitCircleHeadObj,
            HitCircleBreastObj,
            HitCircleSpineObj,
            HitCirclePantsObj,
            HitCircleRHandObj,
            HitCircleLHandObj,
            HitCircleRFootObj,
            HitCircleLFootObj;

        //List追加 と 個別obj変数当てはめ と ヒエラルキー配置 と ペアレント を同時にできた
        HitCircleObjList.Add(HitCircleHeadObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, HeadSphereTrs, false));
        HitCircleObjList.Add(HitCircleBreastObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, BreastSphereTrs, false));
        HitCircleObjList.Add(HitCircleSpineObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, SpineSphereTrs, false));
        HitCircleObjList.Add(HitCirclePantsObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, PantsSphereTrs, false));
        HitCircleObjList.Add(HitCircleRHandObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, RHandSphereTrs, false));
        HitCircleObjList.Add(HitCircleLHandObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, LHandSphereTrs, false));
        HitCircleObjList.Add(HitCircleRFootObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, RFootSphereTrs, false));
        HitCircleObjList.Add(HitCircleLFootObj = Instantiate(Resources.Load("EventSystem/SeeGirl/Prefab/HitCircle") as GameObject, LFootSphereTrs, false));

        //パンツのサークルだけ名前を変更（スカートで視線ブロックを判定するため）
        HitCirclePantsObj.name = "HitCirclePants";

        hitCircleHeadCollider = HitCircleHeadObj.GetComponent<MeshCollider>();
        hitCircleBreastCollider = HitCircleBreastObj.GetComponent<MeshCollider>();
        hitCircleSpineCollider = HitCircleSpineObj.GetComponent<MeshCollider>();
        hitCirclePantsCollider = HitCirclePantsObj.GetComponent<MeshCollider>();
        hitCircleRHandCollider = HitCircleRHandObj.GetComponent<MeshCollider>();
        hitCircleLHandCollider = HitCircleLHandObj.GetComponent<MeshCollider>();
        hitCircleRFootCollider = HitCircleRFootObj.GetComponent<MeshCollider>();
        hitCircleLFootCollider = HitCircleLFootObj.GetComponent<MeshCollider>();

        //MeshRenderer
        hitCircleHeadMeshrenderer = HitCircleHeadObj.transform.GetComponent<MeshRenderer>();
        hitCircleBreastMeshrenderer = HitCircleBreastObj.transform.GetComponent<MeshRenderer>();
        hitCircleSpineMeshrenderer = HitCircleSpineObj.transform.GetComponent<MeshRenderer>();
        hitCirclePantsMeshrenderer = HitCirclePantsObj.transform.GetComponent<MeshRenderer>();
        hitCircleRHandMeshrenderer = HitCircleRHandObj.transform.GetComponent<MeshRenderer>();
        hitCircleLHandMeshrenderer = HitCircleLHandObj.transform.GetComponent<MeshRenderer>();
        hitCircleRFootMeshrenderer = HitCircleRFootObj.transform.GetComponent<MeshRenderer>();
        hitCircleLFootMeshrenderer = HitCircleLFootObj.transform.GetComponent<MeshRenderer>();



        #endregion Trs、MeshRenderer、Collider取得

        #region SkirtBoneQuad生成
        //■GetAllChildrenを使ってスカートボーン挿入（sk_rootがあれば）
        if (sk_rootTrs != null)
        {
            //sk_rootの全子要素を取得する前にtempSkirtBoneQuad生成
            GameObject tempSkirtBoneQuad = Instantiate(ResourceFiles.SkirtBoneQuad);

            //■GetAllChildrenを使ってボーン取得
            List<GameObject> sk_rootObjList = GetAllChildren.GetAll(sk_rootTrs.gameObject);
            foreach (GameObject obj in sk_rootObjList)
            {
                #region SkirtBoneQuad
                if (obj.name == "sk01_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk01_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk01_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk02_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(165, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk02_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(165, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk02_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(165, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk03_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(120, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk03_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(120, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk03_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(120, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk04_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(90, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk04_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(90, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk04_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(90, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk05_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(30, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk05_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(30, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk05_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(30, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk06_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk06_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk06_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(180, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk07_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(330, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk07_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(330, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk07_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(330, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk08_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(290, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk08_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(290, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk08_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(290, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk09_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(250, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk09_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(250, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk09_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(250, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                //if (obj.name == "sk10_02") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(200, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk10_01") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(200, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                if (obj.name == "sk10_00") { tempSkirtBoneQuad.transform.eulerAngles = new Vector3(200, 0, 0); SkirtBoneQuadList.Add(Instantiate(tempSkirtBoneQuad, obj.transform, false)); }
                #endregion SkirtBoneQuad
            }
            //tempスカートのコリジョンオブジェクト削除
            Destroy(tempSkirtBoneQuad);
        }
        #endregion

        //■レイヤーマスク
        //帰ってくるRayは障害物に当たる
        seeRayCircleToPlayerLayerMask =
            (1 << LayerMask.NameToLayer("RayToPlayerTarget")) +
            (1 << LayerMask.NameToLayer("seeRayBlock"));
        //パンツだけスカートを障害物とする
        seeRayPantsCircleToPlayerLayerMask =
            (1 << LayerMask.NameToLayer("RayToPlayerTarget")) +
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("seeRayBlockSkirt"));

        #endregion

        //Debug.Log("智恵理見てる量計測システム初期化");

        #region ループ
        while (isSeeGirlSystem)
        {
            ////ケーブル降り見せてシーンのため急場しのぎでFixedUpdate化（FixedUpdateに運んだ）
            //FixedAction(() =>
            //{
            #region //智恵理見るシステム(FixedUpdateに移動した)
            ////■全Float合算値
            //seeAllFloat = seeHeadFloat + seeBreastFloat + seeSpineFloat + seePantsFloat + seeRHandFloat + seeLHandFloat + seeRFootFloat + seeLFootFloat;

            ////サークルレイ全部にnearSizeAjustとLookAt　//視界ギリギリの大きさでプレイヤーを向き続けるという動作
            //for (int i = 0; i < HitCircleObjList.Count; i++)
            //{
            //    nearSizeAjust(HitCircleObjList[i].transform, 0.03f * GameObjectsTrs.localScale.z);
            //    HitCircleObjList[i].transform.LookAt(PlayerTargetTrs, Vector3.forward);
            //}


            //// playerSeeRayが頭（サークル）と衝突したら(プレイヤーからは障害物判定取らないので当たったら即メソッド実行)
            //if (hitCircleHeadCollider.Raycast(playerSeeRay, out playerSeeHeadRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeHeadRayHit, ref seeHeadFloat, ref hitCircleHeadMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleHeadMeshrenderer.material.color = Color.green;
            //    seeHeadFloat = 0;
            //    seeHeadNomFlt = 0;
            //}

            //// 胸（サークル）
            //if (hitCircleBreastCollider.Raycast(playerSeeRay, out playerSeeBreastRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeBreastRayHit, ref seeBreastFloat, ref hitCircleBreastMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleBreastMeshrenderer.material.color = Color.green;
            //    seeBreastFloat = 0;
            //}

            ////腰
            //if (hitCircleSpineCollider.Raycast(playerSeeRay, out playerSeeSpineRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeSpineRayHit, ref seeSpineFloat, ref hitCircleSpineMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleSpineMeshrenderer.material.color = Color.green;
            //    seeSpineFloat = 0;
            //    seeSpineNomFlt = 0;
            //}

            ////パンツ
            //if (hitCirclePantsCollider.Raycast(playerSeeRay, out playerSeePantsRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeePantsRayHit, ref seePantsFloat, ref hitCirclePantsMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCirclePantsMeshrenderer.material.color = Color.green;
            //    seePantsFloat =
            //    seePantsNomFlt = 0;
            //}

            ////右手
            //if (hitCircleRHandCollider.Raycast(playerSeeRay, out playerSeeRHandRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeRHandRayHit, ref seeRHandFloat, ref hitCircleRHandMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleRHandMeshrenderer.material.color = Color.green;
            //    seeRHandFloat = 0;
            //}

            ////左手
            //if (hitCircleLHandCollider.Raycast(playerSeeRay, out playerSeeLHandRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeLHandRayHit, ref seeLHandFloat, ref hitCircleLHandMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleLHandMeshrenderer.material.color = Color.green;
            //    seeLHandFloat = 0;
            //}

            ////右足
            //if (hitCircleRFootCollider.Raycast(playerSeeRay, out playerSeeRFootRayHit, Mathf.Infinity))
            //{
            //    SeeCircleHit(playerSeeRFootRayHit, ref seeRFootFloat, ref hitCircleRFootMeshrenderer);
            //}
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleRFootMeshrenderer.material.color = Color.green;
            //    seeRFootFloat = 0;
            //    seeRFootNomFlt = 0;
            //}

            ////左足
            //if (hitCircleLFootCollider.Raycast(playerSeeRay, out playerSeeLFootRayHit, Mathf.Infinity))
            //{ SeeCircleHit(playerSeeLFootRayHit, ref seeLFootFloat, ref hitCircleLFootMeshrenderer); }
            //else
            //{
            //    //デバッグ用に外れてたら色緑
            //    hitCircleLFootMeshrenderer.material.color = Color.green;
            //    seeLFootFloat = 0;
            //}
            #endregion
            //});

            //見てる量パーセンテージ生成
            SeeFloatPercentage();

            yield return null;
        }
        #endregion

        #region 終了処理
        //HitCicle関係全消し
        for (int i = 0; i < HitCircleObjList.Count; i++)
        {
            Destroy(HitCircleObjList[i]);
        }
        HitCircleObjList.Clear();

        //SkirtBoneQuad全消し
        for (int i = 0; i < SkirtBoneQuadList.Count; i++)
        {
            Destroy(SkirtBoneQuadList[i]);
        }
        SkirtBoneQuadList.Clear();
        #endregion

        Debug.Log("智恵理見てる量計測システム終了処理完了");
        yield break;
    }

    void SeeCircleHit(RaycastHit playerSeeRayHitCircle, ref float seeFloat, ref MeshRenderer hitCircleMeshrenderer)
    {
        // ターゲットオブジェクトとの差分を求め(プレイヤーからサークルの中心)
        Vector3 temp = PlayerTargetTrs.position - playerSeeRayHitCircle.transform.position;
        // 正規化して方向ベクトルを求める(Rayはターゲットへの場所ではなく"方向"を指定するため)
        Vector3 normal = temp.normalized;
        // Rayの作成
        Ray circleRay = new Ray(playerSeeRayHitCircle.transform.position, normal);
        RaycastHit circlrRayHit;


        #region//Ray発射して処理（パンツ以外とパンツ）（パンツのみ、スカートも障害物になるレイヤーマスク）
        if (playerSeeRayHitCircle.collider.name != "HitCirclePants")
        {
            if (Physics.Raycast(circleRay, out circlrRayHit, Mathf.Infinity, seeRayCircleToPlayerLayerMask))
            {
                //障害物に当たらず、プレイヤーに当たったら
                if (circlrRayHit.collider.tag == "Player")
                {
                    //プレイヤー見てる点からサークル中心への距離計測
                    float seePointToCircleDistance = Vector3.Distance(playerSeeRayHitCircle.point, playerSeeRayHitCircle.transform.position);
                    //プレイヤー位置からサークル中心への距離計測
                    float seePositionToCircleDistance = Vector3.Distance(PlayerTargetTrs.position, playerSeeRayHitCircle.transform.position);

                    #region//＝＝＝使えそうなので↑の計算結果をPublic変数に代入
                    seeNomFlt = 1 * Time.deltaTime / seePointToCircleDistance / seePositionToCircleDistance;
                    //頭 取得
                    if (playerSeeRayHitCircle.collider.transform.parent.name == "HeadSphere") { seeHeadNomFlt = seeNomFlt * 1000000; }//値が小さすぎるので*1000000
                    //腰 取得
                    else if (playerSeeRayHitCircle.collider.transform.parent.name == "SpineSphere") { seeSpineNomFlt = seeNomFlt * 1000000; }//値が小さすぎるので*1000000
                    //右足 取得
                    else if (playerSeeRayHitCircle.collider.transform.parent.name == "RFootSphere") { seeRFootNomFlt = seeNomFlt * 1000000; }//値が小さすぎるので*1000000

                    #endregion//＝＝＝

                    // 加算
                    seeFloat += seeNomFlt;

                    //デバッグ用にヒットしたら一旦色変え
                    hitCircleMeshrenderer.material.color = Color.red;
                    Debug.DrawRay(circleRay.origin, circleRay.direction * 10000, Color.blue);
                    //Debug.Log("だいじょぶ" + circlrRayHit.collider.name + circlrRayHit.transform.parent.name);

                }
                else
                {
                    //デバッグ用に障害物にヒットしたら色変え
                    hitCircleMeshrenderer.material.color = Color.blue;
                    Debug.DrawRay(circleRay.origin, circleRay.direction * 10000, Color.red);
                    //Debug.Log("障害物" + circlrRayHit.collider.name + circlrRayHit.transform.parent.name);
                    //見てる率ゼロ
                    seeFloat = 0;
                }
            }

        }
        else if (playerSeeRayHitCircle.collider.name == "HitCirclePants")
        {

            if (Physics.Raycast(circleRay, out circlrRayHit, Mathf.Infinity, seeRayPantsCircleToPlayerLayerMask))
            {
                //障害物に当たらず、プレイヤーに当たったら
                if (circlrRayHit.collider.tag == "Player")
                {
                    //プレイヤー見てる点からサークル中心への距離計測
                    float seePointToCircleDistance = Vector3.Distance(playerSeeRayHitCircle.point, playerSeeRayHitCircle.transform.position);
                    //プレイヤー位置からサークル中心への距離計測
                    float seePositionToCircleDistance = Vector3.Distance(PlayerTargetTrs.position, playerSeeRayHitCircle.transform.position);

                    seeNomFlt = 1 * Time.deltaTime / seePointToCircleDistance / seePositionToCircleDistance;
                    #region//＝＝＝使えそうなので↑の計算結果をPublic変数に代入
                    //パンツNomFltに
                    seePantsNomFlt = seeNomFlt * 1000000;//値が小さすぎるので*1000000
                    #endregion//＝＝＝

                    // 加算
                    seeFloat += 1.0f * Time.deltaTime / seePointToCircleDistance / seePositionToCircleDistance;

                    //デバッグ用にヒットしたら一旦色変え
                    hitCircleMeshrenderer.material.color = Color.red;
                    Debug.DrawRay(circleRay.origin, circleRay.direction * 10000, Color.blue);
                }
                else
                {
                    //デバッグ用に障害物にヒットしたら色変え
                    hitCircleMeshrenderer.material.color = Color.blue;
                    Debug.DrawRay(circleRay.origin, circleRay.direction * 10000, Color.red);
                    //見てる率ゼロ
                    seeFloat = 0;
                }
            }
        }
        #endregion


    }

    //見てる量パーセンテージ生成（今のところスマホで表示するのみの機能）
    void SeeFloatPercentage()
    {
        //パーセント計算
        seeHeadPercentFloat = (seeHeadFloat / seeAllFloat) * 100;
        seeBreastPercentFloat = (seeBreastFloat / seeAllFloat) * 100;
        seeSpinePercentFloat = (seeSpineFloat / seeAllFloat) * 100;
        seePantsPercentFloat = (seePantsFloat / seeAllFloat) * 100;
        seeHandPercentFloat = ((seeRHandFloat + seeLHandFloat) / seeAllFloat) * 100;
        seeFootPercentFloat = ((seeLFootFloat + seeRFootFloat) / seeAllFloat) * 100;
    }

    #endregion

    #region ■宿題システム

    #region 変数
    bool isHomeworkSystem = false;
    Transform HomeworkObjectsTrs;

    [HideInInspector]
    public HwHit HwHit;

    //オブジェクト
    [HideInInspector]
    public Transform HwPointTrs, DrillTrs, PageTrs;

    //アニメーション用
    [HideInInspector]
    public Animator drillAnim, pageAnim;

    //宿題テクスチャ変更用
    [HideInInspector]
    public Renderer drillRenderer;

    public List<Texture> drillTexturesList;

    // boolのtrue,falseで数値の加算を行う
    [HideInInspector]
    public float
        HwPowFloat,//攻撃力
        HwConcFloat, //集中力
        HwConcCureFloat, //集中力回復量
        HwMoneyFloat, //お金
        HwPriceFloat, //値段
        HwConcDownFloat;  //集中力減退量

    [HideInInspector]
    public bool
        HwConcCureBool,//集中力回復フラグ
        HwColBool;//衝突フラグ

    [HideInInspector]
    public List<GameObject> //ダメージ食らう対象のリスト。HwHitがcolBoolBoolを感知してリストを送り、HwEnemyがそれを見てダメージ食らう
        HwColDmgList = new List<GameObject>();

    [HideInInspector]
    public Slider
        HwConcSlider;

    [HideInInspector]
    public Text
        HwConcText,
        HwMoneyText,
        HwPriceText;

    [HideInInspector]
    public float ct020Float = 0; //進行度?
    [HideInInspector]
    public bool ct020Bool;
    [HideInInspector]
    public Slider ct020Slider;

    [HideInInspector]
    public float ct030Float = 0; //煩悩？
    [HideInInspector]
    public bool ct030Bool;
    [HideInInspector]
    public Slider ct030Slider;

    //リズムをとる用タイマー
    [HideInInspector]
    public float
        HwConcCurTimerFloat,
        HwConcCurRhythmFloat,
        HwNowAttackRhythmFloat,
        HwAttackRhythmMaxFloat;

    //ステージ呼び出し関係
    [HideInInspector]
    public Transform
        HomeworkTrs;
    [HideInInspector]
    public Collider//TimeLineで判定用 だったけど加えてコリダーレイ用にも
        HomeworkCollder;

    //[HideInInspector]
    public int
        HwNowStageInt,
        HwStageClearCountInt,
        HwAllEnmKillCountInt;


    [HideInInspector]
    public Transform //各ステージの親
        HwStageTrs;

    [HideInInspector]
    public List<Transform>//各ステージのリスト 
        HwStagesTrsList = new List<Transform>();
    public List<List<Transform>>//各ステージの敵リスト
        HwStageEnmListList = new List<List<Transform>>();

    [HideInInspector]
    public Transform //ステージ端のステージ移動バー
        HwNextStgBarTrs;
    //PreStgBarObj, 
    //ShopStgBarObj, 
    //MainStgBarObj, 
    //MiddleStgBarObj;        

    //■■12月新規
    [HideInInspector]
    public bool
        isHwVisLock = false, //プレイヤーが宿題できなくするロック
        HwVisBool = false;//プレイヤーが宿題見ているかbool（見たとき離れたときの1フレームを判定）

    [HideInInspector]
    public Slider //ポインターサークルスライダー（アタック・決定までの時間表示）
        HwPointHitSlider,
        HwPointConcSlider;

    [HideInInspector]
    public List<GameObject>
        HwColObjsList = new List<GameObject>();
    [HideInInspector]
    public string
        HwColObjName;

    public GameObject
        HwColObj;
    public HwEnemy
        HwEnemy;
    public HwSEnemy
        HwSEnemy;

    [HideInInspector]
    public int HwEnemyHP;

    //宿題初期位置
    Vector3
        HwDefLocalPos,
        HwDefLocalEul;

    //パワーアップアイコンとお金・値段
    [HideInInspector]
    public Transform
        HwPowUpTrs,
        HwSizeUpTrs,
        HwRhythmUpTrs;
    #endregion

    IEnumerator HomeworkSystem()
    {
        #region 初期化
        //既に起動してればキャンセル
        if (isHomeworkSystem) { yield break; }
        isHomeworkSystem = true;

        //HomeworkObjectsTrsが編集用に設置してあればそれを取得
        if (GameObject.Find("HomeworkObjects") != null) { HomeworkObjectsTrs = NullJudgeFind(ref HomeworkObjectsTrs, "HomeworkObjects"); }
        else
        {
            GameObject tmpObj = Instantiate(Resources.Load("EventSystem/Homework/HomeworkObjects"), GameObjectsTrs, false) as GameObject;
            HomeworkObjectsTrs = tmpObj.transform;
            HomeworkObjectsTrs.gameObject.name = "HomeworkObjects";
        }
        #region 取得

        NullJudgeFind(ref HomeworkTrs, "Homework");
        HomeworkCollder = HomeworkTrs.GetComponent<Collider>();//TimeLineチュートリアルで判定用

        //ポインター あれば取得
        if (GameObject.Find("HwPoint")) { NullJudgeFind(ref HwPointTrs, "HwPoint"); }
        else
        {
            HwPointTrs = Instantiate(Resources.Load("EventSystem/Homework/HwPoint") as GameObject
         , GameObjectsTrs
         , false)
         .transform;//Trs取得
        }

        HwHit = HwPointTrs.GetComponent<HwHit>();

        //スライダー //使わないので消してると取得できないので直接指定
        GameObject HwCanvasObj = HomeworkTrs.Find("HwCanvas").gameObject;
        HwConcSlider = HwCanvasObj.transform.Find("ConcSlider").GetComponent<Slider>();
        //HwConcSlider = NullJudgeFind("ConcSlider").GetComponent<Slider>();
        //ct020Slider = NullJudgeFind("Ct020Slider").GetComponent<Slider>();
        //ct030Slider = NullJudgeFind("Ct030Slider").GetComponent<Slider>();

        //ポインタースライダー
        HwPointHitSlider = HwPointTrs.GetChild(0).GetComponent<Slider>();
        HwPointConcSlider = HwPointTrs.GetChild(1).GetComponent<Slider>();

        HwConcText = HwConcSlider.transform.Find("Text").GetComponent<Text>();


        NullJudgeFind(ref HwNextStgBarTrs, "NextStgBar");

        //パワーアップアイコン
        NullJudgeFind(ref HwPowUpTrs, "PowUp");
        HwMoneyText = HwPowUpTrs.Find("MoneyText").GetComponent<Text>();
        HwPriceText = HwPowUpTrs.Find("PriceText").GetComponent<Text>();
        NullJudgeFind(ref HwSizeUpTrs, "SizeUp");
        NullJudgeFind(ref HwRhythmUpTrs, "RhythmUp");

        //全ステージの親
        NullJudgeFind(ref HwStageTrs, "HwStage");

        #endregion 取得

        #region HomeWorkObjects外の取得
        //Page非表示（アニメ時にONする）
        PageTrs.gameObject.SetActive(false);

        //Animator取得
        drillAnim = DrillTrs.GetComponent<Animator>();
        pageAnim = PageTrs.GetComponent<Animator>();
        drillAnim.enabled = false;

        //宿題テクスチャ変更用
        drillRenderer = DrillTrs.GetComponent<Renderer>();
        drillTexturesList.Clear();
        drillTexturesList = Resources.LoadAll("EventSystem/Homework/DrillTextures/StagesTex", typeof(Texture)).Cast<Texture>().ToList();


        #endregion

        //宿題初期位置取得
        HwDefLocalPos = HomeworkObjectsTrs.localPosition;
        HwDefLocalEul = HomeworkObjectsTrs.localEulerAngles;

        //レイヤー変更
        HwPointTrs.GetComponent<MeshRenderer>().sortingLayerName = "seePoint";


        //敵接触リスト初期化
        HwColObjsList.Clear();


        //■ステージリスト・ステージエネミーリスト・ステージエネミーリストのリスト生成
        HwStagesTrsList.Clear();
        HwStageEnmListList.Clear();

        foreach (Transform stage in HwStageTrs)  //親のTransformに子一覧が入っている（配列として扱えて、順に子の数分ループする)
        {
            List<Transform> tempEnmList = new List<Transform>();
            foreach (Transform enemy in stage.transform)
            {
                //ギミックだったら子（HwEnemy）取得
                if (enemy.gameObject.name.Contains("Gimic"))
                { tempEnmList.Add(enemy.GetChild(0)); }
                //アイテムだったら何も取得しない
                else if (enemy.gameObject.name.Contains("Item"))
                { }
                //それ以外はエネミーとして取得
                else
                { tempEnmList.Add(enemy); }
            }
            HwStagesTrsList.Add(stage);
            HwStageEnmListList.Add(tempEnmList);
        }

        #region //■■■■■初期値■■■■■(DBから読み出し)
        HwPowFloat = DB.HwPowFloat;                      //攻撃力
        HwConcFloat = DB.HwConcFloat;                    //集中力(スタミナ)
        HwConcSlider.maxValue = HwConcFloat;
        HwConcCureFloat = DB.HwConcCureFloat;            //集中力回復量
        HwConcDownFloat = DB.HwConcDownFloat;            //集中力減退量
        HwMoneyFloat = DB.HwMoneyFloat;                  //お金
        HwPriceFloat = DB.HwPriceFloat;                  //値段（倍数）
        HwConcCurRhythmFloat = DB.HwConcCurRhythmFloat;  //回復が始まるまでの時間
        HwAttackRhythmMaxFloat = DB.HwAttackRhythmMaxFloat;    //攻撃の間隔スピード
        HwPointTrs.localScale = DB.HwPointLocalScale; //ポインタサイズ

        HwStageClearCountInt = DB.HwStageClearCountInt;     //クリアしたステージ数
        HwAllEnmKillCountInt = DB.HwAllEnmKillCountInt; //倒した敵の総数

        //DBからステージナンバー呼び出し そのステージに変更
        for (int i = 0; i < HwStagesTrsList.Count; i++)//全ステージオフにして
        { HwStagesTrsList[i].gameObject.SetActive(false); }

        HwNowStageInt = DB.HwNowStageInt;       //現ステージ呼び出し
        HwStagesTrsList[HwNowStageInt].gameObject.SetActive(true);//現ステージオンにする
        drillRenderer.materials[1].mainTexture = drillTexturesList[HwNowStageInt];//現ステージのテクスチャあてはめ
        #endregion
        #region //■■■■■初期値■■■■■(直接設定)(バグ起こすので直接にしようと思ったが開始ステージが直接指定はまずいので、起動前にDB書き換えすることにした）（データとして残し）
        //HwPowFloat = 1;                      //攻撃力
        //HwConcFloat = 20;                    //集中力(スタミナ)
        //HwConcSlider.maxValue = HwConcFloat;
        //HwConcCureFloat = 0.5f;            //集中力回復量
        //HwConcDownFloat = 1;            //集中力減退量
        //HwMoneyFloat = 0;                  //お金
        //HwPriceFloat = 10;                  //値段（倍数）
        //HwConcCurRhythmFloat = 3;  //回復が始まるまでの時間
        //HwAttackRhythmMaxFloat = 1.0f;    //攻撃の間隔スピード
        //HwPointTrs.localScale = new Vector3(0.01f, 0.0001f, 0.01f);//ポインタサイズ

        //HwStageClearCountInt = 0;     //クリアしたステージ数
        //HwAllEnmKillCountInt = 0; //倒した敵の総数

        ////DBからステージナンバー呼び出し そのステージに変更
        //for (int i = 0; i < HwStagesTrsList.Count; i++)//全ステージオフにして
        //{ HwStagesTrsList[i].gameObject.SetActive(false); }

        //HwNowStageInt = 1;       //現ステージ呼び出し
        //HwStagesTrsList[HwNowStageInt].gameObject.SetActive(true);//現ステージオンにする
        //drillRenderer.materials[1].mainTexture = drillTexturesList[HwNowStageInt];//現ステージのテクスチャあてはめ
        #endregion

        #endregion

        #region ゲージ関係やめ初期化

        HwConcSlider.gameObject.SetActive(false);

        HwPowUpTrs.gameObject.SetActive(false);
        HwSizeUpTrs.gameObject.SetActive(false);
        HwRhythmUpTrs.gameObject.SetActive(false);
        #endregion

        //宿題のRayをオリジナルのものに（画面中央より下気味に）
        GameObject HW_SeeRayStartPosObj
            = Instantiate(Resources.Load("EventSystem/Homework/HW_SeeRayStartPosObj") as GameObject
            , VRCameraTrs, false);
        Ray
            hwSeeRay = new Ray(HW_SeeRayStartPosObj.transform.position, VRCameraTrs.forward);


        //Debug.Log("宿題システム初期化完了");
        #region ループ
        //yield return null;//Startに置くとRayエラー出るので一時的に

        while (isHomeworkSystem)
        {
            //前提として、ロックがかかってるかどうか
            if (isHwVisLock == false)
            {
                ////Ray (ズレが生じるので一時保留 playerSeeRayに戻し)
                //hwSeeRay = new Ray(HW_SeeRayStartPosObj.transform.position, VRCameraTrs.forward);

                // playerSeeRayが宿題と衝突したら
                if (HomeworkCollder.Raycast(playerSeeRay, out playerSeeHomeWorkRayHit, Mathf.Infinity))
                {
                    if (HwVisBool == false)//Boolをtrue（1フレームだけ実行）
                    {
                        HwPointTrs.gameObject.SetActive(true);
                        HwVisBool = true;
                    }

                    //■Rayの衝突地点に、オブジェクトHwPointを移動させる
                    //宿題高さ以上の場合のみ（上からのみにするため）（下から覗いても大丈夫にするため）
                    if (playerSeeHomeWorkRayHit.point.y >= HomeworkObjectsTrs.position.y)
                    { HwPointTrs.position = playerSeeHomeWorkRayHit.point; }

                }
                else//■離れたら
                {
                    if (HwVisBool == true) { HwVisBool = false; }//BoolをFalse（1フレームだけ実行）
                    HwPointTrs.gameObject.SetActive(false);
                    HwPointTrs.position = Vector3.zero;
                    //敵接触リスト初期化
                    HwColObjsList.Clear();
                }

                //conc, money ゲージ数値表示
                HwConcText.text = HwConcFloat.ToString("f0") + "/" + HwConcSlider.maxValue.ToString("f0");
                HwMoneyText.text = HwMoneyFloat.ToString();
                HwPriceText.text = HwPriceFloat.ToString();

                // 集中力回復　(一定時間当たってなければ回復し始める)
                if (HwColBool == false)
                {
                    HwConcCurTimerFloat += Time.deltaTime;//一定時間を計算
                    if (HwConcCurTimerFloat > HwConcCurRhythmFloat)//リズムの数値を超えたら
                    {
                        AddConc(0);//回復                
                    }
                }
                else { HwConcCurTimerFloat = 0; }

                // （当たっているフラグ）がtrueで集中力があれば集中力減算メソッド実行
                if (HwColBool == true && HwConcFloat > 0)
                {
                    HwNowAttackRhythmFloat += Time.deltaTime;

                    //敵にダメージとスタミナ減少
                    if (HwNowAttackRhythmFloat > HwAttackRhythmMaxFloat)
                    {
                        HwColDmgList = new List<GameObject>(HwColObjsList);
                        SubConc(0);//1だったけど、スタミナやめるので0
                        HwNowAttackRhythmFloat = 0;
                    }
                }
                else
                {
                    HwNowAttackRhythmFloat = 0;
                }

                //HwPointSlider同期
                if (HwPointHitSlider.value != HwNowAttackRhythmFloat) { HwPointHitSlider.value = HwNowAttackRhythmFloat; }
                if (HwPointHitSlider.maxValue != HwAttackRhythmMaxFloat) { HwPointHitSlider.maxValue = HwAttackRhythmMaxFloat; }

                if (HwPointConcSlider.value != HwConcFloat) { HwPointConcSlider.value = HwConcFloat; }
                if (HwPointConcSlider.maxValue != HwConcSlider.maxValue) { HwPointConcSlider.maxValue = HwConcSlider.maxValue; }


                //HwPoint(HwHit)
                //リストが空っぽなら衝突フラグはずし
                if (HwColObjsList.Count == 0) { HwColBool = false; }
            }
            else//ロックかかってたら
            {
                //ポインターオフと敵接触リストクリア（HwVisBoolとポインターのアクティブで判定（HwVisBoolのみだと初回に取れない））
                if (HwVisBool || HwPointTrs.gameObject.activeSelf)
                {
                    HwVisBool = false;
                    HwPointTrs.gameObject.SetActive(false);
                    HwPointTrs.position = Vector3.zero;
                    //敵接触リスト初期化
                    HwColObjsList.Clear();
                }
            }
            yield return null;
        }

        ////宿題は消さずにアクティブオフ
        //HomeworkObjectsTrs.gameObject.SetActive(false);
        //while (isHomeworkSystem == false)
        //{ yield return null; }
        //HomeworkObjectsTrs.gameObject.SetActive(true);
        //goto ループ;
        #endregion

        #region 終了処理
        Destroy(HomeworkObjectsTrs.gameObject);
        Destroy(HW_SeeRayStartPosObj);
        drillTexturesList.Clear();

        //宿題データ保存
        HwDataSave();

        //ポインター削除
        Destroy(HwPointTrs.gameObject);

        #endregion

        Debug.Log("宿題システム終了処理完了");

        yield break;
    }

    #region 処理メソッド

    public void AddConc(int a)//　concに加算メソッド
    {
        if (HwConcFloat <= HwConcSlider.maxValue)//最大値より低ければ回復
        {
            HwConcFloat += HwConcCureFloat * Time.deltaTime;
            HwConcSlider.value = HwConcFloat;
        }
    }
    public void SubConc(int a)//　concに減算メソッド
    {
        HwConcFloat -= a * HwConcDownFloat;
        //HwConcSlider.value = HwConcFloat;
    }
    public void AddCt020(int a)//　ct020に加算メソッド
    {
        ct020Float += 1.0f + a * Time.deltaTime;
        ct020Slider.value = ct020Float;
    }
    public void AddCt030(int a)//　ct030に加算メソッド
    {
        ct030Float += 1.0f + a * Time.deltaTime;
        ct030Slider.value = ct030Float;
    }

    bool
        isTutorial,//チュートリアル時にいくつか処理させないよう（・ページ移動バー光らせない ）
        isHwClearEventWait; //イベント進行待ちでステージクリア時にページ移動させない用

    public void StageClearCheck()//ステージのクリア管理（敵を全部倒したかどうか）敵復活実行　クリア数カウント
    {
        int activeOffs = 0;//倒した敵の数カウント変数を用意し
        for (int i = 0; i < HwStageEnmListList[HwNowStageInt].Count; i++)//現ステージのオブジェクト数分
        {
            if (HwStageEnmListList[HwNowStageInt][i].gameObject.activeSelf == false)//現ステージのオブジェクトがアクティブか調べて
            {
                activeOffs++;//アクティブじゃなかった数だけカウント
            }
        }

        if (activeOffs == HwStageEnmListList[HwNowStageInt].Count - 1)//アクティブじゃない数が総数より1少なかったら（同数だとそのオブジェクトは非アクティブなのでこのメソッドを実行できない）
        {
            StartCoroutine(StageReload(HwNowStageInt, 3.0f));//ディレイをかけてステージリロード //現在無意味命令 リロードで復活はしないので

            //クリアしたステージ数が現在のステージより少なく、全ステージ数より多くなければ
            if (HwStageClearCountInt < HwNowStageInt && HwStageClearCountInt != HwStagesTrsList.Count - 2)
            {
                if (isHwClearEventWait) { isHwVisLock = true; }//イベント用にウェイトBool立ってれば、宿題を止める

                HwStageClearCountInt++;//クリアステージ数1増える

                if (isTutorial == false && isHwClearEventWait == false)//チュートリアル時、イベントウェイト時は演出なし
                {
                    HwNextStgBarTrs.GetComponent<Renderer>().material.color = Color.blue;//次ステージバー色変更
                    SEPlay(UISEObj, "ui_notification_05");
                }
            }
        }

        HwAllEnmKillCountInt++; //倒した敵の総数プラス1
    }
    public IEnumerator StageReload(int stgNo, float delay)//指定ステージ敵復活メソッド  コルーチンによるディレイメソッド
    {
        yield break;//今は復活しない

        //yield return new WaitForSeconds(delay);//引数分待ってから
        //foreach (GameObject i in stageEnmListList[stgNo])//引数ステージのオブジェクトを
        //{
        //    i.SetActive(true);//アクティブにして

        //    HwEnemy iHwEnemy = i.GetComponent<HwEnemy>();//HwEnemy取得して
        //    iHwEnemy.HP = iHwEnemy.SliderHP.maxValue;//HPを回復させる
        //    iHwEnemy.SliderHP.value = iHwEnemy.HP;//ゲージ表示も更新する
        //    iHwEnemy.SliderHPText.text = iHwEnemy.SliderHP.value.ToString("f0");//HP数も更新する
        //}
    }
    //全ステージリセット
    public IEnumerator HwStageAllReload()
    {
        for (int k = 1; k < HwStagesTrsList.Count; k++)//0ステージ以外全ステージ分ループ
        {
            foreach (Transform i in HwStageEnmListList[k])//引数ステージの敵を
            {
                i.gameObject.SetActive(true);//アクティブにして

                //HwEnemy持っていたら
                if (i.GetComponent<HwEnemy>() != null)
                {
                    HwEnemy tempHwEnemy = i.GetComponent<HwEnemy>();//HwEnemy取得して
                    tempHwEnemy.HP = tempHwEnemy.SliderHP.maxValue;//HPを回復させる
                    tempHwEnemy.SliderHP.value = tempHwEnemy.HP;//ゲージ表示も更新する
                    tempHwEnemy.SliderHPText.text = tempHwEnemy.SliderHP.value.ToString("f0");//HP数も更新する
                }
            }
        }
        yield break;
    }

    #region 宿題ページ移動
    public IEnumerator HwPageMove(int moveStgNoInt)
    {

        //アニメ前のステージ数宣言取得
        int prevStgNoInt = HwNowStageInt;

        SEPlay("paper-take1", HomeworkTrs.gameObject, 0.5f);

        //ステージOFF
        HwStagesTrsList[HwNowStageInt].gameObject.SetActive(false);

        //引数から現在ステージ数に代入
        HwNowStageInt = moveStgNoInt;

        //■アニメ進みか戻りか
        //取得したステージ数より引数指定ステージが大きいか小さいかで判断
        if (prevStgNoInt <= HwNowStageInt)
        {
            //ページ進みアニメ再生
            PageTrs.gameObject.SetActive(true);
            pageAnim.CrossFadeInFixedTime("ページ進み", 0);
        }
        else if (prevStgNoInt > HwNowStageInt)
        {
            //ページ戻りアニメ再生
            PageTrs.gameObject.SetActive(true);
            pageAnim.CrossFadeInFixedTime("ページ戻り", 0);
        }

        //白紙のテクスチャあてはめ
        drillRenderer.materials[1].mainTexture = drillTexturesList[0];
        //バーの色
        HwNextStgBarTrs.GetComponent<Renderer>().material.color = new Color(0, 0, 0, 0);

        yield return new WaitForSeconds(1);

        //ステージON テクスチャ貼る　
        HwStagesTrsList[HwNowStageInt].gameObject.SetActive(true);//現ステージオンにする
        drillRenderer.materials[1].mainTexture = drillTexturesList[HwNowStageInt];//現ステージのテクスチャあてはめ


        //オブジェ表示
        PageTrs.gameObject.SetActive(false);


        ////■ステージ数に合わせてパワーアップアイコン出現
        //if (moveStgNoInt == 3 && HwPowUpTrs.gameObject.activeSelf == false)
        //{
        //    HwPowUpTrs.gameObject.SetActive(true);
        //    SEPlay("ui_magical_back");
        //}
        //if (moveStgNoInt == 4 && HwSizeUpTrs.gameObject.activeSelf == false)
        //{
        //    HwSizeUpTrs.gameObject.SetActive(true);
        //    SEPlay("ui_magical_back");
        //}
        //if (moveStgNoInt == 5 && HwRhythmUpTrs.gameObject.activeSelf == false)
        //{
        //    HwRhythmUpTrs.gameObject.SetActive(true);
        //    SEPlay("ui_magical_back");
        //}


        yield return null;
    }

    #endregion

    #region 宿題ページ強制指定(デバッグ的)
    void HwPageForceMove(int moveStgNumInt)
    {
        for (int i = 0; i < HwStagesTrsList.Count; i++)//全ステージオフにして
        { HwStagesTrsList[i].gameObject.SetActive(false); }

        HwNowStageInt = moveStgNumInt;       //現ステージを指定ステージに

        HwStagesTrsList[HwNowStageInt].gameObject.SetActive(true);//現ステージオンにする
        drillRenderer.materials[1].mainTexture = drillTexturesList[HwNowStageInt];//現ステージのテクスチャあてはめ

        HwStageClearCountInt = HwNowStageInt - 1;     //クリアしたステージ数もそのステージまで
    }

    #endregion

    //HwPointのトリガー(HwHit)
    public void HwPointOnTriggerEnter(Collider col)
    { StartCoroutine(HwPointOnTriggerEnterCor(col)); }
    public IEnumerator HwPointOnTriggerEnterCor(Collider col)
    {
        #region 名前にHwEnmがあったら名前とオブジェクトを取得
        if (col.gameObject.name.Contains("HwEnm"))
        {
            HwColObjName = col.gameObject.name;
            HwColObj = col.gameObject;

            //かつListになければListにも追加
            if (HwColObjsList.Contains(col.gameObject) == false)
            { HwColObjsList.Add(col.gameObject); }

            //かつHwEnemyスクリプトを持ってなければ追加し、HwEnemy変数に代入
            if (HwColObj.GetComponent<HwEnemy>() == null)
            {
                HwEnemy = HwColObj.AddComponent<HwEnemy>();
            }

            #region HwEnemyのHPSetFlagがfalseならHPをセットしフラグtrueにし衝突フラグを送る
            if (HwEnemy.HPSetFlag == false)
            {

                //オブジェクト名から■■数字のみ■■を取り出し敵HP決定
                HwEnemy.HP = int.Parse(new Regex(@"[^0-9]").Replace(HwColObjName, ""));
                HwEnemy.HPSetFlag = true;

                HwColBool = true;//そして衝突しているフラグON
            }
            //HPSetFlagがtrueなら衝突フラグ送るのみ
            else
            {
                HwColBool = true;
            }
            #endregion

            yield break;
        }
        #endregion
        #region 名前にHwSEnmがあったら名前とオブジェクトを取得（Simple版）
        if (col.gameObject.name.Contains("HwSEnm"))
        {
            HwColObjName = col.gameObject.name;
            HwColObj = col.gameObject;

            //かつListになければListにも追加
            if (HwColObjsList.Contains(col.gameObject) == false)
            { HwColObjsList.Add(col.gameObject); }

            //かつHwSEnemyスクリプトを持ってなければ追加し、HwEnemy変数に代入
            if (HwColObj.GetComponent<HwSEnemy>() == null)
            {
                HwSEnemy = HwColObj.AddComponent<HwSEnemy>();
            }

            #region HwSEnemyのHPSetFlagがfalseならHPをセットしフラグtrueにし衝突フラグを送る
            if (HwSEnemy.HPSetFlag == false)
            {

                //オブジェクト名から■■数字のみ■■を取り出し敵HP決定
                HwSEnemy.HP = int.Parse(new Regex(@"[^0-9]").Replace(HwColObjName, ""));
                HwSEnemy.HPSetFlag = true;

                HwColBool = true;//そして衝突しているフラグON
            }
            //HPSetFlagがtrueなら衝突フラグ送るのみ
            else
            {
                HwColBool = true;
            }
            #endregion

            yield break;
        }
        #endregion

        #region ステージ移動
        if (col.gameObject.name == "NextStgBar" && HwStageClearCountInt >= HwNowStageInt)//クリアしてれば
        {
            StartCoroutine(HwPageMove(HwNowStageInt + 1));
        }

        if (col.gameObject.name == "PreStgBar" && HwNowStageInt > 1)//戻るときステージ1より上なら
        {
            //現在ページ戻す必要ないのでキャンセル
            //StartCoroutine(HwPageMove(HwNowStageInt - 1));
        }
        #endregion

        #region 買い物
        if (col.gameObject.name == "PowUp" && HwMoneyFloat >= HwPriceFloat)//当たって金があれば攻撃力UP
        {
            HwMoneyFloat -= HwPriceFloat;
            HwPriceFloat *= 2;

            HwPowFloat++;
            //DataCounter.concDown++;
            HwConcSlider.maxValue++;

            //色チェンジと戻し
            Material tempColMat = col.GetComponent<Renderer>().material;
            Color tempDefColor = tempColMat.color;

            tempColMat.color = Color.red;
            DOTween.To(() => tempColMat.color, (x) => tempColMat.color = x,
                tempDefColor, 1f);
            SEPlay(UISEObj, "ui_powerup_02", HomeworkTrs.gameObject);
        }
        if (col.gameObject.name == "SizeUp" && HwMoneyFloat >= HwPriceFloat)//大きさUP
        {
            HwMoneyFloat -= HwPriceFloat;
            HwPriceFloat *= 2;
            Vector3 HwPointScl = HwPointTrs.localScale;
            HwPointTrs.localScale = new Vector3(HwPointScl.x * 1.3f, HwPointScl.y, HwPointScl.z * 1.3f);
            //DataCounter.concDown++;
            HwConcSlider.maxValue++;

            //色チェンジと戻し
            Material tempColMat = col.GetComponent<Renderer>().material;
            Color tempDefColor = tempColMat.color;

            tempColMat.color = Color.red;
            DOTween.To(() => tempColMat.color, (x) => tempColMat.color = x,
                tempDefColor, 1f);
            SEPlay(UISEObj, "ui_powerup_02", HomeworkTrs.gameObject);
        }
        if (col.gameObject.name == "RhythmUp" && HwMoneyFloat >= HwPriceFloat)//テンポUP
        {
            HwMoneyFloat -= HwPriceFloat;
            HwPriceFloat *= 2;
            HwAttackRhythmMaxFloat /= 2;
            //DataCounter.concDown++;
            HwConcSlider.maxValue++;

            //色チェンジと戻し
            Material tempColMat = col.GetComponent<Renderer>().material;
            Color tempDefColor = tempColMat.color;

            tempColMat.color = Color.red;
            DOTween.To(() => tempColMat.color, (x) => tempColMat.color = x,
                tempDefColor, 1f);
            SEPlay(UISEObj, "ui_powerup_02", HomeworkTrs.gameObject);
        }
        if (col.gameObject.name == "ConcCureUp" && HwMoneyFloat >= HwPriceFloat)//回復量UP
        {
            HwMoneyFloat -= HwPriceFloat;
            HwPriceFloat *= 2;
            HwConcCureFloat++;
            //DataCounter.concDown++;
            HwConcSlider.maxValue++;

            //色チェンジと戻し
            Material tempColMat = col.GetComponent<Renderer>().material;
            Color tempDefColor = tempColMat.color;

            tempColMat.color = Color.red;
            DOTween.To(() => tempColMat.color, (x) => tempColMat.color = x,
                tempDefColor, 1f);
            SEPlay(UISEObj, "ui_powerup_02", HomeworkTrs.gameObject);
        }
        #endregion


    }
    public void HwPointOnTriggerExit(Collider col)
    { HwColObjsList.Remove(col.gameObject); }

    #region HwEnemyのギミックメソッド群

    //追いかける
    public void HwEnemyGimicOikakeru(Transform gimicTrs, Collider col, float oikakeruSpeed, ref bool hwGimicStageMoveBarTouchBool)
    {
        //ステージバーに触れてない間だけ追いかけるようににする
        if (col.gameObject.transform.parent.name == "StageMoveBar" && hwGimicStageMoveBarTouchBool == false)
        {
            hwGimicStageMoveBarTouchBool = true;
        }
        if (hwGimicStageMoveBarTouchBool == false)
        {
            //HwPointへの方向取り
            Vector3 direction = HwPointTrs.position - gimicTrs.position;
            //ノーマライズ
            direction = direction.normalized;
            //移動（ワールド座標なのでYがゼロ（浮かせない））
            gimicTrs.Translate(new Vector3(direction.x, 0, direction.z) * oikakeruSpeed * Time.deltaTime * GameObjectsTrs.localScale.z, Space.World);
        }

    }
    #endregion


    void HwDataSave(bool isHwStageSave = true)//宿題データ保存
    {
        DB.HwPowFloat = HwPowFloat;                             //攻撃力
        DB.HwConcFloat = HwConcFloat;                           //集中力(スタミナ)
        DB.HwConcFloat = HwConcSlider.maxValue;                 //集中力最大値
        DB.HwConcCureFloat = HwConcCureFloat;                   //集中力回復量
        DB.HwConcDownFloat = HwConcDownFloat;                   //集中力減退量
        DB.HwMoneyFloat = HwMoneyFloat;                         //お金
        DB.HwPriceFloat = HwPriceFloat;                         //値段（倍数）
        DB.HwConcCurRhythmFloat = HwConcCurRhythmFloat;         //回復が始まるまでの時間
        DB.HwAttackRhythmMaxFloat = HwAttackRhythmMaxFloat;     //攻撃の間隔スピード
        DB.HwPointLocalScale = HwPointTrs.localScale;           //ポインタサイズ

        //シンプルモード（宿題関係ない場合）はステージ数セーブしない
        if (isHwStageSave == false) { return; }

        DB.HwStageClearCountInt = HwStageClearCountInt;         //クリアしたステージ数
        DB.HwNowStageInt = HwNowStageInt;                       //現ステージ
    }

    #endregion


    #endregion
    #region ■宿題システムのシンプル版（HwStageなどの専用処理を取っ払い、空中や指定場所で行えるように）
    #region 変数
    bool
        isHwSimpleSystem = false;

    //これに入っているコリダーが反応（後入れOKにする）
    List<Collider> HWSColliderList
        = new List<Collider>();

    #endregion
    //シンプル版とはしているが、複雑な処理がそのままなので作り直したい
    //・HwSEnmと名前のついているObjを設置
    //・それがポインターと触れるとHwSEnmスクリプト付与される
    //・HwSEnmスクリプトが消滅時に探索イベント開始命令を出す
    IEnumerator HWSimpleSystemIEnum()
    {
        if (isHwSimpleSystem) { yield break; }
        isHwSimpleSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化


        RaycastHit HWSSeeRayHit = new RaycastHit();

        //ポインター あれば取得
        if (GameObject.Find("HwPoint")) { NullJudgeFind(ref HwPointTrs, "HwPoint"); }
        else
        {
            HwPointTrs = Instantiate(Resources.Load("EventSystem/Homework/HwPoint") as GameObject
         , GameObjectsTrs
         , false)
         .transform;
        }//Trs取得

        //スライダーなど
        HwPointHitSlider = HwPointTrs.GetChild(0).GetComponent<Slider>();
        HwPointConcSlider = HwPointTrs.GetChild(1).GetComponent<Slider>();
        //Concは挙動に必要だったので、ひとまずダミーをポインターに入れて取得
        HwConcSlider = HwPointTrs.GetChild(2).GetComponent<Slider>();

        //■■■■■初期値■■■■■(DBから読み出し)
        HwPowFloat = DB.HwPowFloat;                      //攻撃力
        HwConcFloat = DB.HwConcFloat;                    //集中力(スタミナ)
        HwConcSlider.maxValue = HwConcFloat;
        HwConcCureFloat = DB.HwConcCureFloat;            //集中力回復量
        HwConcDownFloat = DB.HwConcDownFloat;            //集中力減退量
        HwMoneyFloat = DB.HwMoneyFloat;                  //お金
        HwPriceFloat = DB.HwPriceFloat;                  //値段（倍数）
        HwConcCurRhythmFloat = DB.HwConcCurRhythmFloat;  //回復が始まるまでの時間
        HwAttackRhythmMaxFloat = DB.HwAttackRhythmMaxFloat;    //攻撃の間隔スピード
        HwPointTrs.localScale = DB.HwPointLocalScale; //ポインタサイズ

        HwStageClearCountInt = DB.HwStageClearCountInt;     //クリアしたステージ数
        HwAllEnmKillCountInt = DB.HwAllEnmKillCountInt; //倒した敵の総数


        #endregion

        #region ■■■ループ
        while (isHwSimpleSystem)
        {
            //前提として、ロックがかかってるかどうか 探索イベント表示中かどうか
            if (isHwVisLock == false && isTansakuEnter == false && isPlayerAnimReadSystem == false)
            {
                //複数存在を仮定してListFor
                for (int i = 0; i < HWSColliderList.Count; i++)
                {
                    // playerSeeRayが宿題と衝突したら
                    if (HWSColliderList[i].Raycast(playerSeeRay, out HWSSeeRayHit, Mathf.Infinity))
                    {
                        if (HwVisBool == false)//Boolをtrue（1フレームだけ実行）
                        {
                            Debug.Log(i + "Hit");
                            HwPointTrs.gameObject.SetActive(true);
                            HwVisBool = true;
                        }

                        //■Rayの衝突地点に、オブジェクトHwPointを移動させる
                        HwPointTrs.position = HWSSeeRayHit.point;

                        //向かせる保留


                    }
                    else//■離れたら
                    {
                        if (HwVisBool == true) { HwVisBool = false; }//BoolをFalse（1フレームだけ実行）
                        HwPointTrs.gameObject.SetActive(false);
                        HwPointTrs.position = Vector3.zero;
                        //敵接触リスト初期化
                        HwColObjsList.Clear();
                    }
                }

                #region 共通処理
                ////conc, money ゲージ数値表示
                //HwConcText.text = HwConcFloat.ToString("f0") + "/" + HwConcSlider.maxValue.ToString("f0");
                //HwMoneyText.text = HwMoneyFloat.ToString();
                //HwPriceText.text = HwPriceFloat.ToString();

                // 集中力回復　(一定時間当たってなければ回復し始める)
                if (HwColBool == false)
                {
                    HwConcCurTimerFloat += Time.deltaTime;//一定時間を計算
                    if (HwConcCurTimerFloat > HwConcCurRhythmFloat)//リズムの数値を超えたら
                    {
                        AddConc(0);//回復                
                    }
                }
                else { HwConcCurTimerFloat = 0; }

                // （当たっているフラグ）がtrueで集中力があれば集中力減算メソッド実行
                if (HwColBool == true && HwConcFloat > 0)
                {
                    HwNowAttackRhythmFloat += Time.deltaTime;

                    //敵にダメージとスタミナ減少
                    if (HwNowAttackRhythmFloat > HwAttackRhythmMaxFloat)
                    {
                        HwColDmgList = new List<GameObject>(HwColObjsList);
                        SubConc(0);//1だったけど、スタミナやめるので0
                        HwNowAttackRhythmFloat = 0;
                    }
                }
                else
                {
                    HwNowAttackRhythmFloat = 0;
                }

                //HwPointSlider同期
                if (HwPointHitSlider.value != HwNowAttackRhythmFloat) { HwPointHitSlider.value = HwNowAttackRhythmFloat; }
                if (HwPointHitSlider.maxValue != HwAttackRhythmMaxFloat) { HwPointHitSlider.maxValue = HwAttackRhythmMaxFloat; }

                if (HwPointConcSlider.value != HwConcFloat) { HwPointConcSlider.value = HwConcFloat; }
                if (HwPointConcSlider.maxValue != HwConcSlider.maxValue) { HwPointConcSlider.maxValue = HwConcSlider.maxValue; }


                //HwPoint(HwHit)
                //リストが空っぽなら衝突フラグはずし
                if (HwColObjsList.Count == 0) { HwColBool = false; }
            }
            else//ロックかかってたら
            {
                //ポインターオフと敵接触リストクリア（HwVisBoolとポインターのアクティブで判定（HwVisBoolのみだと初回に取れない））
                if (HwVisBool || HwPointTrs.gameObject.activeSelf)
                {
                    HwVisBool = false;
                    HwPointTrs.gameObject.SetActive(false);
                    HwPointTrs.position = Vector3.zero;
                    //敵接触リスト初期化
                    HwColObjsList.Clear();
                }
            }
            #endregion


            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        HWSColliderList.Clear();

        //セーブ（ステータス関係のみ）
        HwDataSave(false);

        //ポインター削除
        Destroy(HwPointTrs.gameObject);


        #endregion
        yield break;
    }


    #endregion
    #region ■宿題システム RME用再開発版（宿題システムとは完全に別物）
    #region 変数
    public bool
        isRMEHwSystem = false;

    //EnmeyのObjリスト
    public List<GameObject> RMEHWEnmObjList
        = new List<GameObject>();

    //public float
    //    RMEHwHitTime = 0;


    #endregion
    public IEnumerator RMEHWSystemIEnum()
    {
        if (isRMEHwSystem) { yield break; }
        isRMEHwSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        //ポインターシステム起動してなければ起動
        if (isSeePointCursorSystem == false)
        { StartCoroutine(SeePointCursorSystemIEnum()); }

        RaycastHit RMEHwSeeRayHit = new RaycastHit();

        bool
            isRMEHwEnmVis = false;
        GameObject
            nowEnmObj = null;

        //ヒエラルキーからRmeHwEnmのObj取得
        RMEHWEnmObjList = GameObject.FindGameObjectsWithTag("RmeHwEnm").ToList();

        Debug.Log(RMEHWEnmObjList.Count);

        #endregion

        #region ■■■ループ
        while (isRMEHwSystem)
        {
            //前提として、ロックがかかってるかどうか (↓探索イベント表示中かどうか)
            if (isHwVisLock == false /*&& isTansakuEnter == false && isPlayerAnimReadSystem == false*/)
            {
                //複数存在を仮定してListFor
                for (int i = 0; i < RMEHWEnmObjList.Count; i++)
                {
                    // playerSeeRayが宿題Enmと衝突したら(Enm側からコリダーレイ)
                    if (RMEHWEnmObjList[i].GetComponent<Collider>().Raycast
                        (playerSeeRay, out RMEHwSeeRayHit, Mathf.Infinity))
                    {
                        //まず いままでと違うEnmObjかどうか
                        if (nowEnmObj != RMEHwSeeRayHit.collider.gameObject || nowEnmObj == null)
                        {
                            //1フレームだけ実行になるはず

                            //現在のEnmに変更
                            nowEnmObj = RMEHwSeeRayHit.collider.gameObject;
                            Debug.Log("RMEHWEnm Hit");
                        }

                    }
                    else//■離れたら
                    {
                        if (nowEnmObj != null)//1フレームだけ実行
                        {
                            nowEnmObj = null;

                        }

                    }
                }

            }


            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        //他にポインターシステム使用するものが起動してなければ終了させる
        SeePointSystemOff();

        #endregion
        yield break;
    }


    #endregion

    #region ■智恵理 & プレイヤーアニメーション情報読み取りシステム

    #region 変数

    bool
        isGirlAnimReadSystem = false;

    [HideInInspector]
    public float
    girlAnimNomTime, girlAnimNomPrevTime;
    [HideInInspector]
    public string nowGirlAnimClipName;

    //■別レイヤー読みたい時はこれを変更（別枠で読む）
    List<int>
        girlAnimReadOtherLayerList = new List<int>();
    OrderedDictionary<int, float>
        girlAnimOtherLayerNomTimeDict = new OrderedDictionary<int, float>();
    OrderedDictionary<int, string>
        nowGirlAnimOtherLayerClipNameDict = new OrderedDictionary<int, string>();

    #endregion
    IEnumerator GirlAnimReadSystem(int otherLayer = 0)
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isGirlAnimReadSystem == true)
        {
            //引数で別レイヤー（0以外）の指定があり、それがリストになければ追加だけして終了
            if (otherLayer != 0 && girlAnimReadOtherLayerList.Contains(otherLayer) == false)
            {
                girlAnimReadOtherLayerList.Add(otherLayer);
            }
            yield break;
        }
        isGirlAnimReadSystem = true;


        #region 初期化
        //別レイヤーリスト指定あれば追加
        if (otherLayer != 0)
        {
            girlAnimReadOtherLayerList.Add(otherLayer);
        }
        #endregion

        #region ループ

        while (isGirlAnimReadSystem)
        {
            //智恵理ONが前提
            if (GirlTrs.gameObject.activeSelf)
            {
                //現在のモーションノーマライズタイム取得(Prevも)
                girlAnimNomPrevTime = girlAnimNomTime;
                girlAnimNomTime = girlAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;

                //■現在のアニメーションクリップ名取得
                if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
                { nowGirlAnimClipName = girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }
            }

            #region 別レイヤー読み込み（Listに追加されれば動く）
            //別レイヤーリストに指定存在したら
            if (girlAnimReadOtherLayerList.Count != 0)
            {
                #region リストに入っているレイヤーの数だけfor処理
                for (int i = 0; i < girlAnimReadOtherLayerList.Count; i++)
                {
                    //nomTimeやClipNameのListに同じレイヤー存在しなければ追加
                    if (girlAnimOtherLayerNomTimeDict.ContainsKey(girlAnimReadOtherLayerList[i]) == false)
                    {
                        girlAnimOtherLayerNomTimeDict.Add(girlAnimReadOtherLayerList[i]
                            , girlAnim.GetCurrentAnimatorStateInfo(girlAnimReadOtherLayerList[i]).normalizedTime);

                        //nomTimeに存在しなければClipNameにも存在しないので追加
                        nowGirlAnimOtherLayerClipNameDict.Add(girlAnimReadOtherLayerList[i]
                        , girlAnim.GetCurrentAnimatorClipInfo(girlAnimReadOtherLayerList[i])[0].clip.name);

                    }
                    else //存在していれば更新
                    {
                        //ノーマライズタイム
                        girlAnimOtherLayerNomTimeDict[girlAnimReadOtherLayerList[i]]
                            = girlAnim.GetCurrentAnimatorStateInfo(girlAnimReadOtherLayerList[i]).normalizedTime;

                        //Clip名 （空の時エラーはかないように）
                        if (girlAnim.GetCurrentAnimatorClipInfo(girlAnimReadOtherLayerList[i]).Length != 0)
                        {
                            nowGirlAnimOtherLayerClipNameDict[girlAnimReadOtherLayerList[i]]
                            = girlAnim.GetCurrentAnimatorClipInfo(girlAnimReadOtherLayerList[i])[0].clip.name;
                        }
                    }
                }
                #endregion
            }
            #endregion

            yield return null;
        }

        #endregion

        #region 終了処理
        //別レイヤーリストクリア
        girlAnimReadOtherLayerList.Clear();

        #endregion

        yield break;
    }

    #region 変数

    bool
        isPlayerAnimReadSystem = false;

    [HideInInspector]
    public float
    playerAnimNomTime, playerAnimNomPrevTime;
    [HideInInspector]
    public string nowPlayerAnimClipName;

    #endregion
    IEnumerator PlayerAnimReadSystem()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isPlayerAnimReadSystem == true) { yield break; }
        isPlayerAnimReadSystem = true;

        #region 初期化

        #endregion

        #region ループ

        while (isPlayerAnimReadSystem)
        {

            //現在のモーションノーマライズタイム取得(Prevも)
            playerAnimNomPrevTime = playerAnimNomTime;
            playerAnimNomTime = playerAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;

            //■現在のアニメーションクリップ名取得
            if (playerAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
            { nowPlayerAnimClipName = playerAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }

            yield return null;
        }

        #endregion

        yield break;
    }

    #endregion
    #region ■智恵理スキンメッシュコリダー生成システム

    //解説
    //SkinnedMeshColliderにはリアルタイムで現メッシュを書き出す機能がある
    //それをメッシュコライダーで読み込む。
    //（メッシュは移動ではなく変形しているので、位置情報がChieriと同じでなければならないのに注意）

    //重いので手登り時にVRCameraにペアレントしている範囲コライダー(HitReloadSkinMeshCollider)と触れたときのみ書き出すようになっている。（判定用のプリミティブコリダーをそれぞれパーツに付与）

    //SkinMeshCollider掴むとき、何に手をペアレントするかの処理はANシステムに入ってる。

    //スケールによる掴み位置問題は、登りシステムでの掴む際に対応のオブジェを指定することで一旦解決（手のコリダーなら手のObjにという感じ）
    //※ただしウェイトの動きに追従はしないため、手の埋まり対策が必要。ちえりがビタッと止まってるなら完璧。
    //メッシュのポリゴン頂点読み込む？
    //※あとボーンが分かれてるのをどうするか。

    #region 変数
    bool
        isReloadSkinMeshColliderSystem = false;
    Coroutine
        ReloadSkinMeshColliderSystemCor;


    GameObject
        //全部入れて、Chieriの直下にペアレントするフォルダ（メッシュの位置はChieriの位置に準拠するため）
        ReloadSkinMeshColliderFolder,
        //メッシュが書き出しの時点で回転しているのでそれの矯正用
        Rotate270Folder;

    //アレイでタグついたコリダーObj取得用
    public GameObject[]
        ChieriSkinMeshColliderObjArray;

    //実際に挙動するオブジェやコンポーネントをListで処理する
    public List<SkinnedMeshRenderer>
        ChieriSkinMeshColliderSkinnedMeshRendList;
    public List<GameObject>
        RSMC_ObjList;
    public List<Mesh>
        RSMC_MeshList;
    public List<MeshCollider>
        RSMC_MeshColliderList;

    //挙動許可Bool
    public List<bool>
        RSMC_isMeshReloadList;

    bool //初期設定終わったらFixedでリロード開始する用
        isFixedRSMCReload = false;

    GameObject
        HitReloadSkinMeshCollider;

    #endregion

    //■作業予定
    //範囲コリダーに触れてないメッシュコリダーを 消去orなにかにペアレントしてそれなりに挙動するように
    //（頂点位置読み取りでなんとかいけないか） （不許可時はConvexしたものを該当位置にペアレント？）
    //リロードを、大きく動いた時のみにする判定？（じっとしてて更新し続けしないように）（ボーンの回転具合など？）


    IEnumerator ReloadSkinMeshColliderSystemIEnum()
    {
        if (isReloadSkinMeshColliderSystem) { yield break; }
        isReloadSkinMeshColliderSystem = true;

        List<GameObject> exitDestroyObjList = new List<GameObject>();
        List<HitAreaTrigger> exitDestroyScriptList = new List<HitAreaTrigger>();

        #region 初期化

        //フォルダ
        ReloadSkinMeshColliderFolder = new GameObject();
        ReloadSkinMeshColliderFolder.name = "ReloadSkinMeshChieriColliderFolder";
        //本体Meshと同じ位置にするためペアレント
        ReloadSkinMeshColliderFolder.transform.SetParent(GirlTrs.transform, true);
        ReloadSkinMeshColliderFolder.transform.localPosition =
        ReloadSkinMeshColliderFolder.transform.localEulerAngles = Vector3.zero;


        //回転フォルダ
        Rotate270Folder = new GameObject();
        Rotate270Folder.name = "Rotate270Folder";
        Rotate270Folder.transform.SetParent(ReloadSkinMeshColliderFolder.transform, false);
        Rotate270Folder.transform.localEulerAngles = new Vector3(270, 0, 0);

        //タグでスキンメッシュコリダー（大元）を取得
        ChieriSkinMeshColliderObjArray = GameObject.FindGameObjectsWithTag("ChieriSkinMeshCollider");
        //リスト初期化
        ChieriSkinMeshColliderSkinnedMeshRendList.Clear();
        RSMC_ObjList.Clear();
        RSMC_MeshList.Clear();
        RSMC_MeshColliderList.Clear();
        RSMC_isMeshReloadList.Clear();

        for (int i = 0; i < ChieriSkinMeshColliderObjArray.Length; i++)
        {
            //SkinMeshあれば
            if (ChieriSkinMeshColliderObjArray[i].GetComponent<SkinnedMeshRenderer>() != null)
            {
                //大元のスキンメッシュレンダラーを取得
                ChieriSkinMeshColliderSkinnedMeshRendList.Add
                    (ChieriSkinMeshColliderObjArray[i].GetComponent<SkinnedMeshRenderer>());

                //コリダーのオブジェ生成して設置
                RSMC_ObjList.Add(new GameObject());
                RSMC_ObjList[i].name = ChieriSkinMeshColliderObjArray[i].name + "Obj";
                RSMC_ObjList[i].transform.SetParent(Rotate270Folder.transform, false);

                //Posが0,0,0でなければ代入
                if (ChieriSkinMeshColliderObjArray[i].transform.localPosition != Vector3.zero)
                {
                    RSMC_ObjList[i].transform.localPosition
                        = ChieriSkinMeshColliderObjArray[i].transform.localPosition * GameObjectsTrs.localScale.z;
                    //スケールはそのままになるため100倍
                }
                //Rotも0,0,0でなければ代入
                if (ChieriSkinMeshColliderObjArray[i].transform.localEulerAngles != Vector3.zero)
                {
                    RSMC_ObjList[i].transform.localEulerAngles
                        = ChieriSkinMeshColliderObjArray[i].transform.localEulerAngles;
                }


                //タグとレイヤーを変更
                RSMC_ObjList[i].tag = "ReloadSkinMeshCollider";
                RSMC_ObjList[i].layer = LayerMask.NameToLayer("SeeGirlIgnoreCollider");

                //大元スキンメッシュレンダラーから現状のメッシュ生成時に保持する用
                RSMC_MeshList.Add(new Mesh());

                //ObjにMeshColliderを付与
                RSMC_MeshColliderList.Add
                    (RSMC_ObjList[i].AddComponent<MeshCollider>());

                //CookingOptionsをなしにすることで、大分軽量化された（若干ポリゴン甘くなるかも）
                RSMC_ObjList[i].GetComponent<MeshCollider>().cookingOptions = MeshColliderCookingOptions.None;


                //動作許可Bool追加
                RSMC_isMeshReloadList.Add(new bool());

                #region ■挙動許可範囲コリダー及びスクリプト付与(これは結局個別なので個別名判定必要)

                #region //以前のもの
                //if ("L_Ashikubi_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                //{
                //    RSMC_HitAreaCollObjList.Add(Instantiate(Resources.Load
                //        ("EventSystem/ReloadSkinMeshCollider/Prefab/L_Ashikubi_Coll_HitAreaColl") as GameObject
                //        , GirlLFootTrs, false));
                //}
                //else if ("L_Knee_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                //{
                //    RSMC_HitAreaCollObjList.Add(Instantiate(Resources.Load
                //        ("EventSystem/ReloadSkinMeshCollider/Prefab/L_Knee_Coll_HitAreaColl") as GameObject
                //        , GirlLCalfTrs, false));
                //}
                //else if ("R_Ashikubi_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                //{
                //    RSMC_HitAreaCollObjList.Add(Instantiate(Resources.Load
                //        ("EventSystem/ReloadSkinMeshCollider/Prefab/R_Ashikubi_Coll_HitAreaColl") as GameObject
                //        , GirlRFootTrs, false));
                //}
                //else if ("R_knee_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                //{
                //    RSMC_HitAreaCollObjList.Add(Instantiate(Resources.Load
                //        ("EventSystem/ReloadSkinMeshCollider/Prefab/R_Knee_Coll_HitAreaColl") as GameObject
                //        , GirlRCalfTrs, false));
                //}
                //else if ("Pants_coll" == ChieriSkinMeshColliderObjArray[i].name)
                //{
                //    RSMC_HitAreaCollObjList.Add(Instantiate(Resources.Load
                //        ("EventSystem/ReloadSkinMeshCollider/Prefab/Pants_coll_HitAreaColl") as GameObject
                //        , GirlPelvisTrs, false));
                //}
                #endregion
                #region 20190110からのもの
                //■解説
                //挙動許可範囲コリダーにスクリプトをAddし、ListIndexIntを設定。
                //専用のコリダーを設置する場合（手など）と、既存のコリダーを利用する場合（脚など）がある。
                //（手は指関節コリダーが多い上に範囲もそれほど差がないので、一個のスフィアを与える）
                //（脚はコリダー数は少なく、関節範囲が広いので、既存のメッシュコリダーや膝などに専用コリダーを付与する）

                if ("LeftLeg_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    //左脚のコリダーに付与
                    for (int k = 0; k < ChieriColliderObjs.Length; k++)
                    {
                        if (
                            ChieriColliderObjs[k].name == "Thigh_L_coll" ||
                            ChieriColliderObjs[k].name == "Sune_L_coll" ||
                            ChieriColliderObjs[k].name == "Tsumasaki_L_coll"
                            )
                        {
                            HitAreaTrigger tmp2HitAreaTrigger = ChieriColliderObjs[k].AddComponent<HitAreaTrigger>();
                            tmp2HitAreaTrigger.listIndexInt = i;
                            exitDestroyScriptList.Add(tmp2HitAreaTrigger);
                        }
                    }

                }
                else if ("RightLeg_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    //右脚のコリダーに付与
                    for (int k = 0; k < ChieriColliderObjs.Length; k++)
                    {
                        if (
                            ChieriColliderObjs[k].name == "Thigh_R_coll" ||
                            ChieriColliderObjs[k].name == "Sune_R_coll" ||
                            ChieriColliderObjs[k].name == "Tsumasaki_R_coll"
                            )
                        {
                            HitAreaTrigger tmp2HitAreaTrigger = ChieriColliderObjs[k].AddComponent<HitAreaTrigger>();
                            tmp2HitAreaTrigger.listIndexInt = i;
                            exitDestroyScriptList.Add(tmp2HitAreaTrigger);
                        }
                    }
                }
                else if ("LeftHand_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Hand_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/L_Hand_MeshColl_HitAreaColl") as GameObject
                        , GirlLHandTrs, false);
                    var tmpHitAreaTrigger = L_Hand_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;

                    exitDestroyObjList.Add(L_Hand_MeshColl_HitAreaCollObj);
                }
                else if ("RightHand_Coll" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Hand_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/R_Hand_MeshColl_HitAreaColl") as GameObject
                        , GirlRHandTrs, false);
                    var tmpHitAreaTrigger = R_Hand_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;

                    exitDestroyObjList.Add(R_Hand_MeshColl_HitAreaCollObj);
                }
                else if ("Spats" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject Spats_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/Spats_MeshColl_HitAreaColl") as GameObject
                        , GirlPelvisTrs, false);
                    var tmpHitAreaTrigger = Spats_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;

                    exitDestroyObjList.Add(Spats_MeshColl_HitAreaCollObj);
                }
                #endregion

                //20190926追加
                else if ("EYE_def" == ChieriSkinMeshColliderObjArray[i].name)//専用メッシュでなく本メッシュを使用
                {
                    GameObject EYE_def_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_EYE_def_PareHead") as GameObject
                        , GirlHeadTrs, false);
                    var tmpHitAreaTrigger = EYE_def_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(EYE_def_MeshColl_HitAreaCollObj);
                }
                else if ("Head_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject Head_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Head_CBM_PareHead") as GameObject
                        , GirlHeadTrs, false);
                    var tmpHitAreaTrigger = Head_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(Head_CBM_MeshColl_HitAreaCollObj);
                }

                else if ("L_Calf_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Calf_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Calf_CBM_PareLCalf") as GameObject
                        , GirlLCalfTrs, false);
                    var tmpHitAreaTrigger = L_Calf_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Calf_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Foot_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Foot_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Foot_CBM_PareLFoot") as GameObject
                        , GirlLFootTrs, false);
                    var tmpHitAreaTrigger = L_Foot_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Foot_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Forearm_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Forearm_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Forearm_CBM_PareLForearm") as GameObject
                        , GirlLForearmTrs, false);
                    var tmpHitAreaTrigger = L_Forearm_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Forearm_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Hand_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Hand_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Hand_CBM_PareLHand") as GameObject
                        , GirlLHandTrs, false);
                    var tmpHitAreaTrigger = L_Hand_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Hand_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_hitosashi00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_hitosashi00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_hitosashi00_CBM_PareLhitosashi00") as GameObject
                        , GirlLhitosashi00Trs, false);
                    var tmpHitAreaTrigger = L_hitosashi00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_hitosashi00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_knee_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_knee_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_knee_CBM_PareLThigh") as GameObject
                        , GirlLThighTrs, false);//掴むときのペアレント先とは別なのに注意
                    var tmpHitAreaTrigger = L_knee_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_knee_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_ko00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_ko00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_ko00_CBM_PareLko00") as GameObject
                        , GirlLko00Trs, false);
                    var tmpHitAreaTrigger = L_ko00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_ko00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_kusuri00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_kusuri00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_kusuri00_CBM_PareLkusuri00") as GameObject
                        , GirlLkusuri00Trs, false);
                    var tmpHitAreaTrigger = L_kusuri00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_kusuri00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_naka00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_naka00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_naka00_CBM_PareLnaka00") as GameObject
                        , GirlLnaka00Trs, false);
                    var tmpHitAreaTrigger = L_naka00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_naka00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_oya00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_oya00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_oya00_CBM_PareLoya00") as GameObject
                        , GirlLoya00Trs, false);
                    var tmpHitAreaTrigger = L_oya00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_oya00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Thigh_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Thigh_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Thigh_CBM_PareLThigh") as GameObject
                        , GirlLThighTrs, false);
                    var tmpHitAreaTrigger = L_Thigh_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Thigh_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Toe0_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Toe0_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Toe0_CBM_PareLToe0") as GameObject
                        , GirlLToe0Trs, false);
                    var tmpHitAreaTrigger = L_Toe0_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Toe0_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Toe1_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Toe1_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Toe1_CBM_PareLToe1") as GameObject
                        , GirlLToe1Trs, false);
                    var tmpHitAreaTrigger = L_Toe1_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Toe1_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Toe2_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Toe2_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Toe2_CBM_PareLToe2") as GameObject
                        , GirlLToe2Trs, false);
                    var tmpHitAreaTrigger = L_Toe2_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Toe2_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Toe3_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Toe3_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Toe3_CBM_PareLToe3") as GameObject
                        , GirlLToe3Trs, false);
                    var tmpHitAreaTrigger = L_Toe3_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Toe3_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_Toe4_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_Toe4_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_Toe4_CBM_PareLToe4") as GameObject
                        , GirlLToe4Trs, false);
                    var tmpHitAreaTrigger = L_Toe4_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_Toe4_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("L_UpperArm_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject L_UpperArm_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_L_UpperArm_CBM_PareLUpperArm") as GameObject
                        , GirlLUpperArmTrs, false);
                    var tmpHitAreaTrigger = L_UpperArm_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(L_UpperArm_CBM_MeshColl_HitAreaCollObj);
                }

                else if ("Mouth_def" == ChieriSkinMeshColliderObjArray[i].name)//専用メッシュでなく本メッシュを使用
                {
                    GameObject Mouth_def_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Mouth_def_PareHead") as GameObject
                        , GirlHeadTrs, false);
                    var tmpHitAreaTrigger = Mouth_def_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(Mouth_def_MeshColl_HitAreaCollObj);
                }
                else if ("Pelvis_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject Pelvis_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Pelvis_CBM_ParePelvis") as GameObject
                        , GirlPelvisTrs, false);
                    var tmpHitAreaTrigger = Pelvis_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(Pelvis_CBM_MeshColl_HitAreaCollObj);
                }

                else if ("R_Calf_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Calf_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Calf_CBM_PareRCalf") as GameObject
                        , GirlRCalfTrs, false);
                    var tmpHitAreaTrigger = R_Calf_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Calf_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Foot_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Foot_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Foot_CBM_PareRFoot") as GameObject
                        , GirlRFootTrs, false);
                    var tmpHitAreaTrigger = R_Foot_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Foot_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Forearm_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Forearm_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Forearm_CBM_PareRForearm") as GameObject
                        , GirlRForearmTrs, false);
                    var tmpHitAreaTrigger = R_Forearm_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Forearm_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Hand_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Hand_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Hand_CBM_PareRHand") as GameObject
                        , GirlRHandTrs, false);
                    var tmpHitAreaTrigger = R_Hand_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Hand_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_hitosashi00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_hitosashi00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_hitosashi00_CBM_PareRhitosashi00") as GameObject
                        , GirlRhitosashi00Trs, false);
                    var tmpHitAreaTrigger = R_hitosashi00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_hitosashi00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_knee_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_knee_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_knee_CBM_PareRThigh") as GameObject
                        , GirlRThighTrs, false);//掴むときのペアレント先とは別なのに注意
                    var tmpHitAreaTrigger = R_knee_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_knee_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_ko00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_ko00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_ko00_CBM_PareRko00") as GameObject
                        , GirlRko00Trs, false);
                    var tmpHitAreaTrigger = R_ko00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_ko00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_kusuri00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_kusuri00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_kusuri00_CBM_PareRkusuri00") as GameObject
                        , GirlRkusuri00Trs, false);
                    var tmpHitAreaTrigger = R_kusuri00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_kusuri00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_naka00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_naka00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_naka00_CBM_PareRnaka00") as GameObject
                        , GirlRnaka00Trs, false);
                    var tmpHitAreaTrigger = R_naka00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_naka00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_oya00_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_oya00_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_oya00_CBM_PareRoya00") as GameObject
                        , GirlRoya00Trs, false);
                    var tmpHitAreaTrigger = R_oya00_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_oya00_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Thigh_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Thigh_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Thigh_CBM_PareRThigh") as GameObject
                        , GirlRThighTrs, false);
                    var tmpHitAreaTrigger = R_Thigh_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Thigh_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Toe0_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Toe0_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Toe0_CBM_PareRToe0") as GameObject
                        , GirlRToe0Trs, false);
                    var tmpHitAreaTrigger = R_Toe0_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Toe0_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Toe1_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Toe1_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Toe1_CBM_PareRToe1") as GameObject
                        , GirlRToe1Trs, false);
                    var tmpHitAreaTrigger = R_Toe1_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Toe1_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Toe2_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Toe2_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Toe2_CBM_PareRToe2") as GameObject
                        , GirlRToe2Trs, false);
                    var tmpHitAreaTrigger = R_Toe2_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Toe2_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Toe3_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Toe3_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Toe3_CBM_PareRToe3") as GameObject
                        , GirlRToe3Trs, false);
                    var tmpHitAreaTrigger = R_Toe3_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Toe3_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_Toe4_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_Toe4_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_Toe4_CBM_PareRToe4") as GameObject
                        , GirlRToe4Trs, false);
                    var tmpHitAreaTrigger = R_Toe4_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_Toe4_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("R_UpperArm_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject R_UpperArm_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_R_UpperArm_CBM_PareRUpperArm") as GameObject
                        , GirlRUpperArmTrs, false);
                    var tmpHitAreaTrigger = R_UpperArm_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(R_UpperArm_CBM_MeshColl_HitAreaCollObj);
                }

                else if ("Spine1_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject Spine1_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Spine1_CBM_PareSpine1") as GameObject
                        , GirlSpine1Trs, false);
                    var tmpHitAreaTrigger = Spine1_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(Spine1_CBM_MeshColl_HitAreaCollObj);
                }
                else if ("Spine_CBM" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject Spine_CBM_MeshColl_HitAreaCollObj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Spine_CBM_PareSpine") as GameObject
                        , GirlSpineTrs, false);
                    var tmpHitAreaTrigger = Spine_CBM_MeshColl_HitAreaCollObj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(Spine_CBM_MeshColl_HitAreaCollObj);
                }
                //咥内
                else if ("Tooth_def" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject HitAreaColl_Tooth_PareToothBone00Obj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Tooth_PareToothBone00") as GameObject
                        , GirlTooth00Trs, false);
                    var tmpHitAreaTrigger = HitAreaColl_Tooth_PareToothBone00Obj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(HitAreaColl_Tooth_PareToothBone00Obj);
                }
                else if ("Tang_def" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject HitAreaColl_Tang_PareTang0003Obj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Tang_PareTang0003") as GameObject
                        , GirlTooth00Trs, false);
                    var tmpHitAreaTrigger = HitAreaColl_Tang_PareTang0003Obj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(HitAreaColl_Tang_PareTang0003Obj);
                }
                else if ("Kounai_def" == ChieriSkinMeshColliderObjArray[i].name)
                {
                    GameObject HitAreaColl_Kounai_PareToothBone00Obj = Instantiate(Resources.Load
                        ("EventSystem/ReloadSkinMeshCollider/Prefab/HitAreaColl_Kounai_PareToothBone00") as GameObject
                        , GirlTooth00Trs, false);
                    var tmpHitAreaTrigger = HitAreaColl_Kounai_PareToothBone00Obj.AddComponent<HitAreaTrigger>();
                    tmpHitAreaTrigger.listIndexInt = i;
                    exitDestroyObjList.Add(HitAreaColl_Kounai_PareToothBone00Obj);
                }
                #endregion

                HitReloadSkinMeshCollider = GameObject.Find(nameof(HitReloadSkinMeshCollider));
                //初期設定終わったらFixedでのリロード開始
                isFixedRSMCReload = true;

            }
        }

        #endregion

        #region ループ
        while (isReloadSkinMeshColliderSystem)
        {
            //Fixedでやる
            //for (int i = 0; i < RSMC_ObjList.Count; i++)
            //{
            //    //リロードが許可されてるもののみ
            //    if (RSMC_isMeshReloadList[i])
            //    {
            //        //大元スキンメッシュレンダラーの現状メッシュを生成
            //        ChieriSkinMeshColliderSkinnedMeshRendList[i].BakeMesh
            //            (RSMC_MeshList[i]);

            //        //メッシュコリダーからメッシュを一旦外して
            //        RSMC_MeshColliderList[i].sharedMesh = null;
            //        //生成したメッシュを当てはめ
            //        RSMC_MeshColliderList[i].sharedMesh = RSMC_MeshList[i];
            //    }
            //}

            HitReloadSkinMeshCollider.transform.localPosition = Vector3.zero;
            yield return null;
        }
        #endregion

        #region 終了処理
        //メッシュ更新止めて削除
        isFixedRSMCReload = false;

        for (int i = 0; i < RSMC_isMeshReloadList.Count; i++)
        {
            RSMC_isMeshReloadList[i] = false;
            RSMC_MeshColliderList[i].sharedMesh = null;
        }

        Destroy(ReloadSkinMeshColliderFolder);

        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();

        for (int i = 0; i < exitDestroyScriptList.Count; i++)
        { Destroy(exitDestroyScriptList[i]); }
        exitDestroyScriptList.Clear();
        #endregion
        yield break;
    }


    #endregion
    #region ■智恵理コリダーFixed処理システム （現在はStartで始動）
    //解説:アニメの更新に判定がついてこないのと、
    //階層のスケールズレによる登りバグを防ぐため
    //Fixedで位置をコピーし続ける

    GameObject //まとめるフォルダ
        FixedMoveChieriColliderFollderObj;

    public GameObject[] //ひとまず取得用
        ChieriColliderObjs;
    public List<GameObject>//親一覧と同期して動かすオブジェ一覧
        ChieriColliderObjRootObjList,
        FixedMoveChieriCollObjList;

    void SetChieriColliders()
    {
        //■まず、タグのついたコリダーオブジェをリストで取得
        ChieriColliderObjs = GameObject.FindGameObjectsWithTag("ChieriCollider");

        //フォルダOBJ作成
        FixedMoveChieriColliderFollderObj = new GameObject();
        FixedMoveChieriColliderFollderObj.transform.SetParent(GameObjectsTrs, false);
        FixedMoveChieriColliderFollderObj.name = "FixedMoveChieriColliderFollder";

        foreach (GameObject collObj in ChieriColliderObjs)
        {
            //ボーンと動き同期させるオブジェ作成（これをピボットにして、ボーンと同じ数値をいれる(元々のコリダー用オブジェが位置調整されてても良いように2階層)）
            GameObject tmpObj = new GameObject();
            tmpObj.transform.SetParent(FixedMoveChieriColliderFollderObj.transform, false);
            tmpObj.name = "Bone" + collObj.transform.parent.gameObject.name;
            FixedMoveChieriCollObjList.Add(tmpObj);

            //コリダーオブジェの親（ボーン）をリストに
            ChieriColliderObjRootObjList.Add(collObj.transform.parent.gameObject);
            //同期させるオブジェにコリダーオブジェをペアレント
            collObj.transform.SetParent(tmpObj.transform, false);
        }
    }

    #endregion

    #region ■その他コリダーFixed処理システム（智恵理手にペアレントされたペットボトルなど）(重複自動キャンセルや自動削除を入れた（その代わりクローンして大元アクティブオフの処理に変更）)

    GameObject //まとめるフォルダ
        FixedMoveColliderFollderObj;

    public List<GameObject>//親一覧と同期して動かすオブジェ一覧
        fixedMoveColliderDefParentObjList,
        fixedMoveColliderCloneParentObjList;

    void SetFixedMoveColliders(GameObject collObj)
    {

        #region 既にあるかどうか
        for (int i = 0; i < fixedMoveColliderDefParentObjList.Count; i++)
        {
            //あったらなにもしない
            if (fixedMoveColliderDefParentObjList[i] == collObj.transform.parent.gameObject)
            { return; }
        }
        #endregion

        //フォルダなければ作成
        if (FixedMoveColliderFollderObj == null)
        {
            //フォルダOBJ作成
            FixedMoveColliderFollderObj = new GameObject();
            FixedMoveColliderFollderObj.transform.SetParent(GameObjectsTrs, false);
            FixedMoveColliderFollderObj.name = "FixedMoveColliderFollder";
        }

        //ボーンと動きを同期させるオブジェ作成（智恵理ではこれをピボットにして、ボーンと同じ数値をいれる(元々のコリダー用オブジェが位置調整されてても良いように2階層)）
        GameObject tmpObj = new GameObject();
        tmpObj.transform.SetParent(FixedMoveColliderFollderObj.transform, false);
        tmpObj.name = "FixedMove" + collObj.transform.parent.gameObject.name;
        fixedMoveColliderCloneParentObjList.Add(tmpObj);//コリダーの親フォルダの動きを読み取って動くObj群


        //コリダーオブジェの親をリストに（これの動きを読み取る）
        fixedMoveColliderDefParentObjList.Add(collObj.transform.parent.gameObject);
        //同期させるオブジェにコリダーオブジェをクローンしてペアレント
        GameObject cloneCollObj = Instantiate(collObj);
        cloneCollObj.transform.SetParent(tmpObj.transform, false);

        //本元のコリダーオブジェオフ
        collObj.SetActive(false);
        //クローン一応オン
        cloneCollObj.SetActive(true);

        //処理はFixedに
    }

    #endregion
    #region ■その他コリダーFixed"Rigid"処理システム（↑のRigidbodyのMovePosition版。物理を伴って移動するらしい）

    GameObject //まとめるフォルダ
        FixedRigidMoveColliderFollderObj;

    public List<GameObject>//親一覧と同期して動かすオブジェ一覧
        fixedRigidMoveColliderDefParentObjList,
        fixedRigidMoveColliderCloneParentObjList;

    public List<Rigidbody>
        fixedRigidMoveColliderCloneParentObjRigidbodyList;

    void SetFixedRigidMoveColliders(GameObject collObj)
    {
        #region 既にあるかどうか
        for (int i = 0; i < fixedRigidMoveColliderDefParentObjList.Count; i++)
        {
            //あったらなにもしない
            if (fixedRigidMoveColliderDefParentObjList[i] == collObj.transform.parent.gameObject)
            { return; }
        }
        #endregion

        //初ならフォルダ作成
        if (FixedRigidMoveColliderFollderObj == null)
        {
            //フォルダOBJ作成
            FixedRigidMoveColliderFollderObj = new GameObject();
            FixedRigidMoveColliderFollderObj.transform.SetParent(GameObjectsTrs, false);
            FixedRigidMoveColliderFollderObj.name = "FixedRigidMoveColliderFollder";
        }

        //ボーンと動きを同期させるオブジェ作成（これをピボットにして、ボーンと同じ数値をいれる(元々のコリダー用オブジェが位置調整されてても良いように2階層)）
        GameObject tmpObj = new GameObject();
        tmpObj.transform.SetParent(FixedRigidMoveColliderFollderObj.transform, false);
        tmpObj.name = "FixedRigidMove" + collObj.transform.parent.gameObject.name;
        fixedRigidMoveColliderCloneParentObjList.Add(tmpObj);

        //RigidBody付与(MovePositionさせるため）
        Rigidbody rb = tmpObj.AddComponent<Rigidbody>();
        rb.isKinematic = true;
        rb.useGravity = false;
        rb.interpolation = RigidbodyInterpolation.Interpolate;
        fixedRigidMoveColliderCloneParentObjRigidbodyList.Add(rb);


        //コリダーオブジェの親をリストに
        fixedRigidMoveColliderDefParentObjList.Add(collObj.transform.parent.gameObject);
        //同期させるオブジェにコリダーオブジェをクローンしてペアレント
        GameObject cloneCollObj = Instantiate(collObj);
        cloneCollObj.transform.SetParent(tmpObj.transform, false);

        //本元のコリダーオブジェオフ
        collObj.SetActive(false);
        //クローン一応オン
        cloneCollObj.SetActive(true);

        //処理はFixedに
    }

    #endregion

    #region ■プレイヤーRigidbodyの値取得システム

    #region 変数
    [HeaderAttribute("・プレイヤーRigidRead")]
    bool
        isRigidReadSystem;
    public float
        nowVelMag,
        prevVelMag;
    public bool
        isShock = false,
        isShockWait = false;//イベントなどでショック待ち用
    float
        playerWindAudioVolumeBorderFloat = 1500;

    AudioSource //風切り音ソース
        playerWindAudioSource;

    #region 衝突用（カウンター設置）
    float
        RR_velMag1000TimeCounterFloat = 0,
        RR_velMag1000TimeCounterMaxFloat = 0.2f;//元0.2 なりすぎだと思ったので

    #endregion
    #endregion

    IEnumerator RigidReadSystem()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isRigidReadSystem == true) { yield break; }
        isRigidReadSystem = true;

        #region 初期化
        //なければ即終了
        if (CameraObjectsTrs.GetComponent<Rigidbody>() == null)
        {
            isRigidReadSystem = false;
            Debug.Log("プレイヤーにRigidbodyがないのでRigidbody監視システム終了");
            yield break;
        }

        Rigidbody
            rigidbody = CameraObjectsTrs.GetComponent<Rigidbody>();

        GameObject //デバッグ表示キャンバス
            rigidDataObj = Instantiate(Resources.Load("Debug/DebugPlayerRigidDataVis/PlayerRigidDataObj") as GameObject);

        rigidDataObj.transform.SetParent(VRUICameraTrs, false);

        //デバッグ中でなければ表示オフ
        if (DB.isDebugMode == false)
        { rigidDataObj.SetActive(false); }

        Text
            rigidText = rigidDataObj.transform.GetChild(0).Find("Text").GetComponent<Text>();

        nowVelMag = rigidbody.velocity.magnitude / nowPlayerLocalScale.z;
        prevVelMag = nowVelMag;

        //風切り音ソース
        playerWindAudioSource = SounderTrs.Find("PlayerWindSoundObj").GetComponent<AudioSource>();

        #endregion

        bool
            isTmpDataObjVis = false;


        #region ループ
        while (isRigidReadSystem == true)
        {
            prevVelMag = nowVelMag;
            nowVelMag = rigidbody.velocity.magnitude / nowPlayerLocalScale.z;

            rigidText.text =
                "velocity " + rigidbody.velocity.ToString()
                + "\n" + "magnitude/Size " + nowVelMag.ToString()
                + "\n" + "volume " + playerWindAudioSource.volume.ToString();

            //風切り音
            playerWindAudioSource.volume = nowVelMag / playerWindAudioVolumeBorderFloat;


            #region 衝突用（一定時間以上 勢い1000を超えてたらboolON）

            if (nowVelMag > 1000)
            {
                RR_velMag1000TimeCounterFloat += 1 * Time.deltaTime;

                if (isShock == false
                    && RR_velMag1000TimeCounterFloat > RR_velMag1000TimeCounterMaxFloat)
                { isShock = true; }
            }
            else //勢いなくなったら0
            {
                if (RR_velMag1000TimeCounterFloat != 0) { RR_velMag1000TimeCounterFloat = 0; }

                //衝突音
                if (isShock
                    && nowVelMag < 1 //急な加速時に音出さない用
                    && prevVelMag - nowVelMag > 500)
                {
                    SEPlay("FootStep04MaxComp");
                    Debug.Log("着地音" + "nowVelMag" + nowVelMag + " prevVelMag" + prevVelMag);
                }

                if (isShock) { isShock = false; isShockWait = false; }
            }

            #endregion



            if (isTmpDataObjVis == false && Input.GetKeyDown(KeyCode.I))
            { isTmpDataObjVis = true; rigidDataObj.SetActive(true); }
            else if (isTmpDataObjVis == true && Input.GetKeyDown(KeyCode.I))
            { isTmpDataObjVis = false; rigidDataObj.SetActive(false); }


            if (isTmpDataObjVis)
            {
                //デバッグにしたら表示オン
                if (DB.isDebugMode == true && rigidDataObj.activeSelf == false)
                { rigidDataObj.SetActive(true); }
                else if (DB.isDebugMode == false && rigidDataObj.activeSelf == true)
                { rigidDataObj.SetActive(false); }
            }
            else if (isTmpDataObjVis == false && rigidDataObj.activeSelf == true)
            { rigidDataObj.SetActive(false); }


            yield return null;
        }
        #endregion

        //終了処理

        Destroy(rigidDataObj);
        playerWindAudioSource.volume = 0;

        Debug.Log("プレイヤーRigidbody監視システム終了");

    }

    #region プレイヤーOnCollisionEnterなど
    public bool //床判定
        isYukaEnter,
        isYukaExit;
    public IEnumerator OnCollisionEnter_Player(Collision collision)
    {
        //床コリダー 直接名前で判定
        if (collision.gameObject.name == "YukaCollider01")
        {
            isYukaEnter = true;
            yield return null;
            isYukaEnter = false;
        }
    }
    public void OnCollisionStay_Player(Collision collision)
    {
    }
    public IEnumerator OnCollisionExit_Player(Collision collision)
    {
        //床コリダー 直接名前で判定
        if (collision.gameObject.name == "YukaCollider01")
        {
            isYukaExit = true;
            yield return null;
            isYukaExit = false;
        }
    }

    public void OnTriggerEnter_Player(Collider collider)
    {
    }
    public void OnTriggerStay_Player(Collider collider)
    {
    }
    public void OnTriggerExit_Player(Collider collider)
    {
    }

    #endregion

    #endregion

    #region ■PostProcessing V1


    #region 変数
    bool
        isPPSyatem = false,
        isPPEffectRun = false;//エフェクト中かどうか
    PostProcessingBehaviour //取得したのち、クローンする（デフォルトのアセットをいじらないように）
        postPB;

    //いじる用と、戻す用Def値取得用 //いじるには専用変数用意して丸々代入でないといけない
    DepthOfFieldModel.Settings
        nowPPv1DepthOfFieldSetting,
        defPPv1DepthOfFieldSetting;

    //未使用
    ColorGradingModel.Settings //色調補正
        PP_colorGradingSets,
        PP_def_colorGradingSets;
    ChromaticAberrationModel.Settings //レンズ色収差
        PP_chromaticAberrationSets,
        PP_def_chromaticAberrationSets;
    GrainModel.Settings //フィルム粒子ノイズ
        PP_grainSets,
        PP_def_grainSets;

    float //初期値系
        PPFadeToDefTime = 3;

    #endregion

    IEnumerator PostProcessingEffectSystemCor()//■■■■■■本体
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isPPSyatem == true) { yield break; }
        isPPSyatem = true;

        #region 初期化
        //■本体をクローン
        //まず取得
        postPB = VRCameraTrs.GetComponent<PostProcessingBehaviour>();

        //新規でバックアップ用Gameobject生成して貼り付け（PostProcessingBehaviourは複数もてないため）
        GameObject
            BackUpPostPBObj = new GameObject();
        BackUpPostPBObj.name = "BackUpPostProcessingBehaviourObj";
        BackUpPostPBObj.SetActive(false);//負荷かけないようOFF

        //バックアップ生成
        PostProcessingBehaviour
            backUpPostPB = BackUpPostPBObj.AddComponent<PostProcessingBehaviour>();
        backUpPostPB.profile = postPB.profile;//本体のものと同じアセットに（これをするためにこんなまどろっこしいやり方）
        backUpPostPB.enabled = postPB.enabled;//Enableかどうかも

        //本体のProfileをクローンに
        postPB.profile = Instantiate(postPB.profile);


        //■いじる用と、戻す用Def値取得(DepthOfField)
        nowPPv1DepthOfFieldSetting = defPPv1DepthOfFieldSetting = postPB.profile.depthOfField.settings;


        //DBのDepth最大値最小値を、レンジから計算して入れておく
        //まずデフォルト取り（x100はいずれ）
        DB.defaultDepthOfFieldV1x50Float
        = defPPv1DepthOfFieldSetting.focusDistance;

        //初回読み込みのみ、userの値変更)（セーブデータ無いときの初起動デフォルトが0にならないように）
        if (DB.isUserInitialSetting == false)
        { DB.userDepthOfFieldV1Float = defPPv1DepthOfFieldSetting.focusDistance; }

        //レンジ計算
        DB.adjustDepthOfFieldV1x50MinFloat =
            DB.defaultDepthOfFieldV1x50Float - DB.adjustDepthOfFieldV1RangeFloat;
        DB.adjustDepthOfFieldV1x50MaxFloat =
            DB.defaultDepthOfFieldV1x50Float + DB.adjustDepthOfFieldV1RangeFloat;


        //■いじる用と、戻す用Def値取得（使用してない）
        PP_colorGradingSets =
        PP_def_colorGradingSets = postPB.profile.colorGrading.settings;
        PP_chromaticAberrationSets =
        PP_def_chromaticAberrationSets = postPB.profile.chromaticAberration.settings;
        PP_grainSets =
        PP_def_grainSets = postPB.profile.grain.settings;

        #endregion
        //Debug.Log("PPエフェクトシステム初期化");

        #region ループ(参考の為に残しているが、未使用)
        while (isPPSyatem)
        {
            #region ■時間補正切りエフェクト 継続
            if (isPPEffect_ZikanHosei)
            {
                isPPEffect_ZikanHosei = false;
                isPPEffectRun = true;

                //まずどちらにしろenable
                postPB.enabled =
                postPB.profile.colorGrading.enabled =
                postPB.profile.chromaticAberration.enabled =
                postPB.profile.grain.enabled =
                true;

                //SE
                SEPlay("heart_def");

                #region ■カラーグレディング設定 初期値と変移用変数
                float tmpTonemappingNeutralWhiteClip =
                    PP_colorGradingSets.tonemapping.neutralWhiteClip;//明暗
                float tmpBasicSaturation =
                    PP_colorGradingSets.basic.saturation;//彩度
                float tmpBasicContrast =
                    PP_colorGradingSets.basic.contrast;//コントラスト


                //DOTWeenTO neutralWhiteClip 一瞬白くして　戻して　じわじわ白く
                DOTween.To(
                    () => tmpTonemappingNeutralWhiteClip, (x) => tmpTonemappingNeutralWhiteClip = x, 1f, 0.1f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => tmpTonemappingNeutralWhiteClip, (x) => tmpTonemappingNeutralWhiteClip = x, PP_def_colorGradingSets.tonemapping.neutralWhiteClip, 1f)
                        .OnComplete(() =>
                        {
                            DOTween.To(() => tmpTonemappingNeutralWhiteClip, (x) => tmpTonemappingNeutralWhiteClip = x, 10f, 3f);
                        });
                    });
                ////DOTWeenTO saturation 下げる
                //DOTween.To(
                //    () => tmpBasicSaturation, (x) => tmpBasicSaturation = x, 0.8f, 3f);
                ////DOTWeenTO contrast 上げる
                //DOTween.To(
                //    () => tmpBasicContrast, (x) => tmpBasicContrast = x, 1.2f, 3f);


                #endregion
                #region ■クロマティックアベレーション 初期値と変移用変数
                float tmpChromaticAberrationIntensity =
                    PP_chromaticAberrationSets.intensity;

                //DOTWeenTO intensity 一瞬最大値　戻して　じわじわ最大値へ
                DOTween.To(
                    () => tmpChromaticAberrationIntensity, (x) => tmpChromaticAberrationIntensity = x, 1f, 0.2f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => tmpChromaticAberrationIntensity, (x) => tmpChromaticAberrationIntensity = x, 0.2f, 1f)
                        .OnComplete(() =>
                        {
                            DOTween.To(() => tmpChromaticAberrationIntensity, (x) => tmpChromaticAberrationIntensity = x, 1f, 2f);
                        });
                    });
                #endregion
                #region ■グレイン設定 フィルム粒子じらじらノイズ  初期値と変移用変数
                //明るい部分はザラザラ小さく、暗い部分はザラザラ大きく。上げた方がリアル。
                float tmpGrainLuminanceContribution =
                    PP_grainSets.luminanceContribution = 0;
                float tmpGrainSize =
                    PP_grainSets.size = 3;
                float tmpGrainIntensity =
                    PP_grainSets.intensity = 0.99f;//1になったらループ終了のため0.99

                //DOTWeenTO luminanceContribution 0から0.5fへ
                DOTween.To(
                    () => tmpGrainLuminanceContribution, (x) => tmpGrainLuminanceContribution = x, 0.5f, 3f);
                //DOTWeenTO Size 3から1へ
                DOTween.To(
                    () => tmpGrainSize, (x) => tmpGrainSize = x, 1f, 3f);
                //DOTWeenTO Intensity　一瞬で1にしてあるので　戻して じわじわ上げる
                DOTween.To(
                    () => tmpGrainIntensity, (x) => tmpGrainIntensity = x, 0f, 0.5f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => tmpGrainIntensity, (x) => tmpGrainIntensity = x, 1f, 4f);
                    });
                #endregion

                //■更新し続けループ
                while (tmpGrainIntensity != 1)//最長のDOTWeen処理が←だったのでとりあえず
                {
                    //カラーグレディング
                    PP_colorGradingSets.tonemapping.neutralWhiteClip = tmpTonemappingNeutralWhiteClip;
                    PP_colorGradingSets.basic.saturation = tmpBasicSaturation;
                    PP_colorGradingSets.basic.contrast = tmpBasicContrast;
                    //クロマティックアベレーション
                    PP_chromaticAberrationSets.intensity = tmpChromaticAberrationIntensity;
                    //グレイン
                    PP_grainSets.luminanceContribution = tmpGrainLuminanceContribution;
                    PP_grainSets.size = tmpGrainSize;
                    PP_grainSets.intensity = tmpGrainIntensity;


                    //更新
                    postPB.profile.colorGrading.settings = PP_colorGradingSets;
                    postPB.profile.chromaticAberration.settings = PP_chromaticAberrationSets;
                    postPB.profile.grain.settings = PP_grainSets;

                    yield return null;
                }

                isPPEffectRun = false;
            }
            #endregion

            #region ■初期値に戻していく
            if (isPPEffect_FadeToDef)
            {
                isPPEffect_FadeToDef = false;
                isPPEffectRun = true;

                //まずenable
                postPB.enabled =
                postPB.profile.colorGrading.enabled =
                postPB.profile.chromaticAberration.enabled =
                postPB.profile.grain.enabled =
                true;

                //■初期値にじわじわ戻す
                bool isTmpComplete = false;

                //カラーグレディング
                DOTween.To(
                    () => PP_colorGradingSets.tonemapping.neutralWhiteClip, (x) => PP_colorGradingSets.tonemapping.neutralWhiteClip = x, PP_def_colorGradingSets.tonemapping.neutralWhiteClip, PPFadeToDefTime);
                DOTween.To(
                    () => PP_colorGradingSets.basic.saturation, (x) => PP_colorGradingSets.basic.saturation = x, PP_def_colorGradingSets.basic.saturation, PPFadeToDefTime);
                DOTween.To(
                    () => PP_colorGradingSets.basic.contrast, (x) => PP_colorGradingSets.basic.contrast = x, PP_def_colorGradingSets.basic.contrast, PPFadeToDefTime);
                //クロマティックアベレーション
                DOTween.To(
                    () => PP_chromaticAberrationSets.intensity, (x) => PP_chromaticAberrationSets.intensity = x, PP_def_chromaticAberrationSets.intensity, PPFadeToDefTime);
                //グレイン
                DOTween.To(
                    () => PP_grainSets.luminanceContribution, (x) => PP_grainSets.luminanceContribution = x, PP_def_grainSets.luminanceContribution, PPFadeToDefTime);
                DOTween.To(
                    () => PP_grainSets.size, (x) => PP_grainSets.size = x, PP_def_grainSets.size, PPFadeToDefTime);
                DOTween.To(
                    () => PP_grainSets.intensity, (x) => PP_grainSets.intensity = x, PP_def_grainSets.intensity, PPFadeToDefTime)
                    .OnComplete(() => { isTmpComplete = true; });//更新終了用（全部同タイミングなのでこの方法）


                //■更新し続けループ
                while (isTmpComplete != true)
                {
                    //更新
                    postPB.profile.colorGrading.settings = PP_colorGradingSets;
                    postPB.profile.chromaticAberration.settings = PP_chromaticAberrationSets;
                    postPB.profile.grain.settings = PP_grainSets;

                    yield return null;
                }

                //■念のため初期値に一瞬で戻す
                //カラーグレディング
                PP_colorGradingSets.tonemapping.neutralWhiteClip = PP_def_colorGradingSets.tonemapping.neutralWhiteClip;
                PP_colorGradingSets.basic.saturation = PP_def_colorGradingSets.basic.saturation;
                PP_colorGradingSets.basic.contrast = PP_def_colorGradingSets.basic.contrast;
                //クロマティックアベレーション
                PP_chromaticAberrationSets.intensity = PP_def_chromaticAberrationSets.intensity;
                //グレイン
                PP_grainSets.luminanceContribution = PP_def_grainSets.luminanceContribution;
                PP_grainSets.size = PP_def_grainSets.size;
                PP_grainSets.intensity = PP_def_grainSets.intensity;

                //更新
                postPB.profile.colorGrading.settings = PP_colorGradingSets;
                postPB.profile.chromaticAberration.settings = PP_chromaticAberrationSets;
                postPB.profile.grain.settings = PP_grainSets;

                //enabledかどうかも戻す
                postPB.profile.colorGrading.enabled = backUpPostPB.profile.colorGrading.enabled;
                postPB.profile.chromaticAberration.enabled = backUpPostPB.profile.chromaticAberration.enabled;
                postPB.profile.grain.enabled = backUpPostPB.profile.grain.enabled;

                //指定値 初期値に
                PPFadeToDefTime = 3;

                isPPEffectRun = false;
            }
            #endregion

            yield return null;
        }

        #endregion

        #region 終了処理


        //本体のProfileをバックアップのものに戻す
        postPB.profile = backUpPostPB.profile;
        postPB.enabled = backUpPostPB.enabled;
        //バックアップObj削除
        Destroy(BackUpPostPBObj);

        #endregion
        Debug.Log("PPエフェクトシステム終了");

        yield break;
    }

    bool isPPEffect_ZikanHosei = false;
    void PPEffect_ZikanHosei()
    {
        //システム起動してなければ起動
        if (isPPSyatem == false) { StartCoroutine(PostProcessingEffectSystemCor()); }
        //bool ON（処理は本体にある）
        isPPEffect_ZikanHosei = true;
    }
    bool isPPEffect_FadeToDef = false;
    void PPEffect_FadeToDef(float durationTime = 3)
    {
        //システム起動してなければ起動
        if (isPPSyatem == false) { StartCoroutine(PostProcessingEffectSystemCor()); }
        //bool ON（処理は本体にある）
        PPFadeToDefTime = durationTime;
        isPPEffect_FadeToDef = true;
    }
    #endregion
    #region ■PostProcessing V2
    #region 変数
    bool
        isPPv2System = false;

    public GameObject
        PostProcessVolume00DirectDataObj,
        PostProcessVolume01UserCustomObj;

    //■カメラについてるコンポーネント（アンチエイリアスとFog）
    public PostProcessLayer
        PPv2FPSLayerComponent,
        PPv2TPSLayerComponent,
        PPv2FreeFPSLayerComponent;

    //PPv2エフェクト変数群（直接いじれる）（クローン生成後取得する）
    private AmbientOcclusion
        nowPPv2AmbientOcclusion;
    private Bloom
        nowPPv2Bloom;
    private DepthOfField
        nowPPv2DepthOfField;

    #endregion
    IEnumerator PostProcessingV2SystemIEnum()
    {
        if (isPPv2System) { yield break; }
        isPPv2System = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        //PostProcessing2は、ヒエラルキー上に置かれた指定したレイヤーのObjから設定を読み込む
        //シーン別に設定ファイルを用意しリソースに保存。
        //それを割り当てたPostProcessVolume00DirectDataObjを利用して調整

        //どうやらSettingsを代入すると参照渡しにされるため、もう00DirectDataObjを直接いじるように
        //（取得するだけでSettingsを代入しなければ、クローン化（インスタンス化？）される模様）
        //（そして、DBの値を起動時に書き込むようにした）


        #region ■■■初期化
        //調査中
        //PostProcessVolume
        //    PPVolume = PostProcessManager.instance.QuickVolume(LayerMask.GetMask("PostProcessing"), 100f, vignette);

        //■カメラについてるコンポーネント（アンチエイリアスとFog）
        PPv2FPSLayerComponent = VRCameraTrs.GetComponent<PostProcessLayer>();

        //■エフェクト設定本体（取得すると勝手にクローン化）（カメラじゃないほう（アンチエイリアス、フォグ以外））
        PostProcessProfile
            PPv2CloneProfile = PostProcessVolume00DirectDataObj.GetComponent<PostProcessVolume>().profile;


        #region ■PPv2Volumeで操作する変数取得 （アンチエイリアス、Fog、FieldOfViewは別。Layerコンポーネントとカメラコンポーネントにある）
        nowPPv2AmbientOcclusion
            = PPv2CloneProfile.GetSetting<AmbientOcclusion>();
        nowPPv2Bloom
            = PPv2CloneProfile.GetSetting<Bloom>();
        nowPPv2DepthOfField
            = PPv2CloneProfile.GetSetting<DepthOfField>();

        #endregion

        #region ■TPSカメラに設定Layerコンポーネントをクローン（初期化後 手動で（スクリプトでのCopyComponentはないものか））
        PPv2TPSLayerComponent = TPSCameraTrs.gameObject.AddComponent<PostProcessLayer>();
        PPv2TPSLayerComponent.volumeLayer = LayerMask.GetMask("PostProcessing");
        PPv2TPSLayerComponent.volumeTrigger = TPSCameraTrs;

        //リソース（初期設定？）ロード（これがないとエラー）
        PPv2TPSLayerComponent.Init(Resources.Load("PostProcessing/PostProcessResources") as PostProcessResources);

        //アンチエイリアス
        PPv2TPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.FastApproximateAntialiasing;
        PPv2TPSLayerComponent.fastApproximateAntialiasing = PPv2FPSLayerComponent.fastApproximateAntialiasing;

        //Fog
        PPv2TPSLayerComponent.fog = PPv2FPSLayerComponent.fog;

        #endregion
        #region ■Freeカメラに設定Layerコンポーネントをクローン（初期化後 手動で（スクリプトでのCopyComponentはないものか））
        PPv2FreeFPSLayerComponent = FreeCameraTrs.gameObject.AddComponent<PostProcessLayer>();
        PPv2FreeFPSLayerComponent.volumeLayer = LayerMask.GetMask("PostProcessing");
        PPv2FreeFPSLayerComponent.volumeTrigger = FreeCameraTrs;

        //リソース（初期設定？）ロード（これがないとエラー）
        PPv2FreeFPSLayerComponent.Init(Resources.Load("PostProcessing/PostProcessResources") as PostProcessResources);

        //アンチエイリアス
        PPv2FreeFPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.FastApproximateAntialiasing;
        PPv2FreeFPSLayerComponent.fastApproximateAntialiasing = PPv2FPSLayerComponent.fastApproximateAntialiasing;

        //Fog
        PPv2FreeFPSLayerComponent.fog = PPv2FPSLayerComponent.fog;

        #endregion

        #endregion

        //Debug.Log("PPv2System初期化完了");

        #region ■■■ループ とくになし
        while (isPPv2System)
        {
            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }

    //各エフェクトメソッド
    GameObject //グレースケール専用Obj（消せるように）
        PPv2GrayscaleObj;
    void PPv2Grayscale(bool isOn = true)
    {
        //オブジェ設置・削除でのみ処理
        if (isOn)
        {
            #region グレースケール用PPv2Obj取得
            //既に取得してるかどうか
            if (PPv2GrayscaleObj == null)
            {
                //編集用にシーンに置かれてるか
                if (GameObject.Find("PostProcessVolumeGrayscaleObj") != null)
                { PPv2GrayscaleObj = GameObject.Find("PostProcessVolumeGrayscaleObj"); }
                else
                { PPv2GrayscaleObj = Instantiate(Resources.Load("PostProcessing/Prefab/PostProcessVolumeGrayscaleObj") as GameObject); }
            }
            #endregion
        }
        else
        {
            if (PPv2GrayscaleObj != null)
            { Destroy(PPv2GrayscaleObj); }
        }
    }

    GameObject //目眩専用Obj
        PPv2MemaiObj;
    void PPv2Memai(bool isOn = true, float fadeoutTime = 5)
    {
        //オブジェ設置・削除が基礎　Tweenでアニメ処理
        if (isOn)
        {
            #region 目眩用PPv2Obj取得
            //既に取得してるかどうか
            if (PPv2MemaiObj == null)
            {
                //編集用にシーンに置かれてるか
                if (GameObject.Find("PostProcessVolumeMemaiObj") != null)
                { PPv2MemaiObj = GameObject.Find("PostProcessVolumeMemaiObj"); }
                else
                { PPv2MemaiObj = Instantiate(Resources.Load("PostProcessing/Prefab/PostProcessVolumeMemaiObj") as GameObject); }
            }
            #endregion

            PostProcessProfile
                memaiPPv2Prof = PPv2MemaiObj.GetComponent<PostProcessVolume>().profile;
            #region ColorGrading（白）
            ColorGrading
                colorGrading = memaiPPv2Prof.GetSetting<ColorGrading>();
            //DOTWeenTO neutralWhiteClip 一瞬白くして　戻して　じわじわ白く
            DOTween.To(
                () => colorGrading.gamma.value.w, (x) => colorGrading.gamma.value.w = x
                , 1f, 0.1f)
                .OnComplete(() =>
                {
                    DOTween.To(() => colorGrading.gamma.value.w, (x) => colorGrading.gamma.value.w = x
                    , 0, 1f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => colorGrading.gamma.value.w, (x) => colorGrading.gamma.value.w = x
                        , 1f, 3f);
                    });
                });
            #endregion

            #region ChromaticAberration (レンズ端の色差)
            ChromaticAberration
                chromaticAberration = memaiPPv2Prof.GetSetting<ChromaticAberration>();
            //DOTWeenTO intensity 一瞬最大値　戻して　じわじわ最大値へ
            DOTween.To(
                () => chromaticAberration.intensity.value, (x) => chromaticAberration.intensity.value = x
                , 1f, 0.2f)
                .OnComplete(() =>
                {
                    DOTween.To(() => chromaticAberration.intensity.value, (x) => chromaticAberration.intensity.value = x
                    , 0.2f, 1f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => chromaticAberration.intensity.value, (x) => chromaticAberration.intensity.value = x
                        , 1f, 2f);
                    });
                });
            #endregion

            #region Grain(フィルム粒子ノイズ)
            Grain
                grain = memaiPPv2Prof.GetSetting<Grain>();

            //DOTWeenTO luminanceContribution 0から0.5fへ
            DOTween.To(
                () => grain.lumContrib.value, (x) => grain.lumContrib.value = x
                , 0.5f, 3f);
            //DOTWeenTO Size 3から1.5へ
            DOTween.To(
                () => grain.size.value, (x) => grain.size.value = x
                , 1.5f, 3f);
            //DOTWeenTO Intensity　一瞬で1にしてあるので　戻して じわじわ上げる
            DOTween.To(
                () => grain.intensity.value, (x) => grain.intensity.value = x
                , 0f, 0.5f)
                .OnComplete(() =>
                {
                    DOTween.To(() => grain.intensity.value, (x) => grain.intensity.value = x
                    , 1f, 4f);
                });
            #endregion
        }
        else
        {
            if (PPv2MemaiObj != null)
            {
                #region //旧それぞれフェードアウト
                ////PostProcessProfile
                ////    memaiPPv2Prof = PPv2MemaiObj.GetComponent<PostProcessVolume>().profile;

                ////#region ColorGrading（白）
                ////ColorGrading
                ////    colorGrading = memaiPPv2Prof.GetSetting<ColorGrading>();
                ////DOTween.To(
                ////    () => colorGrading.gamma.value.w, (x) => colorGrading.gamma.value.w = x
                ////    , 0f, fadeoutTime);
                ////#endregion

                ////#region ChromaticAberration (レンズ端の色差)
                ////ChromaticAberration
                ////    chromaticAberration = memaiPPv2Prof.GetSetting<ChromaticAberration>();
                ////DOTween.To(
                ////    () => chromaticAberration.intensity.value, (x) => chromaticAberration.intensity.value = x
                ////    , 0f, fadeoutTime);
                ////#endregion

                ////#region Grain(フィルム粒子ノイズ)（最後にオブジェDestroy）
                ////Grain
                ////    grain = memaiPPv2Prof.GetSetting<Grain>();

                //////Size 0へ
                ////DOTween.To(
                ////    () => grain.size.value, (x) => grain.size.value = x
                ////    , 0, fadeoutTime);
                //////Intensity 0へ
                ////DOTween.To(
                ////    () => grain.intensity.value, (x) => grain.intensity.value = x
                ////    , 0f, fadeoutTime)
                ////    .OnComplete(() =>
                ////    {
                ////        Destroy(PPv2MemaiObj);
                ////    });
                //#endregion

                #endregion
                //ウェイトでやることにした。//DOTWeenTO
                DOTween.To(() => PPv2MemaiObj.GetComponent<PostProcessVolume>().weight, (x) => PPv2MemaiObj.GetComponent<PostProcessVolume>().weight = x
                , 0f
                , fadeoutTime)
                .OnComplete(() =>
                {
                    Destroy(PPv2MemaiObj);
                });

            }
        }
    }

    GameObject //目眩リトル専用Obj
        PPv2MemaiLittleObj;
    public void PPv2MemaiLittle(float value = 1)
    {
        #region 目眩用PPv2Obj取得
        //既に取得してるかどうか
        if (PPv2MemaiLittleObj == null)
        {
            //編集用にシーンに置かれてるか
            if (GameObject.Find("PostProcessVolumeMemaiLittleObj") != null)
            { PPv2MemaiLittleObj = GameObject.Find("PostProcessVolumeMemaiLittleObj"); }
            else
            { PPv2MemaiLittleObj = Instantiate(Resources.Load("PostProcessing/Prefab/PostProcessVolumeMemaiLittleObj") as GameObject); }
        }
        #endregion

        PostProcessVolume
            memaiLittlePPv2Volume = PPv2MemaiLittleObj.GetComponent<PostProcessVolume>();

        #region 設定してある値をWeight値操作で演出 その後Destroy

        //DOTWeenTO フラッシュ2回、1秒フェードインアウト後 Destroy
        DOTween.To(
            () => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
            , value, 0.1f)
            .OnComplete(() =>
            {
                DOTween.To(() => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
                , 0, 0.1f)
                .OnComplete(() =>
                {
                    DOTween.To(() => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
                    , value, 0.1f)
                    .OnComplete(() =>
                    {
                        DOTween.To(() => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
                        , 0f, 0.1f)
                        .OnComplete(() =>
                        {
                            DOTween.To(() => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
                            , value, 1f)
                            .OnComplete(() =>
                            {
                                DOTween.To(() => memaiLittlePPv2Volume.weight, (x) => memaiLittlePPv2Volume.weight = x
                                , 0f, 1f)
                                .OnComplete(() =>
                                {
                                    Destroy(PPv2MemaiLittleObj);
                                });
                            });
                        });
                    });
                });
            });
        #endregion
    }

    //オプションで設定されたユーザー変更ロード（boolと値）
    void PPUserLoad()
    {
        if (DB.isUserAntialiasing)
        { PPv2FPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.FastApproximateAntialiasing; }
        else
        { PPv2FPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.None; }

        if (DB.isUserAmbientOcclusion)
        { nowPPv2AmbientOcclusion.active = true; }
        else { nowPPv2AmbientOcclusion.active = false; }

        if (DB.isUserBloom)
        { nowPPv2Bloom.active = true; }
        else { nowPPv2Bloom.active = false; }

        //DofはV1のもの
        if (DB.isUserDepthOfFieldV1)
        { postPB.profile.depthOfField.enabled = true; }
        else { postPB.profile.depthOfField.enabled = false; }

        nowPPv1DepthOfFieldSetting.focusDistance = DB.userDepthOfFieldV1Float;
        postPB.profile.depthOfField.settings = nowPPv1DepthOfFieldSetting;

        #region DofはV1のものを使うので、V2のは設定だけ一応残して無効にしておく。（DBのBoolをfalseにしておき、いじらせない）
        if (DB.isUserDepthOfFieldV2)
        { nowPPv2DepthOfField.active = true; }
        else { nowPPv2DepthOfField.active = false; }

        nowPPv2DepthOfField.focusDistance.value = DB.userDepthOfFieldV2Float;
        #endregion





        if (DB.isUserFog)
        {
            PPv2FPSLayerComponent.fog.enabled = true;
            RenderSettings.fog = true;
        }
        else
        {
            PPv2FPSLayerComponent.fog.enabled = false;
            RenderSettings.fog = false;
        }

        VRCamera.fieldOfView = TPSCamera.fieldOfView
            = DB.userFieldOfViewFloat;
    }


    #endregion

    #region ■スマホとりあえずシステム化

    #region 変数
    bool
        isPlayerSumahoSystem = false;

    Transform
        SmartPhoneObjectsTrs,
        PlayerSumahoTrs,
        PlayerSmartPhoneCanvasTrs,
        PlayerSmartPhoneFolderTrs,
        SpPointTrs,
        PlayerSmartPhoneTopPointTrs,
        PlayerSmartPhoneMiddlePointTrs,
        PlayerSmartPhoneBottomPointTrs,
        PlayerSmaphoOnPosCubeTrs,
        PlayerSmaphoOffPosCubeTrs,
        Status_SeeSizeTrs;

    GameObject //スマホ画面Obj群
        TalkLogScrollViewObj,
        OptionObj;

    BoxCollider //コリダー
        HardKeyCollider,
        debugModeToggleCollider,
        buttonWaitModeToggleCollider,
        skipModeToggleCollider,
        cameraResetButtonCollider,
        goToTitleButtonCollider;

    Vector3 //ペアレントで変わるスケール戻す用
        PlayerSmartPhoneDefScale;

    bool
        SmartPhoneVisLockBool = false,//プレイヤーがスマホ取り出せなくするロック判定用（falseで取り出せる）
        playerSmartPhoneVisBool = false,//プレイヤーがスマホを取り出してるかどうか判定用
        playerSmartPhoneVisCoroutineBool = false,//コルーチン内のループ中に重複実行されたらキャンセルする用

        smartPhoneRayBool = false,//スマホレイ飛ばしっぱなしにしない用
        smartPhonePoseBool = false;//ポーズ命令を一フレームだけにする用

    Collider
        playerSmartPhoneCollider;
    Slider
        SentakuOnCircleSlider;


    float //スマホ放置したらしまう用
        smartPhoneHouchiTimeFloat;


    GameObject //サイズステータス画面用
        Status_SeeSizeObj;
    RectTransform
        ManImageRectTrs;
    Text
        nowSintyouText,
        seeHeadPercentText,
        seeBreastPercentText,
        seeSpinePercentText,
        seePantsPercentText,
        seeHandPercentText,
        seeFootPercentText;


    //■智恵理スマホ
    public GameObject
        ChieriSumahoObj,
        ChieriSumahoUSBCableObj;
    Transform
        ChieriSmartPhoneCanvasTrs;

    public GameObject //智恵理スマホサイズステータス画面用
        Status_SeeSizeObjClone;
    Transform
        Status_SeeSizeTrsClone;
    RectTransform
        ManImageRectTrsClone;
    Text
        nowSintyouTextClone,
        seeHeadPercentTextClone,
        seeBreastPercentTextClone,
        seeSpinePercentTextClone,
        seePantsPercentTextClone,
        seeHandPercentTextClone,
        seeFootPercentTextClone;

    List<Image> //電源ONOFF用ImageList
        chieriSumahoFadeImageList = new List<Image>();
    List<Text> //電源ONOFF用TextList
        chieriSumahoFadeTextList = new List<Text>();

    #endregion

    IEnumerator PlayerSumahoSystemCor()//本体
    {
        if (isPlayerSumahoSystem) { yield break; }
        isPlayerSumahoSystem = true;

        #region 初期化

        #region プレイヤースマホ
        GameObject tmpSmartPhoneObj =
            Instantiate(Resources.Load("Main/KomonoObj/SmartPhone/Prefab/SmartPhoneObjects") as GameObject
            , GameObjectsTrs
            , false);
        tmpSmartPhoneObj.name = "SmartPhoneObjects";

        SmartPhoneObjectsTrs = tmpSmartPhoneObj.transform;
        PlayerSmartPhoneFolderTrs = SmartPhoneObjectsTrs.Find("PlayerSmartPhoneFolder");
        PlayerSumahoTrs = PlayerSmartPhoneFolderTrs.Find("PlayerSumaho");

        SpPointTrs = PlayerSmartPhoneFolderTrs.Find("SpPoint");
        SentakuOnCircleSlider = SpPointTrs.transform.GetChild(0).GetComponent<Slider>();

        //キャンバスのTrandform
        PlayerSmartPhoneCanvasTrs = PlayerSumahoTrs.Find("PlayerSmartPhoneCanvas").transform;

        //スマホ画面Obj群
        TalkLogScrollViewObj = PlayerSmartPhoneCanvasTrs.Find("TalkLogScrollView").gameObject;
        OptionObj = PlayerSmartPhoneCanvasTrs.Find("Option").gameObject;
        Status_SeeSizeObj = PlayerSmartPhoneCanvasTrs.Find("Status_SeeSize").gameObject;

        //ハードキーコリダー
        HardKeyCollider = PlayerSmartPhoneCanvasTrs.Find("HardKey").GetComponent<BoxCollider>();

        //トークログエレメント判定用
        PlayerSmartPhoneTopPointTrs = PlayerSmartPhoneFolderTrs.Find("PlayerSmartPhoneTopPoint").transform;
        PlayerSmartPhoneMiddlePointTrs = PlayerSmartPhoneFolderTrs.Find("PlayerSmartPhoneMiddlePoint").transform;
        PlayerSmartPhoneBottomPointTrs = PlayerSmartPhoneFolderTrs.Find("PlayerSmartPhoneBottomPoint").transform;

        //スマホ出し入れ位置（_CameraScriptObject内にある）
        NullJudgeFind(ref PlayerSmaphoOnPosCubeTrs, "PlayerSmaphoOnPosCube");
        NullJudgeFind(ref PlayerSmaphoOffPosCubeTrs, "PlayerSmaphoOffPosCube");

        //コリダー取得
        playerSmartPhoneCollider = PlayerSmartPhoneFolderTrs.Find("PlayerSmartPhoneCollider").GetComponent<Collider>();
        debugModeToggleCollider = OptionObj.transform.Find("DebugModeToggle").GetComponent<BoxCollider>();
        buttonWaitModeToggleCollider = OptionObj.transform.Find("ButtonWaitModeToggle").GetComponent<BoxCollider>();
        skipModeToggleCollider = OptionObj.transform.Find("SkipModeToggle").GetComponent<BoxCollider>();
        cameraResetButtonCollider = OptionObj.transform.Find("CameraResetButton").GetComponent<BoxCollider>();
        goToTitleButtonCollider = OptionObj.transform.Find("GoToTitleButton").GetComponent<BoxCollider>();


        //スマホ用身長ステータスオブジェクト取得
        Status_SeeSizeTrs = Status_SeeSizeObj.transform;
        ManImageRectTrs = Status_SeeSizeTrs.Find("ManImage").GetComponent<RectTransform>();
        nowSintyouText = Status_SeeSizeTrs.Find("NouSintyouText").GetComponent<Text>();
        seeHeadPercentText = Status_SeeSizeTrs.Find("SeeHeadPercentText").GetComponent<Text>();
        seeBreastPercentText = Status_SeeSizeTrs.Find("SeeBreastPercentText").GetComponent<Text>();
        seeSpinePercentText = Status_SeeSizeTrs.Find("SeeSpinePercentText").GetComponent<Text>();
        seePantsPercentText = Status_SeeSizeTrs.Find("SeePantsPercentText").GetComponent<Text>();
        seeHandPercentText = Status_SeeSizeTrs.Find("SeeHandPercentText").GetComponent<Text>();
        seeFootPercentText = Status_SeeSizeTrs.Find("SeeFootPercentText").GetComponent<Text>();


        //元Start
        //ペアレントで変わるスケール戻す用に取得
        PlayerSmartPhoneDefScale = PlayerSmartPhoneFolderTrs.localScale;

        //ソーティングレイヤーを変更
        SpPointTrs.GetComponent<MeshRenderer>().sortingLayerName = "SpPoint";
        PlayerSumahoTrs.GetComponent<MeshRenderer>().sortingLayerName = "playerSmartPhone";

        //起動時はトークログに
        TalkLogScrollViewObj.SetActive(true);
        OptionObj.SetActive(false);
        Status_SeeSizeObj.SetActive(false);

        //初期がデバッグOFFならデバッグトグル存在自体オフ
        if (DB.isDebugMode == false) { debugModeToggleCollider.gameObject.SetActive(false); }
        #endregion
        //プレイヤースマホオフ
        SmartPhoneObjectsTrs.gameObject.SetActive(false);

        #region ■■智恵理スマホ
        //■智恵理スマホ本体
        ChieriSumahoObj =
            Instantiate(Resources.Load("Main/KomonoObj/SmartPhone/Prefab/ChieriSumaho") as GameObject
            , GameObjectsTrs
            , false);
        ChieriSumahoObj.name = nameof(ChieriSumahoObj);
        ChieriSmartPhoneCanvasTrs = ChieriSumahoObj.transform.Find("ChieriSmartPhoneCanvas").transform;

        //USBケーブル
        ChieriSumahoUSBCableObj = ChieriSumahoObj.transform.Find("USBCable02").gameObject;

        //■旧タイムライン用にposObj事前読み込み（智恵理のスマホ持ち位置）
        ChieriSumaho_LHand_DefPosObj = Resources.Load("_PosObj/_ParentPoseObjs/ChieriSumaho_LHand_DefPosObj") as GameObject;
        ChieriSumaho_LHand_BuraBuraPosObj = Resources.Load("_PosObj/_ParentPoseObjs/ChieriSumaho_LHand_BuraBuraPosObj") as GameObject;

        //■サイズステータス画面クローン
        Status_SeeSizeObjClone = Instantiate(Status_SeeSizeObj);
        Status_SeeSizeTrsClone = Status_SeeSizeObjClone.transform;
        //On
        Status_SeeSizeObjClone.SetActive(true);

        ManImageRectTrsClone = Status_SeeSizeTrsClone.Find("ManImage").GetComponent<RectTransform>();
        nowSintyouTextClone = Status_SeeSizeTrsClone.Find("NouSintyouText").GetComponent<Text>();
        seeHeadPercentTextClone = Status_SeeSizeTrsClone.Find("SeeHeadPercentText").GetComponent<Text>();
        seeBreastPercentTextClone = Status_SeeSizeTrsClone.Find("SeeBreastPercentText").GetComponent<Text>();
        seeSpinePercentTextClone = Status_SeeSizeTrsClone.Find("SeeSpinePercentText").GetComponent<Text>();
        seePantsPercentTextClone = Status_SeeSizeTrsClone.Find("SeePantsPercentText").GetComponent<Text>();
        seeHandPercentTextClone = Status_SeeSizeTrsClone.Find("SeeHandPercentText").GetComponent<Text>();
        seeFootPercentTextClone = Status_SeeSizeTrsClone.Find("SeeFootPercentText").GetComponent<Text>();

        //値更新用コルーチン取得（止められるように）
        ChieriSumahoSeeSizeReloadCoroutine = ChieriSumahoSeeSizeReload();


        //■クローン身長差画面ペアレント
        Status_SeeSizeTrsClone.SetParent(ChieriSmartPhoneCanvasTrs, false);

        //■智恵理スマホ画面電源ONOFF用ListにAdd
        //Image
        chieriSumahoFadeImageList.Add(ChieriSmartPhoneCanvasTrs.Find("SeeSizeBack").GetComponent<Image>());
        chieriSumahoFadeImageList.Add(ChieriSmartPhoneCanvasTrs.Find("MenuBarDown").GetComponent<Image>());
        chieriSumahoFadeImageList.Add(ChieriSmartPhoneCanvasTrs.Find("MenuBarTop").GetComponent<Image>());

        chieriSumahoFadeImageList.Add(Status_SeeSizeTrsClone.GetComponent<Image>());
        chieriSumahoFadeImageList.Add(Status_SeeSizeTrsClone.Find("ManImage").GetComponent<Image>());

        //Text
        chieriSumahoFadeTextList.Add(nowSintyouTextClone);
        chieriSumahoFadeTextList.Add(seeHeadPercentTextClone);
        chieriSumahoFadeTextList.Add(seeBreastPercentTextClone);
        chieriSumahoFadeTextList.Add(seeSpinePercentTextClone);
        chieriSumahoFadeTextList.Add(seePantsPercentTextClone);
        chieriSumahoFadeTextList.Add(seeHandPercentTextClone);
        chieriSumahoFadeTextList.Add(seeFootPercentTextClone);

        //■スマホ智恵理に持たしてオフ
        ChieriSumahoObj.transform.SetParent(GirlLHandTrs);
        ChieriSumahoObj.transform.localPosition = ChieriSumaho_LHand_DefPosObj.transform.localPosition;
        ChieriSumahoObj.transform.localEulerAngles = ChieriSumaho_LHand_DefPosObj.transform.localEulerAngles;
        ChieriSumahoObj.transform.localScale = ChieriSumaho_LHand_DefPosObj.transform.localScale;
        ChieriSumahoObj.SetActive(false);
        //ケーブルもオフ
        ChieriSumahoUSBCableObj.SetActive(false);

        //画面オフ
        ChieriSumahoPower(false, 0);


        //1フレ遅らして起動時プレイヤースマホキャンバスオフ（ログ残しの取得でエラーになるため）（そのうち見直して統合化）
        yield return null;
        PlayerSmartPhoneCanvasTrs.gameObject.SetActive(false);

        #endregion

        #endregion

        #region ループ※メニュー作ったので廃止
        while (isPlayerSumahoSystem)
        {
            //トークログ・オプション等
            //ボタンを押すとスマホ出し入れコルーチン実行（出すしまうの処理と判断をコルーチンで行っている。）（ロック中は押せない）

            ////※メニュー作ったので廃止
            ////if (isMenuPauseDown == true
            //if (Input.GetKeyDown(KeyCode.Return) == true
            //    && SmartPhoneVisLockBool == false)
            //{ StartCoroutine(PlayerSmartPhoneVis()); }

            ////メソッド実行
            //if (smartPhoneRayBool == true)
            //{ SeeSmartPhoneHitRay(); }


            yield return null;
        }
        #endregion

        #region 終了処理※メニュー作ったので廃止

        #endregion
        yield break;
    }

    #region メソッド群
    #region ■■スマホメインとトークログ操作
    public IEnumerator PlayerSmartPhoneVis()
    {
        //モーション完了まで待つループ中に実行されたら　重複キャンセル
        if (playerSmartPhoneVisCoroutineBool == true)
        { yield break; }//これでコルーチン破棄

        playerSmartPhoneVisCoroutineBool = true;

        //スマホ取り出してるかBoolがFalseならスマホ取り出す、Trueならスマホ戻す。
        if (playerSmartPhoneVisBool == false)
        {
            //オブジェクトON
            PlayerSmartPhoneFolderTrs.gameObject.SetActive(true);
            //スマホ取り出してるかBoolをtrue
            playerSmartPhoneVisBool = true;
            //スマホをカメラにペアレント
            PlayerSmartPhoneFolderTrs.SetParent(VRCameraTrs, false);

            //位置を取り出す前の位置に
            PlayerSmartPhoneFolderTrs.position = PlayerSmaphoOffPosCubeTrs.position;
            //回転
            PlayerSmartPhoneFolderTrs.eulerAngles = PlayerSmaphoOnPosCubeTrs.eulerAngles;

            //現在の時刻取得
            float smaphoPosOnStartTimeFloat = Time.realtimeSinceStartup;
            //現在のスマホしまっている位置取得
            Vector3 startSmaphoPos = PlayerSmaphoOffPosCubeTrs.position;
            //現在のスマホ置く位置取得
            Vector3 endSmaphoPos = PlayerSmaphoOnPosCubeTrs.position;

            //起動時はトークログに
            TalkLogScrollViewObj.SetActive(true);
            OptionObj.SetActive(false);
            Status_SeeSizeObj.SetActive(false);

            //スマホ置き場所に移動するまでループしてから
            do
            {
                //ONになった瞬間の時間取得後、そこから過ぎた時間（diff）を指定した時間（0.3）で割って、start（0）からend（1）までの数値（rate）をだす //「なお時を止める予定があるなら Time.realtimeSinceStartupで時間を計測すれば、時が止まっても動けます。」
                float diff = Time.realtimeSinceStartup - smaphoPosOnStartTimeFloat;
                //rateを変数に代入することで、0.3秒かけて目的の位置にする。
                float rate = diff / 0.3f;
                //移動
                PlayerSmartPhoneFolderTrs.position
                    = Vector3.Lerp(startSmaphoPos, endSmaphoPos, rate);

                yield return null;
            }
            while (Time.realtimeSinceStartup - smaphoPosOnStartTimeFloat < 0.3f);//時間内は繰り返す（離脱条件でなく継続条件）

            //Gameオブジェクツにペアレント
            PlayerSmartPhoneFolderTrs.SetParent(GameObjectsTrs, true);

            //キャンバスON
            PlayerSmartPhoneCanvasTrs.gameObject.SetActive(true);


            //rayを作動させる
            smartPhoneRayBool = true;

            //■それぞれの画面メソッド
            //トークログ画面
            StartCoroutine(SmahoTalkLogControlCor());
            //オプション項目Rayコルーチン始動
            StartCoroutine(SmahoOptionTogglesCor());
            //ステータス（見てる量・サイズ）画面コルーチン始動
            StartCoroutine(SmahoStatus_SeeSizeCor());
            //画面切り替えコルーチン始動
            StartCoroutine(SmahoMenuChangeControl());
        }
        else
        {
            //現在の時刻取得
            float smaphoPosOffStartTimeFloat = Time.realtimeSinceStartup;
            //現在のスマホ置かれた位置取得
            Vector3 startSmaphoPos = PlayerSmartPhoneFolderTrs.position;
            //現在のしまう位置取得
            Vector3 endSmaphoPos = PlayerSmaphoOffPosCubeTrs.position;

            //スマホしまい場所に戻るまでループしてから
            do
            {
                //ONになった瞬間の時間取得後、そこから過ぎた時間（diff）を指定した時間（0.3）で割って、start（0）からend（1）までの数値（rate）をだす //「なお時を止める予定があるなら Time.realtimeSinceStartupで時間を計測すれば、時が止まっても動けます。」
                float diff = Time.realtimeSinceStartup - smaphoPosOffStartTimeFloat;
                //rateを変数に代入することで、0.3秒かけて目的の位置にする。
                float rate = diff / 0.3f;
                //移動
                PlayerSmartPhoneFolderTrs.position
                    = Vector3.Lerp(startSmaphoPos, endSmaphoPos, rate);

                yield return null;
            }
            while (Time.realtimeSinceStartup - smaphoPosOffStartTimeFloat < 0.3f);

            //元の親にペアレントして
            PlayerSmartPhoneFolderTrs.SetParent(SmartPhoneObjectsTrs, true);
            //オブジェクトオフ
            //PlayerSmartPhoneTrs.position = Vector3.zero;
            PlayerSmartPhoneFolderTrs.gameObject.SetActive(false);
            //ペアレントで変わったスケールを戻す
            PlayerSmartPhoneFolderTrs.localScale = PlayerSmartPhoneDefScale;

            //スマホVisBoolをfalse
            playerSmartPhoneVisBool = false;

            //ray止める(モーションか何かで目離してから)(止める前に再びONにならないように注意)
            //yield return new WaitForSeconds(1); //アニメーション終ってからなので待ち時間いらなそう
            smartPhoneRayBool = false;

            //キャンバスオフ
            PlayerSmartPhoneCanvasTrs.gameObject.SetActive(false);


            //スマホQuad強制で明るく
            FadeBlackSmartPhone(0f, 0.2f, false, Ease.InQuart, true);
        }

        //重複キャンセル用Boolをfalse
        playerSmartPhoneVisCoroutineBool = false;
    }
    void SeeSmartPhoneHitRay()
    {
        // playerSeeRayがスマホと衝突したら
        if (playerSmartPhoneCollider.Raycast(playerSeeRay, out playerSeeSmartPhoneRayHit, Mathf.Infinity))
        {
            //ポーズ状態に
            if (smartPhonePoseBool == false)
            {
                isGamePause = true;

                //スマホ放置タイマーリセット
                smartPhoneHouchiTimeFloat = 0;

                smartPhonePoseBool = true;
            }

            //スマホ用FadeQuad明るかったら暗く//タイムスケール関係なく
            if (fadeBlackSmartPhoneQuadMeshRenderer.material.color.a == 0)
            { FadeBlackSmartPhone(0.96f, 0.1f, false, Ease.OutQuart, true); }

            // Rayの衝突地点に、オブジェクトSpPointを移動させる
            SpPointTrs.position = playerSeeSmartPhoneRayHit.point;

        }
        //離れたら
        else
        {
            //ポインターゼロ位置
            if (SpPointTrs.position != Vector3.zero)
            { SpPointTrs.position = Vector3.zero; }

            //ポーズ状態ならポーズ解除
            if (smartPhonePoseBool == true)
            { isGamePause = false; }

            //スマホ用FadeQuad暗かったら明るく//タイムスケール関係なく
            if (fadeBlackSmartPhoneQuadMeshRenderer.material.color.a == 0.96f)
            { FadeBlackSmartPhone(0f, 0.2f, false, Ease.InQuart, true); }

            //スマホポーズ判定解除
            smartPhonePoseBool = false;

            //※スマホ出してる間に三秒間目を離すとスマホしまう
            smartPhoneHouchiTimeFloat += 1 * Time.deltaTime;
            if (smartPhoneHouchiTimeFloat > 3) { StartCoroutine(PlayerSmartPhoneVis()); smartPhoneHouchiTimeFloat = 0; }
        }

    }

    public IEnumerator SmahoTalkLogControlCor()
    {
        //スマホ出てる間ループ
        while (playerSmartPhoneVisBool == true)
        {
            //TalkLog画面ON かつ スマホポーズ（画面を見てる）間のみ操作できる
            if (TalkLogScrollViewObj.activeSelf == true && smartPhonePoseBool == true)
            {
                #region//スマホ視線でスクロール

                //プレイヤー見てる点から上下辺への距離計測してパーセンテージ化
                float seePointToSmaPhoYDistancePercent
                    = (SpPointTrs.localPosition.y
                    / PlayerSmartPhoneTopPointTrs.localPosition.y) * 100;

                //50パーセント以上になれば、下げる
                if (50 < seePointToSmaPhoYDistancePercent)
                {
                    //50を0としてから×-50ずつ下げる
                    TalkLogContentRectTrs.anchoredPosition += (new Vector2(0,
                        ((seePointToSmaPhoYDistancePercent - 50) * -40f) * Time.unscaledDeltaTime));
                }
                //逆に上げる
                if (-50 > seePointToSmaPhoYDistancePercent)
                {
                    //50を0としてから×50ずつ上げる
                    TalkLogContentRectTrs.anchoredPosition += (new Vector2(0,
                        ((seePointToSmaPhoYDistancePercent + 50) * -40f) * Time.unscaledDeltaTime));
                }
                #endregion

                #region//上下入力ボタンダウン化しint1ずつ操作
                if (sentakuAxisY == 1f || sentakuAxisY == 1f)
                {
                    //Debug.Log("Up Key");
                    TalkLogContentRectTrs.anchoredPosition += new Vector2(0,
                        1000 * Time.unscaledDeltaTime);
                }
                if (sentakuAxisY == -1f || sentakuAxisY == -1f)
                {
                    //Debug.Log("Down Key");
                    TalkLogContentRectTrs.anchoredPosition += new Vector2(0,
                        -1000 * Time.unscaledDeltaTime);
                }

                #endregion

                #region//マウススクロールでスクロール
                if (mouseWheelFloat != 0f)
                {
                    TalkLogContentRectTrs.anchoredPosition
                          -= new Vector2(0, (mouseWheelFloat * 50000) * Time.unscaledDeltaTime);
                }
                #endregion
            }
            yield return null;
        }
    }
    #endregion ■■スマホメインとトークログ操作

    #region ■■オプション設定画面
    //オプション項目取得＆Rayコルーチン始動コルーチン
    public IEnumerator SmahoOptionTogglesCor()
    {
        //設定値読み取り
        buttonWaitModeToggleCollider.GetComponent<Toggle>().isOn = DB.isButtonWaitMode;
        skipModeToggleCollider.GetComponent<Toggle>().isOn = DB.isSkipMode;

        SmahoOptionTogglesRay(debugModeToggleCollider);
        SmahoOptionTogglesRay(buttonWaitModeToggleCollider);
        SmahoOptionTogglesRay(skipModeToggleCollider);
        SmahoOptionTogglesRay(cameraResetButtonCollider, 3);
        SmahoOptionTogglesRay(goToTitleButtonCollider, 4);
        yield break;
    }
    //↑で取得したコリダーでRay（この中に実際の設定Bool判定群がある（コルーチンはrefが使えないため））

    void SmahoOptionTogglesRay(Collider tempCollider)
    { StartCoroutine(SmahoOptionTogglesRayCor(tempCollider, 1)); }
    void SmahoOptionTogglesRay(Collider tempCollider, float tempTimeMaxFloat)
    { StartCoroutine(SmahoOptionTogglesRayCor(tempCollider, tempTimeMaxFloat)); }
    //本体（Ray動作）
    public IEnumerator SmahoOptionTogglesRayCor(Collider tempCollider, float tempTimeMaxFloat)
    {


        //temp宣言
        Toggle tempToggle = tempCollider.GetComponent<Toggle>();
        Image tempImage = tempCollider.GetComponent<Image>();
        Color tempDefColor = tempImage.color;
        RaycastHit tempRayHit;
        float tempTimeFloat = 0;
        bool tempBool = false;

        //スマホ出てる間ループ
        while (playerSmartPhoneVisBool == true)
        {
            //Option画面ONの間のみレイ飛ばす
            if (OptionObj.activeSelf == true)
            {
                if (tempCollider.Raycast(playerSeeRay, out tempRayHit, Mathf.Infinity))
                {
                    //■見た1フレームだけ実行（色・音）
                    if (tempBool == false)
                    {
                        //ラベル薄色
                        tempImage.color = new Color(tempDefColor.r, tempDefColor.g, tempDefColor.b, 0.6f);
                        SentakuOnCircleSlider.maxValue = tempTimeMaxFloat;
                        tempBool = true;
                    }
                    //■見てる間
                    //Floatカウント
                    tempTimeFloat += 1 * Time.unscaledDeltaTime;
                    //カウントをSpPointスライダーへ
                    SentakuOnCircleSlider.value = tempTimeFloat;
                    //ボタンを押したら即決定（カウントMAX）
                    if (isKetteiDown == true)
                    { tempTimeFloat = tempTimeMaxFloat; }

                    //■カウントMAXでトグル切り替え
                    if (tempTimeFloat >= tempTimeMaxFloat)
                    {
                        //トグルならトグルONOFF切り替え
                        if (tempToggle != null)
                        {
                            if (tempToggle.isOn == true)
                            { tempToggle.isOn = false; }
                            else { tempToggle.isOn = true; }
                        }

                        #region//ここで実際の設定Boolを判定（コルーチンはrefが使えないため）■■■■■■■■■■■■■■■■■■■■■■
                        if (tempCollider == debugModeToggleCollider)
                        {
                            DB.isDebugMode = tempToggle.isOn;
                            DebugObjectsTrs.gameObject.SetActive(tempToggle.isOn);
                        }

                        if (tempCollider == buttonWaitModeToggleCollider)
                        { DB.isButtonWaitMode = tempToggle.isOn; }

                        if (tempCollider == skipModeToggleCollider)
                        { DB.isSkipMode = tempToggle.isOn; }

                        //ボタン
                        if (tempCollider == cameraResetButtonCollider)
                        { UnityEngine.XR.InputTracking.Recenter(); }

                        if (tempCollider == goToTitleButtonCollider)
                        {
                            EventMove("メガネ外してチュートリアル", true);
                            StartCoroutine(PlayerSmartPhoneVis());
                        }

                        #endregion

                        SEPlay(UISEObj, "UI_pyu");
                        tempTimeFloat = 0;
                    }
                }
                else //目離したらリセット
                {
                    //■目離した1フレームだけリセット処理
                    if (tempBool == true)
                    {
                        tempTimeFloat = 0;
                        SentakuOnCircleSlider.value = tempTimeFloat;
                        //ラベル薄色戻し
                        tempImage.color = tempDefColor;
                        tempBool = false;
                    }
                }
            }

            //activeオフ時（画面切り替えた）
            else
            {
                //■目離した1フレームだけリセット処理と同じ処理
                if (tempBool == true)
                {
                    tempTimeFloat = 0;
                    SentakuOnCircleSlider.value = tempTimeFloat;
                    //ラベル薄色戻し
                    tempImage.color = tempDefColor;
                    tempBool = false;
                }
            }
            yield return null;
        }


    }
    #endregion ■■オプション設定画面

    #region ■■見てる量と身長ステータス画面
    //■取得と値更新
    public IEnumerator SmahoStatus_SeeSizeCor()
    {
        //スマホ出ている間ループ
        while (playerSmartPhoneVisBool == true)
        {
            //ステータス画面オブジェクトがアクティブな間は値を更新し続ける
            if (Status_SeeSizeObj.activeSelf == true)
            { SmahoStatus_SeeSizeReload(); }
            yield return null;
        }
        yield break;
    }
    //値更新メソッド。
    public void SmahoStatus_SeeSizeReload()
    {
        ManImageRectTrs.localScale = new Vector3(nowPlayerSintyouFloat / DB.sintyouFloat, nowPlayerSintyouFloat / DB.sintyouFloat, nowPlayerSintyouFloat / DB.sintyouFloat);
        nowSintyouText.text = "現在身長\n" + nowPlayerSintyouFloat.ToString("f1") + " cm";
        seeHeadPercentText.text = seeHeadPercentFloat.ToString("f0") + "%";
        seeBreastPercentText.text = seeBreastPercentFloat.ToString("f0") + "%";
        seeSpinePercentText.text = seeSpinePercentFloat.ToString("f0") + "%";
        seePantsPercentText.text = seePantsPercentFloat.ToString("f0") + "%";
        seeHandPercentText.text = seeHandPercentFloat.ToString("f0") + "%";
        seeFootPercentText.text = seeFootPercentFloat.ToString("f0") + "%";
    }
    #endregion ■■見てる量と身長ステータス画面


    #region ■■スマホ画面切り替え
    public IEnumerator SmahoMenuChangeControl()
    {


        //temp宣言
        RaycastHit tempRayHit;
        float tempTimeFloat = 0, tempTimeMaxFloat = 1;
        bool tempBool = false;

        //スマホ出てる間ループ
        while (playerSmartPhoneVisBool == true)
        {
            //レイ操作
            if (HardKeyCollider.Raycast(playerSeeRay, out tempRayHit, Mathf.Infinity))
            {
                //■見た1フレームだけ実行（色・音）
                if (tempBool == false)
                {
                    SentakuOnCircleSlider.maxValue = tempTimeMaxFloat;
                    tempBool = true;
                }
                tempTimeFloat += 1 * Time.unscaledDeltaTime;
                SentakuOnCircleSlider.value = tempTimeFloat;
                //ボタンを押したら即決定（カウントMAX）
                if (isKetteiDown == true)
                { tempTimeFloat = tempTimeMaxFloat; }

                //■カウントMAXで切り替え
                if (tempTimeFloat >= tempTimeMaxFloat)
                {
                    SmahoMenuChange();
                    tempTimeFloat = 0;
                }
            }
            else //目離したらリセット
            {
                //■目離した1フレームだけリセット処理
                if (tempBool == true)
                {
                    tempTimeFloat = 0;
                    SentakuOnCircleSlider.value = tempTimeFloat;
                    tempBool = false;
                }
            }

            //切り替えボタン押したら即切り替え
            if (Input.GetButtonDown(DB.inputDict["カメラ切り替え"]) == true)
            {
                SmahoMenuChange();
                tempTimeFloat = 0;
            }

            yield return null;
        }


    }
    public void SmahoMenuChange()
    {
        //ログからオプションへ
        if (TalkLogScrollViewObj.activeSelf == true)
        {
            TalkLogScrollViewObj.SetActive(false);
            OptionObj.SetActive(true);
        }

        //オプションから
        else if (OptionObj.activeSelf == true)
        {
            //2週以上してたらサイズステータス画面へ
            if (DB.storyLoopCountInt > 2)
            {
                OptionObj.SetActive(false);
                Status_SeeSizeObj.SetActive(true);
            }
            else//でなければログへ
            {
                OptionObj.SetActive(false);
                TalkLogScrollViewObj.SetActive(true);
            }
        }

        //サイズステータスからログへ
        else if (Status_SeeSizeObj.activeSelf == true)
        {
            Status_SeeSizeObj.SetActive(false);
            TalkLogScrollViewObj.SetActive(true);
        }

        SEPlay(UISEObj, "UI_ko");
    }
    #endregion

    #region ■■智恵理スマホ画面ONOFF用

    public void ChieriSumahoPower(bool On = true, float durationTime = 0.2f)
    {
        if (On)
        {
            //スマホアクティブの場合のみ
            if (ChieriSumahoObj.activeSelf)
            {
                #region 時計更新
                //取得
                int hour =
                    flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().hour;
                int minute =
                    flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().minute;

                ChieriSmartPhoneCanvasTrs.Find("MenuBarTop/TimeText").GetComponent<TextMeshProUGUI>().text
                    = String.Format("{00}", hour) + ":" + String.Format("{00}", minute);
                #endregion

                //画面要素をONにする
                ChieriSmartPhoneCanvasTrs.gameObject.SetActive(true);
                for (int i = 0; i < chieriSumahoFadeImageList.Count; i++)
                { chieriSumahoFadeImageList[i].DOColor(new Color(1, 1, 1, 1), durationTime); }

                for (int i = 0; i < chieriSumahoFadeTextList.Count; i++)
                { chieriSumahoFadeTextList[i].DOColor(new Color(1, 1, 1, 1), durationTime); }

                //更新コルーチンスタート
                StartCoroutine(ChieriSumahoSeeSizeReloadCoroutine);
            }
        }
        else
        {
            for (int i = 0; i < chieriSumahoFadeImageList.Count; i++)
            { chieriSumahoFadeImageList[i].DOColor(new Color(1, 1, 1, 0), durationTime); }

            for (int i = 0; i < chieriSumahoFadeTextList.Count; i++)
            { chieriSumahoFadeTextList[i].DOColor(new Color(1, 1, 1, 0), durationTime); }

            //表示消えてからキャンバスオフにするため、ダミーDOTweenを走らせて同時間にOnCompleteでオフ
            int tmpDummyInt = 0;
            DOTween.To(() => tmpDummyInt, (x) => tmpDummyInt = x, 2, durationTime)
                .OnComplete(() => { ChieriSmartPhoneCanvasTrs.gameObject.SetActive(false); });

            //更新コルーチンストップ
            StopCoroutine(ChieriSumahoSeeSizeReloadCoroutine);
        }
    }
    //スマホObjがtrue ＆ 画面On時は値更新し続ける
    IEnumerator ChieriSumahoSeeSizeReloadCoroutine;//ストップする用変数
    IEnumerator ChieriSumahoSeeSizeReload()
    {
        繰り返し使う用に破棄せず戻る:
        yield return null;//これが無いとループでフリーズする

        //オブジェついてる間のみ
        while (ChieriSumahoObj.activeSelf == true)
        {
            //更新頻度下げれば負荷軽減できるかも？
            ManImageRectTrsClone.localScale = new Vector3(nowPlayerSintyouFloat / DB.sintyouFloat, nowPlayerSintyouFloat / DB.sintyouFloat, nowPlayerSintyouFloat / DB.sintyouFloat);
            nowSintyouTextClone.text = "現在身長\n" + nowPlayerSintyouFloat.ToString("f1") + " cm";
            seeHeadPercentTextClone.text = seeHeadPercentFloat.ToString("f0") + "%";
            seeBreastPercentTextClone.text = seeBreastPercentFloat.ToString("f0") + "%";
            seeSpinePercentTextClone.text = seeSpinePercentFloat.ToString("f0") + "%";
            seePantsPercentTextClone.text = seePantsPercentFloat.ToString("f0") + "%";
            seeHandPercentTextClone.text = seeHandPercentFloat.ToString("f0") + "%";
            seeFootPercentTextClone.text = seeFootPercentFloat.ToString("f0") + "%";

            yield return null;
        }

        //オブジェを消したら自動で画面オフ命令送る。
        ChieriSumahoPower(false, 0);

        //終わりまで行くと変数から破棄されるのでgotoで頭に戻しておく（ストップがかかるので無駄ループはしない）
        goto 繰り返し使う用に破棄せず戻る;
    }
    #endregion

    #endregion

    #endregion

    #region ■かくれおにシステム

    #region 変数
    [HeaderAttribute("・かくれおに")]
    public GameObject //開始時にリソースから読み、終了時に消す用
        EV_C_KakureOni;

    public bool
        isKOSystem;
    bool
        isKOSystemLoading = true;

    GameObject
        KakureOni_UI,
        KO_MatagiColliderObj;

    CharacterController //段差越え、壁判定など用 （コリダーとは別挙動になりつつ、コリダー判定は生まれるので微妙にややこしい　後で変えるかも）
        KO_CharacterController;

    LayerMask //探索オブジェと被らないようにseeRayBlockとseeRayKakurePosの2種
        seeRayKakurePosLayerMask;


    public List<GameObject> //隠れ場所オブジェ
        KO_KakurePosObjsList = new List<GameObject>();

    Collider //隠れ位置判定用コリダー
        KO_nowSeePosCollider = null,
        KO_prevSeePosCollider = null,
        KO_nowMovePosCollider = null;
    public bool //移動先決定してるかbool
        KO_isMovePosSet = false;

    Material //隠れ場所オブジェマテリアル
    KO_kakurePosEnterMat,
    KO_kakurePosOnMat,
    KO_kakurePosOffMat,
    KO_kakurePosNewOnMat,
    KO_kakurePosNewOffMat;

    public bool //イベント中などにロックする用
        KO_isMovePosLock = false;

    bool //現在いどうしているかどうか判定（TPS走りアニメなどの表示用）
        KO_isMove = false;

    Vector3 //移動している方向（アニメ用にclass変数にしたが、結局場所から算出にした（なぜかバック時向かなかった）ので、現在は参照なし）
        KO_moveDirection = new Vector3();
    Vector3 //現在移動している場所（アニメ用）
        KO_nowMovePos = new Vector3();


    public bool
        KO_isParticleObjMode = true;

    float
        KO_AsiotoTimeCountFloat = 0,
        KO_AsiotoTimeCountMaxFloat = 0.35f;

    #endregion

    //■かくれおに プレイヤー移動システム
    IEnumerator KakureOniSystemLoad()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isKOSystem == true) { yield break; }
        isKOSystem = true;
        #region 初期化

        //初回起動のみの初期化
        if (isKOSystemLoading)
        {
            //かくれおにPrefabなければ生成
            if (GameObject.Find("EV_C_KakureOni") == null)
            {
                EV_C_KakureOni = Instantiate(Resources.Load("EventSystem/KakureOni/Prefab/EV_C_KakureOni") as GameObject);
                EV_C_KakureOni.transform.SetParent(EventObjectsTrs, false);
            }
            //編集用にすでに配置してある場合
            else { EV_C_KakureOni = GameObject.Find("EV_C_KakureOni"); }

            //■隠れ場所オブジェから取得
            //まずクリア
            KO_KakurePosObjsList.Clear();

            #region ■隠れ場所ステージの取得　と　ついでにプロットデータ取得して、残りのポイントObjにコピー
            #region コピーするのは、親Objのコリダーと 子のRootNaviEffect群
            GameObject
                Prot_KakurePosObj
                = EV_C_KakureOni.transform.Find("Prot_KakurePosObj").gameObject;
            CapsuleCollider
                protCollider
                = Prot_KakurePosObj.GetComponent<CapsuleCollider>();
            List<GameObject>
                prot_RootNaviEffectObjList = new List<GameObject>();
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_Ex").gameObject);
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_ExGreen").gameObject);
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_ExStop").gameObject);
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_Square").gameObject);
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_SquareGreen").gameObject);
            prot_RootNaviEffectObjList.Add(Prot_KakurePosObj.transform.Find("RootNaviEffect_SquareStop").gameObject);
            #endregion

            //隠れ場所ステージの取得　//なぜかforだとエラーが起きるのでforeach
            foreach (Transform x in EV_C_KakureOni.transform.Find("KO_KakurePosObjs").transform)
            {
                KO_KakurePosObjsList.Add(x.gameObject);
                #region パーティクルモードの場合プロットデータからポイントObjへペーストしてからスクリプトON
                if (KO_isParticleObjMode)
                {
                    foreach (Transform y in x)
                    {
                        //KakurePosColliderHitスクリプトがあること前提
                        if (y.GetComponent<KakurePosCollderHit>() != null)
                        {
                            #region コリダー付与して、値をプロットからコピー
                            CapsuleCollider
                                tmpCollider =
                                y.gameObject.AddComponent<CapsuleCollider>();
                            tmpCollider.isTrigger = protCollider.isTrigger;
                            tmpCollider.center = protCollider.center;
                            tmpCollider.radius = protCollider.radius;
                            tmpCollider.height = protCollider.height;
                            tmpCollider.direction = protCollider.direction;

                            tmpCollider.enabled = false;

                            #endregion
                            #region RootNaviObj群をクローン
                            for (int i = 0; i < prot_RootNaviEffectObjList.Count; i++)
                            {
                                //なければ置く
                                if (y.Find(prot_RootNaviEffectObjList[i].name) == false)
                                {
                                    GameObject tmpRootNaviObj
                                        = Instantiate(prot_RootNaviEffectObjList[i], y, false);
                                    tmpRootNaviObj.name = prot_RootNaviEffectObjList[i].name;
                                }
                            }
                            #endregion


                            //SphereColliderとMeshRendererをOFF //以前タイプのコリダーとスフィアなので
                            y.GetComponent<SphereCollider>().enabled = false;
                            y.GetComponent<MeshRenderer>().enabled = false;

                            //スクリプトON（RootNaviObjの名前変えるのでこれを最後に）
                            y.GetComponent<KakurePosCollderHit>().enabled = true;
                        }
                    }
                }
                #endregion
                #region パーティクルモードでない場合は以前通りにするために パーティクルObj消しとスクリプトON
                else
                {
                    foreach (Transform y in x)
                    {
                        //KakurePosColliderHitスクリプトがあること前提
                        if (y.GetComponent<KakurePosCollderHit>() != null)
                        {
                            #region RootNaviObj群を削除
                            for (int i = 0; i < prot_RootNaviEffectObjList.Count; i++)
                            {
                                //あれば消す
                                if (y.Find(prot_RootNaviEffectObjList[i].name))
                                {
                                    Destroy(y.Find(prot_RootNaviEffectObjList[i].name).gameObject);
                                }
                            }
                            #endregion
                            //スクリプトON（RootNaviObjの名前変えるのでこれを最後に）
                            y.GetComponent<KakurePosCollderHit>().enabled = true;
                        }
                    }
                }
                #endregion
            }
            #endregion
            #region 全部Activeオンにして1フレ待ってオフ（付与しているスクリプト走らせるため）
            for (int i = 0; i < KO_KakurePosObjsList.Count; i++)
            { KO_KakurePosObjsList[i].SetActive(true); }

            yield return null;//ActiveONに1フレーム必要

            for (int i = 0; i < KO_KakurePosObjsList.Count; i++)
            { KO_KakurePosObjsList[i].SetActive(false); }
            #endregion

            //■隠れオブジェレイヤーマスク作成（ビット演算で指定は複雑なので名前で指定）
            //探索オブジェと被り時に レイヤー変更でスルーできるように2種
            seeRayKakurePosLayerMask =
                (1 << LayerMask.NameToLayer("seeRayBlock")) +
                (1 << LayerMask.NameToLayer("seeRayKakurePos")) +
                (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));

            //隠れ場所オブジェマテリアル
            KO_kakurePosEnterMat = Resources.Load("EventSystem/KakureOni/Mat/KO_kakurePosEnter") as Material;
            KO_kakurePosOnMat = Resources.Load("EventSystem/KakureOni/Mat/KO_kakurePosOn") as Material;
            KO_kakurePosOffMat = Resources.Load("EventSystem/KakureOni/Mat/KO_kakurePosOff") as Material;
            KO_kakurePosNewOnMat = Resources.Load("EventSystem/KakureOni/Mat/KO_kakurePosNewOn") as Material;
            KO_kakurePosNewOffMat = Resources.Load("EventSystem/KakureOni/Mat/KO_kakurePosNewOff") as Material;

        }

        //ポインターシステム起動してなければ起動
        if (isSeePointCursorSystem == false)
        { StartCoroutine(SeePointCursorSystemIEnum()); }

        //■段差越え、壁判定など用 （コリダーとは別挙動になりつつ、コリダー判定は生まれるので微妙にややこしい　後で変えるかも）
        KO_CharacterController = CameraObjectsTrs.gameObject.AddComponent<CharacterController>();
        //初期設定（値読み出す専用OBJをリソースにおいてもよさそう。一旦直接指定）
        KO_CharacterController.center = new Vector3(0, 0.5f, 0);//Geo00（都市床）に置く時は0.6fに
        KO_CharacterController.height = 1;
        KO_CharacterController.radius = 0.25f;

        RaycastHit
            KO_kakurePosRayHit;
        Vector3 //バックする場合の位置（行き先決定時の位置）
            backMovePos = CameraObjectsTrs.position;

        //playerMoveSpeed = 4f;
        #endregion

        //起動時にSeeRay当たってるとエラーになるので1フレ待ち
        yield return null;

        //Debug.Log("かくれおに移動システム設置・初期化完了");

        //初回ロード終了
        isKOSystemLoading = false;

        #region ループ（隠れポジション選択・移動）

        while (isKOSystem == true)
        {
            //■CharacterControllerを更新し続ける（物理挙動はCharacterControllerが独立して計算しているため）
            KO_CharacterController.SimpleMove(Vector3.zero);

            #region RayでPosオブジェ選択、ボタン押しで移動
            if (isNovelSetVisIng == false || isNowNovelAutoVis)//ためしにノベル時強制ストップ//オート時はOK
            {
                #region Ray（マスクはseeRayBlockも含んでいる）
                if (Physics.Raycast(playerSeeRay, out KO_kakurePosRayHit, Mathf.Infinity, seeRayKakurePosLayerMask))
                {
                    #region 見て選択、色音処理
                    if (KO_kakurePosRayHit.collider.gameObject.tag == "kakurePosObj")
                    {
                        //■見てるPosが初見なら
                        if (KO_nowSeePosCollider != KO_kakurePosRayHit.collider)
                        {
                            //■now更新
                            KO_nowSeePosCollider = KO_kakurePosRayHit.collider;

                            //nowが 現移動先Posでないなら
                            if (KO_nowSeePosCollider != KO_nowMovePosCollider)
                            {
                                #region パーティクルObj版なら
                                if (KO_isParticleObjMode)
                                {
                                    //■色変え
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(true);
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);

                                    //prevが nowでなく、現移動先でもなければ prevのpos色を戻す
                                    if (KO_prevSeePosCollider != null &&
                                    KO_prevSeePosCollider != KO_nowSeePosCollider &&
                                    KO_prevSeePosCollider != KO_nowMovePosCollider)
                                    {
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(true);
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                                    }
                                }
                                #endregion
                                #region 従来のスフィア版
                                else
                                {

                                    //■色変え(NewOffならNewOnに)
                                    if (KO_nowSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOffMat.color)
                                    { KO_nowSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOnMat; }
                                    else
                                    { KO_nowSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOnMat; }

                                    //prevが nowでなく、現移動先でもなければ prevのpos色を戻す
                                    if (KO_prevSeePosCollider != null &&
                                    KO_prevSeePosCollider != KO_nowSeePosCollider &&
                                    KO_prevSeePosCollider != KO_nowMovePosCollider)
                                    {
                                        //NewOnならNewOffに
                                        if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                                        { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                                        else
                                        { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                                    }
                                }
                                #endregion

                                //■prev更新
                                KO_prevSeePosCollider = KO_nowSeePosCollider;

                                SEPlay(UISEObj, "UI_pin");
                            }
                        }

                        //■pos見続けてる間 ボタン入力待ち
                        if (KO_nowSeePosCollider == KO_kakurePosRayHit.collider)
                        {
                            //if (Input.GetButtonDown(DB.inputDict["移動ポイント前進デジタル"]) == true)
                            if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0
                                || isKettei == true)
                            {
                                //それが現移動先Posでないなら音と色変え 現移動先にする
                                if (KO_nowMovePosCollider != KO_nowSeePosCollider)
                                {
                                    #region パーティクルObj版なら
                                    if (KO_isParticleObjMode)
                                    {
                                        //初回でなければ、前の移動先pos色戻し
                                        if (KO_nowMovePosCollider != null)
                                        {
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                                        }
                                        //現移動先 更新
                                        KO_nowMovePosCollider = KO_nowSeePosCollider;
                                        //戻り先も更新
                                        backMovePos = CameraObjectsTrs.position;
                                        //色
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(true);

                                    }
                                    #endregion
                                    #region 従来のスフィア版
                                    else
                                    {
                                        //初回でなければ、前の移動先pos色戻し
                                        if (KO_nowMovePosCollider != null)
                                        {
                                            KO_nowMovePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat;
                                        }

                                        //現移動先 更新
                                        KO_nowMovePosCollider = KO_nowSeePosCollider;
                                        //戻り先も更新
                                        backMovePos = CameraObjectsTrs.position;
                                        //色
                                        KO_nowMovePosCollider.GetComponent<Renderer>().material = KO_kakurePosEnterMat;
                                    }
                                    #endregion

                                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                    //フラグ
                                    KO_isMovePosSet = true;
                                }
                            }
                        }
                    }
                    else //tagがkakurePosObjでなかった場合(あらぬ方向見)
                    {
                        //前回見てたposがあるなら それの色戻し
                        if (KO_prevSeePosCollider != KO_nowMovePosCollider && KO_prevSeePosCollider != null)
                        {
                            #region パーティクルObj版なら
                            if (KO_isParticleObjMode)
                            {
                                KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                                KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                            }
                            #endregion
                            #region 従来のスフィア版
                            else
                            {
                                //NewOnならNewOffに
                                if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                                { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                                else
                                { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                            }
                            #endregion

                            KO_nowSeePosCollider =
                            KO_prevSeePosCollider = null;
                        }
                    }

                    #endregion

                    ////■ポインタ処理
                    //if (isKOPointerOff == false)
                    //{
                    //    if (KO_SeePointTrs.gameObject.activeSelf != true) { KO_SeePointTrs.gameObject.SetActive(true); }
                    //    KO_SeePointTrs.position = KO_kakurePosRayHit.point;
                    //    KO_SeePointTrs.LookAt(PlayerTargetTrs, Vector3.forward);
                    //    nearSizeAjust(KO_SeePointTrs, 8000);
                    //}

                }
                else //■Rayが何にもヒットしていない場合（SeeRayBlockにもヒットしてない場合）(あらぬ方向と同処理)
                {
                    //前回見てたposがあるなら それの色戻し
                    if (KO_prevSeePosCollider != KO_nowMovePosCollider && KO_prevSeePosCollider != null)
                    {
                        #region パーティクルObj版なら
                        if (KO_isParticleObjMode)
                        {
                            KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                            KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                            KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                        }
                        #endregion
                        #region 従来のスフィア版
                        else
                        {
                            //NewOnならNewOffに
                            if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                            { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                            else
                            { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                        }
                        #endregion

                        KO_nowSeePosCollider =
                        KO_prevSeePosCollider = null;
                    }

                    ////■ポインタ消し
                    //if (KO_SeePointTrs.gameObject.activeSelf != false) { KO_SeePointTrs.gameObject.SetActive(false); }
                }

                #endregion

                #region 移動先が存在するフラグ立ってれば ボタン押し続けでそこへ移動（Lockがかかってなければ）(アナログトリガー)
                if (KO_isMovePosSet == true && KO_isMovePosLock == false)
                {
                    if (//問題切り分けのためアナログはずし //Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0 ||
                            isKettei == true)
                    {
                        //到着後ぶるぶるしないように距離計り(高さ無視)
                        float distanceFlt =
                            Vector3.Distance(
                            new Vector3(KO_nowMovePosCollider.transform.position.x, 0, KO_nowMovePosCollider.transform.position.z)
                            , new Vector3(CameraObjectsTrs.position.x, 0, CameraObjectsTrs.position.z));
                        //Debug.Log(distanceFlt);
                        //0.1で到着とみなし
                        if (distanceFlt >= 0.1f)
                        {
                            //移動しているtrue（アニメ用）
                            if (KO_isMove == false) { KO_isMove = true; }

                            #region アナログの速度数値置き換え（デジタルの場合は1）

                            float inputSpeed;

                            ////アナログ切り
                            //if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) < 0)
                            //{ inputSpeed = Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]); }
                            //else
                            //{
                            inputSpeed = 1;
                            //}
                            #endregion
                            #region 前進
                            //方向取り
                            KO_moveDirection = KO_nowMovePosCollider.transform.position - CameraObjectsTrs.position;
                            //ノーマライズ
                            KO_moveDirection = KO_moveDirection.normalized;
                            //■移動（ワールド座標なのでYがゼロ（浮かせない））
                            CameraObjectsTrs.Translate(new Vector3(KO_moveDirection.x, 0, KO_moveDirection.z)
                                * inputSpeed
                                * playerMoveSpeed
                                * Time.deltaTime
                                * GameObjectsTrs.localScale.z
                                * nowPlayerLocalScale.z
                                , Space.World);

                            //アニメ用に現在移動しているポイントをクラス変数に
                            KO_nowMovePos = KO_nowMovePosCollider.transform.position;
                            #endregion
                            #region 足音
                            if (KO_AsiotoTimeCountFloat < KO_AsiotoTimeCountMaxFloat)
                            {
                                KO_AsiotoTimeCountFloat += 1 * Time.deltaTime;
                            }
                            else
                            {
                                KO_AsiotoTimeCountFloat = 0;
                                SEPlay(UISEObj, KO_PlayerAsioto_DefList[UnityEngine.Random.Range(0, KO_PlayerAsioto_DefList.Count)], 0.3f);
                            }
                            #endregion
                        }
                        //到着してるのでアニメやめ
                        else { if (KO_isMove) { KO_isMove = false; } }

                    }
                    else if (
                        //切り分けのためアナログはずし //Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) < 0 ||
                        isBack == true)
                    {
                        //到着後ぶるぶるしないように距離計り(高さ無視)
                        float distanceFlt =
                            Vector3.Distance(
                            new Vector3(backMovePos.x, 0, backMovePos.z)
                            , new Vector3(CameraObjectsTrs.position.x, 0, CameraObjectsTrs.position.z));

                        //0.1で到着とみなし
                        if (distanceFlt >= 0.1f)
                        {
                            //移動しているtrue（アニメ用）
                            if (KO_isMove == false) { KO_isMove = true; }
                            #region アナログの速度数値置き換え（デジタルの場合は-1）

                            float inputSpeed;

                            //if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0)
                            //{ inputSpeed = Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]); }
                            //else
                            //{
                            inputSpeed = -1;
                            //}
                            #endregion
                            #region 後退
                            //方向取り
                            KO_moveDirection = CameraObjectsTrs.position - backMovePos;
                            //ノーマライズ
                            KO_moveDirection = KO_moveDirection.normalized;
                            //移動（ワールド座標なのでYがゼロ（浮かせない））
                            CameraObjectsTrs.Translate(new Vector3(KO_moveDirection.x, 0, KO_moveDirection.z)
                                * inputSpeed
                                * playerMoveSpeed
                                * Time.deltaTime
                                * GameObjectsTrs.localScale.z
                                * nowPlayerLocalScale.z
                                , Space.World);

                            //アニメ用に現在移動しているポイントをクラス変数に
                            KO_nowMovePos = backMovePos;
                            #endregion
                        }
                        //到着してるのでアニメやめ
                        else { if (KO_isMove) { KO_isMove = false; } }

                    }
                    //どちらも押してない場合 移動しているフラグfalse（アニメ用）
                    else
                    { if (KO_isMove) { KO_isMove = false; } }

                }
                else //移動先存在なし || Lock時 もフラグfalse（アニメ用）
                { if (KO_isMove) { KO_isMove = false; } }
                #endregion

                #region //移動先が存在するフラグ立ってれば ボタン押し続けでそこへ移動（Lockがかかってなければ）（デジタルボタン）
                //if (isMovePosSet == true && KO_isMovePosLock == false)
                //{
                //    if (Input.GetButton(DB.inputDict["移動ポイント前進デジタル"]) == true)
                //    {
                //        #region 前進
                //        //方向取り
                //        Vector3 direction = nowMovePosCollider.transform.position - CameraObjectsTrs.position;
                //        //ノーマライズ
                //        direction = direction.normalized;
                //        //移動（ワールド座標なのでYがゼロ（浮かせない））
                //        CameraObjectsTrs.Translate(new Vector3(direction.x, 0, direction.z)
                //            * playerMoveSpeed
                //            * Time.deltaTime
                //            * GameObjectsTrs.localScale.z
                //            , Space.World);
                //        #endregion
                //    }
                //    if (Input.GetButton(DB.inputDict["移動ポイント後退デジタル"]) == true)
                //    {
                //        #region 後退
                //        //方向取り
                //        Vector3 direction = backMovePos - CameraObjectsTrs.position;
                //        //ノーマライズ
                //        direction = direction.normalized;
                //        //移動（ワールド座標なのでYがゼロ（浮かせない））
                //        CameraObjectsTrs.Translate(new Vector3(direction.x, 0, direction.z)
                //            * playerMoveSpeed
                //            * Time.deltaTime
                //            * GameObjectsTrs.localScale.z
                //            , Space.World);
                //        #endregion
                //    }
                //}
                #endregion

            }
            else//ノベル表示中
            {
                ////■ポインタ消し
                //if (KO_SeePointTrs.gameObject.activeSelf != false) { KO_SeePointTrs.gameObject.SetActive(false); }
                //移動しているfalse（アニメ用）
                if (KO_isMove == true) { KO_isMove = false; }
            }

            #endregion //RayでPosオブジェ選択、ボタン押しで移動
            yield return null;
        }
        #endregion 隠れポジション選択・移動

        #region 終了処理(初回起動ロード重いので一部だけ解放　一時終了)
        KO_isMovePosLock = false;//移動止め解除
        KO_isMovePosSet = false;//移動先なしに

        //Destroy(EV_C_KakureOni);
        Destroy(KO_CharacterController);

        //他にポインターシステム使用するものが起動してなければ終了させる
        SeePointSystemOff();

        //隠れ場所オブジェステージリストオフ
        for (int i = 0; i < KO_KakurePosObjsList.Count; i++)
        { KO_KakurePosObjsList[i].SetActive(false); }

        Resources.UnloadUnusedAssets();
        Debug.Log("かくれおに移動システム一時終了処理完了");

        #endregion
    }

    //■プレイヤー移動システムシンプル起動（移動ポイントの読み込みと設置なし 手動で設置してリストに入れる）
    public IEnumerator KakureOniSimpleSystemLoad()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isKOSystem == true) { yield break; }
        isKOSystem = true;
        #region 初期化
        //ロード開始
        isKOSystemLoading = true;

        //■隠れオブジェレイヤーマスク作成（ビット演算で指定は複雑なので名前で指定）
        //探索オブジェと被り時に レイヤー変更でスルーできるように2種
        seeRayKakurePosLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("seeRayKakurePos")) +
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));

        //ポインターシステム起動してなければ起動
        if (isSeePointCursorSystem == false)
        { StartCoroutine(SeePointCursorSystemIEnum()); }

        //■段差越え、壁判定など用 （コリダーとは別挙動になりつつ、コリダー判定は生まれるので微妙にややこしい　後で変えるかも）
        KO_CharacterController = CameraObjectsTrs.gameObject.AddComponent<CharacterController>();
        //初期設定（値読み出す専用OBJをリソースにおいてもよさそう。一旦直接指定）
        KO_CharacterController.center = new Vector3(0, 0.5f, 0);//Geo00（都市床）に置く時は0.6fに
        KO_CharacterController.height = 1;
        KO_CharacterController.radius = 0.25f;
        KO_CharacterController.slopeLimit = 60;//シンプルでのみ、登れる坂の角度60度に（デフォルトは45）

        RaycastHit
            KO_kakurePosRayHit;
        Vector3 //バックする場合の位置（行き先決定時の位置）
            backMovePos = CameraObjectsTrs.position;
        #endregion

        //起動時にSeeRay当たってるとエラーになるので1フレ待ち
        yield return null;

        //Debug.Log("かくれおに移動システム設置・初期化完了");

        //ロード終了
        isKOSystemLoading = false;

        #region ループ（隠れポジション選択・移動）

        while (isKOSystem == true)
        {
            //■CharacterControllerを更新し続ける（物理挙動はCharacterControllerが独立して計算しているため）
            KO_CharacterController.SimpleMove(Vector3.zero);

            #region RayでPosオブジェ選択、ボタン押しで移動
            if (isNovelSetVisIng == false || isNowNovelAutoVis)//ためしにノベル時強制ストップ//オート時はOK
            {
                #region Ray（マスクはseeRayBlockも含んでいる）
                if (Physics.Raycast(playerSeeRay, out KO_kakurePosRayHit, Mathf.Infinity, seeRayKakurePosLayerMask))
                {
                    #region 見て選択、色音処理
                    if (KO_kakurePosRayHit.collider.gameObject.tag == "kakurePosObj")
                    {
                        //■見てるPosが初見なら
                        if (KO_nowSeePosCollider != KO_kakurePosRayHit.collider)
                        {
                            //■now更新
                            KO_nowSeePosCollider = KO_kakurePosRayHit.collider;

                            //nowが 現移動先Posでないなら
                            if (KO_nowSeePosCollider != KO_nowMovePosCollider)
                            {
                                #region パーティクルObj版なら
                                if (KO_isParticleObjMode)
                                {
                                    //■色変え
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(true);
                                    KO_nowSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);

                                    //prevが nowでなく、現移動先でもなければ prevのpos色を戻す
                                    if (KO_prevSeePosCollider != null &&
                                    KO_prevSeePosCollider != KO_nowSeePosCollider &&
                                    KO_prevSeePosCollider != KO_nowMovePosCollider)
                                    {
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(true);
                                        KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                                    }
                                }
                                #endregion
                                #region 従来のスフィア版
                                else
                                {

                                    //■色変え(NewOffならNewOnに)
                                    if (KO_nowSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOffMat.color)
                                    { KO_nowSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOnMat; }
                                    else
                                    { KO_nowSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOnMat; }

                                    //prevが nowでなく、現移動先でもなければ prevのpos色を戻す
                                    if (KO_prevSeePosCollider != null &&
                                    KO_prevSeePosCollider != KO_nowSeePosCollider &&
                                    KO_prevSeePosCollider != KO_nowMovePosCollider)
                                    {
                                        //NewOnならNewOffに
                                        if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                                        { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                                        else
                                        { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                                    }
                                }
                                #endregion

                                //■prev更新
                                KO_prevSeePosCollider = KO_nowSeePosCollider;

                                SEPlay(UISEObj, "UI_pin");
                            }
                        }

                        //■pos見続けてる間 ボタン入力待ち
                        if (KO_nowSeePosCollider == KO_kakurePosRayHit.collider)
                        {
                            //if (Input.GetButtonDown(DB.inputDict["移動ポイント前進デジタル"]) == true)
                            if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0
                                || isKettei == true)
                            {
                                //それが現移動先Posでないなら音と色変え 現移動先にする
                                if (KO_nowMovePosCollider != KO_nowSeePosCollider)
                                {
                                    #region パーティクルObj版なら
                                    if (KO_isParticleObjMode)
                                    {
                                        //初回でなければ、前の移動先pos色戻し
                                        if (KO_nowMovePosCollider != null)
                                        {
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                            KO_nowMovePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                                        }
                                        //現移動先 更新
                                        KO_nowMovePosCollider = KO_nowSeePosCollider;
                                        //戻り先も更新
                                        backMovePos = CameraObjectsTrs.position;
                                        //色
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(false);
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                        KO_nowMovePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(true);

                                    }
                                    #endregion
                                    #region 従来のスフィア版
                                    else
                                    {
                                        //初回でなければ、前の移動先pos色戻し
                                        if (KO_nowMovePosCollider != null)
                                        {
                                            KO_nowMovePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat;
                                        }

                                        //現移動先 更新
                                        KO_nowMovePosCollider = KO_nowSeePosCollider;
                                        //戻り先も更新
                                        backMovePos = CameraObjectsTrs.position;
                                        //色
                                        KO_nowMovePosCollider.GetComponent<Renderer>().material = KO_kakurePosEnterMat;
                                    }
                                    #endregion

                                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                    //フラグ
                                    KO_isMovePosSet = true;
                                }
                            }
                        }
                    }
                    else //tagがkakurePosObjでなかった場合(あらぬ方向見ている場合)
                    {
                        //前回見てたposがあるなら それの色戻し
                        if (KO_prevSeePosCollider != KO_nowMovePosCollider && KO_prevSeePosCollider != null)
                        {
                            #region パーティクルObj版なら
                            if (KO_isParticleObjMode)
                            {
                                KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                                KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                                KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                            }
                            #endregion
                            #region 従来のスフィア版
                            else
                            {
                                //NewOnならNewOffに
                                if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                                { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                                else
                                { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                            }
                            #endregion

                            KO_nowSeePosCollider =
                            KO_prevSeePosCollider = null;
                        }
                    }

                    #endregion
                }
                else //■Rayが何にもヒットしていない場合（SeeRayBlockにもヒットしてない場合）(あらぬ方向と同処理)
                {
                    //前回見てたposがあるなら それの色戻し
                    if (KO_prevSeePosCollider != KO_nowMovePosCollider && KO_prevSeePosCollider != null)
                    {
                        #region パーティクルObj版なら
                        if (KO_isParticleObjMode)
                        {
                            KO_prevSeePosCollider.transform.Find("RootNaviEffect").gameObject.SetActive(true);
                            KO_prevSeePosCollider.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
                            KO_prevSeePosCollider.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
                        }
                        #endregion
                        #region 従来のスフィア版
                        else
                        {
                            //NewOnならNewOffに
                            if (KO_prevSeePosCollider.GetComponent<Renderer>().material.color == KO_kakurePosNewOnMat.color)
                            { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosNewOffMat; }
                            else
                            { KO_prevSeePosCollider.GetComponent<Renderer>().material = KO_kakurePosOffMat; }
                        }
                        #endregion

                        KO_nowSeePosCollider =
                        KO_prevSeePosCollider = null;
                    }
                }

                #endregion

                #region 移動先が存在するフラグ立ってれば ボタン押し続けでそこへ移動（Lockがかかってなければ）
                if (KO_isMovePosSet == true && KO_isMovePosLock == false)
                {
                    if (//問題切り分けのためアナログはずし //Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0 ||
                            isKettei == true)
                    {
                        //到着後ぶるぶるしないように距離計り(高さ無視)
                        float distanceFlt =
                            Vector3.Distance(
                            new Vector3(KO_nowMovePosCollider.transform.position.x, 0, KO_nowMovePosCollider.transform.position.z)
                            , new Vector3(CameraObjectsTrs.position.x, 0, CameraObjectsTrs.position.z));
                        //Debug.Log(distanceFlt);
                        //0.1で到着とみなし
                        if (distanceFlt >= 0.1f)
                        {
                            //移動しているtrue（アニメ用）
                            if (KO_isMove == false) { KO_isMove = true; }

                            #region アナログの速度数値置き換え（デジタルの場合は1）

                            float inputSpeed;

                            ////アナログ切り
                            //if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) < 0)
                            //{ inputSpeed = Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]); }
                            //else
                            //{
                            inputSpeed = 1;
                            //}
                            #endregion
                            #region 前進
                            //方向取り
                            KO_moveDirection = KO_nowMovePosCollider.transform.position - CameraObjectsTrs.position;
                            //ノーマライズ
                            KO_moveDirection = KO_moveDirection.normalized;
                            //■移動（ワールド座標なのでYがゼロ（浮かせない））
                            CameraObjectsTrs.Translate(new Vector3(KO_moveDirection.x, 0, KO_moveDirection.z)
                                * inputSpeed
                                * playerMoveSpeed
                                * Time.deltaTime
                                * GameObjectsTrs.localScale.z
                                * nowPlayerLocalScale.z
                                , Space.World);

                            //アニメ用に現在移動しているポイントをクラス変数に
                            KO_nowMovePos = KO_nowMovePosCollider.transform.position;
                            #endregion
                            #region 足音
                            if (KO_AsiotoTimeCountFloat < KO_AsiotoTimeCountMaxFloat)
                            {
                                KO_AsiotoTimeCountFloat += 1 * Time.deltaTime;
                            }
                            else
                            {
                                KO_AsiotoTimeCountFloat = 0;
                                SEPlay(UISEObj, KO_PlayerAsioto_DefList[UnityEngine.Random.Range(0, KO_PlayerAsioto_DefList.Count)], 0.3f);
                            }
                            #endregion
                        }
                        //到着してるのでアニメやめ
                        else { if (KO_isMove) { KO_isMove = false; } }

                    }
                    else if (
                        //切り分けのためアナログはずし //Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) < 0 ||
                        isBack == true)
                    {
                        //到着後ぶるぶるしないように距離計り(高さ無視)
                        float distanceFlt =
                            Vector3.Distance(
                            new Vector3(backMovePos.x, 0, backMovePos.z)
                            , new Vector3(CameraObjectsTrs.position.x, 0, CameraObjectsTrs.position.z));

                        //0.1で到着とみなし
                        if (distanceFlt >= 0.1f)
                        {
                            //移動しているtrue（アニメ用）
                            if (KO_isMove == false) { KO_isMove = true; }
                            #region アナログの速度数値置き換え（デジタルの場合は-1）

                            float inputSpeed;

                            //if (Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]) > 0)
                            //{ inputSpeed = Input.GetAxis(DB.inputDict["移動ポイント前進後退アナログ"]); }
                            //else
                            //{
                            inputSpeed = -1;
                            //}
                            #endregion
                            #region 後退
                            //方向取り
                            KO_moveDirection = CameraObjectsTrs.position - backMovePos;
                            //ノーマライズ
                            KO_moveDirection = KO_moveDirection.normalized;
                            //移動（ワールド座標なのでYがゼロ（浮かせない））
                            CameraObjectsTrs.Translate(new Vector3(KO_moveDirection.x, 0, KO_moveDirection.z)
                                * inputSpeed
                                * playerMoveSpeed
                                * Time.deltaTime
                                * GameObjectsTrs.localScale.z
                                * nowPlayerLocalScale.z
                                , Space.World);

                            //アニメ用に現在移動しているポイントをクラス変数に
                            KO_nowMovePos = backMovePos;
                            #endregion
                        }
                        //到着してるのでアニメやめ
                        else { if (KO_isMove) { KO_isMove = false; } }

                    }
                    //どちらも押してない場合 移動しているフラグfalse（アニメ用）
                    else
                    { if (KO_isMove) { KO_isMove = false; } }

                }
                else //移動先存在なし || Lock時 もフラグfalse（アニメ用）
                { if (KO_isMove) { KO_isMove = false; } }
                #endregion

            }
            else//ノベル表示中
            {
                //移動しているfalse（アニメ用）
                if (KO_isMove == true) { KO_isMove = false; }
            }

            #endregion //RayでPosオブジェ選択、ボタン押しで移動
            yield return null;
        }
        #endregion □隠れポジション選択・移動ループ

        #region 終了処理 リストに入れたポイントObj削除もここ
        KO_isMovePosLock = false;//移動止め解除
        KO_isMovePosSet = false;//移動先なしに

        //Destroy(EV_C_KakureOni);
        Destroy(KO_CharacterController);

        //他にポインターシステム使用するものが起動してなければ終了させる
        SeePointSystemOff();

        //隠れ場所オブジェ削除
        for (int i = 0; i < KO_KakurePosObjsList.Count; i++)
        {
            Destroy(KO_KakurePosObjsList[i]);
        }

        //Resources.UnloadUnusedAssets();
        Debug.Log("シンプル移動システム終了処理完了");

        #endregion
    }


    //新移動ポイント出現拡縮演出メソッド
    public void KO_NewPosPointObjVis(GameObject PosPointObj, float volume = 1, bool isSyutugenScale = true)
    {
        //一度OFFっておかないとなぜか反応しなくなった（元からOFFにしててもOKだったが、念のため）
        if (KO_isParticleObjMode)
        { PosPointObj.GetComponent<CapsuleCollider>().enabled = false; }
        else { PosPointObj.GetComponent<SphereCollider>().enabled = false; }

        #region 子の到着検知用コリダーObjもオフ（拡大縮小で当たると検知しちゃう）
        foreach (Transform k in PosPointObj.transform)
        {
            if (k.GetComponent<Collider>() != null)
            { k.GetComponent<Collider>().enabled = false; }
        }

        #endregion

        #region パーティクルObj版なら
        if (KO_isParticleObjMode)
        {
            PosPointObj.transform.Find("RootNaviEffect").gameObject.SetActive(true);
            PosPointObj.transform.Find("RootNaviEffectGreen").gameObject.SetActive(false);
            PosPointObj.transform.Find("RootNaviEffectStop").gameObject.SetActive(false);
        }
        #endregion
        #region 従来のスフィア版
        else
        {
            //表示ON
            PosPointObj.GetComponent<Renderer>().enabled = true;

            //Newカラーに
            PosPointObj.GetComponent<Renderer>().material = KO_kakurePosNewOffMat;
        }
        #endregion


        //デフォルトの大きさ保持
        Vector3 defScale = PosPointObj.transform.localScale;

        //拡大縮小演出
        if (isSyutugenScale)
        {
            //大きさゼロに(パーティクルのScaleを0にするとエラーがでるので、0.001に)
            PosPointObj.transform.localScale = new Vector3(0.001f, 0.001f, 0.001f);

            //デフォルトの大きさにTweenで戻る
            PosPointObj.transform.DOScale(defScale, 1f)
                .SetEase(Ease.OutElastic)
                .OnComplete(() =>//戻り次第にコリダーON
            {
                if (KO_isParticleObjMode)
                { PosPointObj.GetComponent<CapsuleCollider>().enabled = true; }
                else { PosPointObj.GetComponent<SphereCollider>().enabled = true; }
                #region 子の到着検知用コリダーObjも
                foreach (Transform k in PosPointObj.transform)
                {
                    if (k.GetComponent<Collider>() != null)
                    { k.GetComponent<Collider>().enabled = true; }
                }

                #endregion
            });
        }
        else //演出なしで即コリダーON
        {
            if (KO_isParticleObjMode)
            { PosPointObj.GetComponent<CapsuleCollider>().enabled = true; }
            else { PosPointObj.GetComponent<SphereCollider>().enabled = true; }

            //子の到着検知用コリダーObjも
            foreach (Transform k in PosPointObj.transform)
            {
                if (k.GetComponent<Collider>() != null)
                { k.GetComponent<Collider>().enabled = true; }
            }

        }

        SEPlay(KO_IdouPoint3DSEObj, "ui_casual_musical_open", PosPointObj, volume);

    }

    //■智恵理行動システム
    #region 智恵理行動システム変数（まだプレイヤー移動システムの変数混ざってるかも）
    //智恵理場所 
    List<Transform>
        KO_ChieriPosTrssList = new List<Transform>();

    GameObject
        KO_GreenImageObj,
        KO_YellowImageObj,
        KO_RedImageObj;

    public bool //智恵理の跨ぎオブジェからのコリジョン判定受け取り用
        KO_ChieriMatagiColOnTriggerStayBool;

    bool //コルーチン重複防止・終了用
        KO_chieriSerchCorBool,
        //以下は入れ子コルーチン
        KO_ChieriWalkColBool,
        KO_ChieriHuseColBool,
        KO_ChieriKidukiColBool,
        KO_ChieriNayamuColBool,
        KO_ChieriGameOverColBool;

    bool
        KO_HuseTansakuBool = false,
        KO_HakkenBool = false;
    int
        KO_NowChieriTaskInt = 1;
    RaycastHit
        KO_ChieriREyeRayHit,
        KO_ChieriLEyeRayHit,
        KO_playerUpRayHit;

    Coroutine //強制終了用
        KO_KakurePointSerchCorCoroutine,
        KO_ChieriSerchCorCoroutine;
    IEnumerator //入れ子コルーチン一時停止用
        KO_NowChieriKakurenboEyeRayIEnum,
        KO_NowChieriKakurenboWalkIEnum,
        KO_NowChieriKakurenboHuseIEnum;


    public bool
        nowTaskBool = false,
        GreenBool = false,
        YellowBool = false,
        RedBool = false,
        walkBool = false,
        huseBool = false,
        kidukiBool = false,
        kidukiWalkBool = false,
        kidukiHuseStartBool = false,
        kidukiHuseBool = false,
        kidukiHuseEndBool = false;
    IEnumerator
        nowTaskIEnum;

    #endregion

    IEnumerator KO_ChieriSerchCor() //かくれおに 智恵理行動システム
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (KO_chieriSerchCorBool == true) { yield break; }
        KO_chieriSerchCorBool = true;
        //途中強制終了用コルーチン始動
        StartCoroutine(KO_ChieriSerchStopCor());

        #region 初期化

        //■UI設置
        if (GameObject.Find("KakureOni_UI") == null)
        { KakureOni_UI = Instantiate(Resources.Load("EventSystem/KakureOni/Prefab/KakureOni_UI") as GameObject, VRCameraTrs, false); }
        //編集用にすでに配置してある場合
        else { KakureOni_UI = GameObject.Find("KakureOni_UI"); }
        //子の子のGreenYellowRedそれぞれ取得
        KO_GreenImageObj = KakureOni_UI.transform.GetChild(0).Find("KO_GreenImage").gameObject;
        KO_YellowImageObj = KakureOni_UI.transform.GetChild(0).Find("KO_YellowImage").gameObject;
        KO_RedImageObj = KakureOni_UI.transform.GetChild(0).Find("KO_RedImage").gameObject;

        //■GirlTrsに跨ぎオブジェサーチ用ObjPrefabなければ生成
        if (GirlTrs.Find("KO_MatagiCollider") == null)
        { KO_MatagiColliderObj = Instantiate(Resources.Load("EventSystem/KakureOni/Prefab/KO_MatagiCollider") as GameObject, GirlTrs, false); }
        //編集用にすでに配置してある場合
        else { KO_MatagiColliderObj = GirlTrs.Find("KO_MatagiCollider").gameObject; }

        //■目Rayコルーチン始動
        StartCoroutine(KO_NowChieriKakurenboEyeRayIEnum = KO_ChieriEyeRayCor());
        #endregion

        Debug.Log("智恵理 隠れ鬼動作 設置・初期化完了");

        //初期位置
        GirlTrs.position = KO_ChieriPosTrssList[0].GetChild(0).position;
        GirlTrs.localEulerAngles = KO_ChieriPosTrssList[0].GetChild(0).rotation.eulerAngles;
        ChieriMotion("かくれおに探し歩きrootポーズ", 0f, 0);


        //UI色
        StartCoroutine(KO_UIColorSetCor());
        yield return new WaitForSeconds(2f);

        //■初期行動設定
        GreenBool = true;
        walkBool = true;

        #region ループ
        while (KO_chieriSerchCorBool)
        {
            //各行動の終了時にBoolで予約されている。
            //予約された行動を行う。
            //行動終了or気付き発生で行動は止まるので、状況判定して次の行動を決定
            //行動判断はすべてここで

            if (nowTaskBool == false)//現行動なし 次行動判断
            {
                #region ■歩き
                if (walkBool)
                {
                    if (GreenBool)//通常時
                    {
                        Vector3 taskPoint =
                            KO_ChieriPosTrssList[KO_NowChieriTaskInt].transform.GetChild(0).transform.position;

                        nowTaskIEnum = KO_ChieriWalkCor(taskPoint);
                    }
                    else if (YellowBool)//気づきor追いかけていた後なら 見失い地点へ
                    {
                        Vector3 miusinaiPoint =
                            KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].transform.GetChild(0).transform.position;

                        nowTaskIEnum = KO_ChieriWalkCor(miusinaiPoint);
                    }
                    else if (RedBool)//気づきor追いかけていた後なら 見失い地点へ
                    {
                        Vector3 miusinaiPoint =
                            KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].transform.GetChild(0).transform.position;

                        nowTaskIEnum = KO_ChieriWalkCor(miusinaiPoint);
                    }

                }
                #endregion
                #region ■伏せ
                else if (huseBool)
                {
                    if (GreenBool)//通常時
                    {
                        Transform taskTrs =
                            KO_ChieriPosTrssList[KO_NowChieriTaskInt].GetChild(0).transform;

                        nowTaskIEnum = KO_ChieriHuseCor(taskTrs);

                        //■タスクInt++
                        if (KO_NowChieriTaskInt < KO_ChieriPosTrssList.Count - 2)
                        { KO_NowChieriTaskInt++; }
                        //（智恵理ポジションリストの数分 行動していたら1へ戻す）
                        else { KO_NowChieriTaskInt = 1; }
                    }
                    else if (YellowBool)//気づきor追いかけ"後"なら 見失い地点
                    {
                        Transform miusinaiTrs =
                            KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].GetChild(0).transform;

                        nowTaskIEnum = KO_ChieriHuseCor(miusinaiTrs);
                    }
                    else if (RedBool)//気づきor追いかけ"後"なら 見失い地点
                    {
                        Transform miusinaiTrs =
                            KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].GetChild(0).transform;

                        nowTaskIEnum = KO_ChieriHuseCor(miusinaiTrs);
                    }
                }
                #endregion
                #region ■気付き
                else if (kidukiBool)
                {
                    nowTaskIEnum = KO_ChieriKidukiCor();
                }
                #endregion
            }
            //行動開始したので予約bool全部false
            walkBool =
            huseBool =
            kidukiBool = false;


            //コルーチン始動・待機
            Debug.Log("行動終了待ち");

            yield return StartCoroutine(nowTaskIEnum);
            Debug.Log("行動終了");



            yield return null;

        }

        ////■処理中、気づいた場合は歩きも伏せもキャンセルされここにくる。　気づきコルーチン終わるまで待機
        //while (KO_ChieriKidukiColBool)
        //    { yield return null; }



        //    //見失い地点フラグ外し
        //    if (KO_KidukiBool02miusinaiSagasi) { KO_KidukiBool02miusinaiSagasi = false; }


        #endregion かくれおに智恵理動作

    }
    IEnumerator KO_ChieriSerchStopCor()//↑の終了処理（ウェイトがあるので必要）
    {
        while (KO_chieriSerchCorBool == true) { yield return null; }

        //終了処理
        StopCoroutine(KO_ChieriSerchCorCoroutine);

        KO_isChieriSightColOnTriggerStay =
        KO_isChieriEyeRayColSystem =
        KO_ChieriWalkColBool =
        KO_ChieriHuseColBool =
        KO_ChieriKidukiColBool =
        KO_ChieriNayamuColBool = false;

        Resources.UnloadUnusedAssets();
        Debug.Log("智恵理探し終了処理完了");
    }

    #region 智恵理視界変数
    bool
        KO_isChieriEyeRayColSystem;
    GameObject
        KO_ChieriSightCapsuleObj,
        KO_ChieriEyeHitSliderObj;

    public bool//智恵理の視界Objからコリジョン判定受け取り用
        KO_isChieriSightColOnTriggerStay;
    public bool //智恵理視線ヒット判定用
        KO_isEyeHit = false,
        KO_isEyeHitDown = false,
        KO_isEyeHitUp = false,
        KO_isEyeRHit = false,
        KO_isEyeLHit = false,
        KO_isEyeNoHitMode = false;
    public float
        KO_EyeHitCountFloat = 0;
    Transform
        KO_ChieriREyeSphereTrs,
        KO_ChieriLEyeSphereTrs;
    Ray
        KO_chieriREyeRay,
        KO_chieriLEyeRay;
    LayerMask
        KO_chieriEyeRayLayerMask;

    Slider
        KO_ChieriEyeHitSlider;
    Material
        KO_ChieriEyeHitSliderOut,
        KO_ChieriEyeHitSliderHit;


    #endregion
    IEnumerator KO_ChieriEyeRayCor()//智恵理　視界・視線
    {
        //重複防止
        if (KO_isChieriEyeRayColSystem == true) { yield break; }
        KO_isChieriEyeRayColSystem = true;

        //■智恵理Bip001HeadTrsにサーチ用ObjPrefabなければ生成
        if (GameObject.Find("KO_ChieriSightCapsule") == null)
        { KO_ChieriSightCapsuleObj = Instantiate(Resources.Load("EventSystem/KakureOni/Prefab/KO_ChieriSightCapsule") as GameObject, Bip001HeadTrs, false); }
        //編集用にすでに配置してある場合
        else { KO_ChieriSightCapsuleObj = GameObject.Find("ChieriSightCapsule"); }

        //初期化
        KO_ChieriREyeSphereTrs = KO_ChieriSightCapsuleObj.transform.Find("ChieriREyeSphere").transform;
        KO_ChieriLEyeSphereTrs = KO_ChieriSightCapsuleObj.transform.Find("ChieriLEyeSphere").transform;

        KO_chieriEyeRayLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("RayToPlayerTarget")) +
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));

        //■UI見られ量スライダー設置
        if (GameObject.Find("KO_ChieriEyeHitSliderObj") == null)
        { KO_ChieriEyeHitSliderObj = Instantiate(Resources.Load("EventSystem/KakureOni/Prefab/KO_ChieriEyeHitSliderObj") as GameObject, VRUICameraTrs, false); }
        //編集用にすでに配置してある場合
        else { KO_ChieriEyeHitSliderObj = GameObject.Find("KO_ChieriEyeHitSliderObj"); }
        //消せるようにリストへ
        DB.evMoveDelObjList.Add(KO_ChieriEyeHitSliderObj);

        KO_ChieriEyeHitSlider = KO_ChieriEyeHitSliderObj.GetComponent<Slider>();
        Image KO_ChieriEyeHitSliderFillImage = KO_ChieriEyeHitSliderObj.transform.GetChild(0).GetComponent<Image>();
        KO_ChieriEyeHitSliderOut = Instantiate(Resources.Load("EventSystem/KakureOni/Mat/KO_ChieriEyeHitSliderOut") as Material);
        KO_ChieriEyeHitSliderHit = Instantiate(Resources.Load("EventSystem/KakureOni/Mat/KO_ChieriEyeHitSliderHit") as Material);

        //Ray当てて、状況に合わせて判定(RayとHitBoolはFixedにある)
        while (KO_isChieriEyeRayColSystem)
        {
            //■両目どちらかがHIT中 カウンタープラス
            if (KO_isEyeHit)
            {
                //Downで一回のみ処理
                if (KO_isEyeHitDown)
                {
                    KO_ChieriEyeHitSliderFillImage.material = KO_ChieriEyeHitSliderHit;
                }

                //値更新
                if (!KO_isEyeNoHitMode)
                { KO_ChieriEyeHitSlider.value += 1 * Time.deltaTime; }

            }
            //外れたらカウントマイナス（※以前は即ゼロだった）
            else if (!KO_isEyeHit && KO_ChieriEyeHitSlider.value > 0)
            {
                //Upで一回のみ処理
                if (KO_isEyeHitUp)
                {
                    KO_ChieriEyeHitSliderFillImage.material = KO_ChieriEyeHitSliderOut;
                }
                KO_ChieriEyeHitSlider.value += -0.8f * Time.deltaTime;
            }
            //カウントが0以下になったとき
            else if (KO_ChieriEyeHitSlider.value < 0)
            {
                KO_ChieriEyeHitSlider.value = 0;
                //カウントゼロ時の処理群
                //目線やめ
                if (!isD2200a) { DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1); }
            }
            yield return null;
        }

        //終了処理
        Destroy(KO_ChieriSightCapsuleObj);
        //ゲージちょっと後消し
        yield return new WaitForSeconds(3);
        Destroy(KO_ChieriEyeHitSliderObj);
    }
    IEnumerator KO_UIColorSetCor()//UIの色と表示変更メソッド
    {
        while (KO_chieriSerchCorBool)
        {
            if (GreenBool)
            {
                KO_GreenImageObj.SetActive(true);
                KO_YellowImageObj.SetActive(false);
                KO_RedImageObj.SetActive(false);
            }
            else if (YellowBool)
            {
                KO_GreenImageObj.SetActive(false);
                KO_YellowImageObj.SetActive(true);
                KO_RedImageObj.SetActive(false);
            }
            else if (RedBool)
            {
                KO_GreenImageObj.SetActive(false);
                KO_YellowImageObj.SetActive(false);
                KO_RedImageObj.SetActive(true);
            }
            else
            {
                KO_GreenImageObj.SetActive(false);
                KO_YellowImageObj.SetActive(false);
                KO_RedImageObj.SetActive(false);
            }
            yield return null;
        }
    }

    //■智恵理行動群
    IEnumerator KO_ChieriWalkCor(Vector3 movePos)//歩き
    {
        //重複防止
        if (KO_ChieriWalkColBool == true) { yield break; }
        KO_ChieriWalkColBool = true;

        #region////足音テスト
        //Transform Tang0000Trs = GameObject.Find("Tang0000").transform;
        //bool asiotoBool = false;

        ////足音テスト
        //if (asiotoBool == false && Tang0000Trs.localRotation.z < 3.000000E-07)
        //{
        //    SEPlay("bosu31_bom19_mishi_100倍足音_村_遠く");
        //    asiotoBool = true;
        //}
        //else if (asiotoBool == true && Tang0000Trs.localRotation.z > 4.000000E-07)
        //{
        //    asiotoBool = false;
        //}
        //Debug.Log(Tang0000Trs.localRotation.z);
        #endregion

        //追いかけ時だったら、回転判断なし（歩みとめずそのまま歩き続ける）
        if (RedBool)
        { }
        //回転判断
        else
        {
            #region 智恵理から右にあるか左にあるか判断して 歩きモーションへ
            //智恵理から見た行き先の相対位置 //これのX+ Z+なら前方右 X+ Z-なら後方右 X- Z+なら前方左　X- Z-なら後方左　　
            Vector3 tempV3 = GirlTrs.InverseTransformDirection(movePos - GirlTrs.position);
            //角差を求める
            float kakusaFloat = Vector3.Angle(GirlTrs.forward, movePos - GirlTrs.position);

            if (tempV3.x > 0)
            {
                if (25 < kakusaFloat && kakusaFloat < 135)
                {
                    Debug.Log("migi90");
                    ChieriMotion("かくれおに立ち右90度回転root", 0.1f, 0);
                    GirlTrs.DORotate(Quaternion.LookRotation(movePos - GirlTrs.position).eulerAngles, 4f).SetEase(Ease.OutCubic);
                }
                else if (135 <= kakusaFloat && kakusaFloat <= 180)
                {
                    Debug.Log("migi180");
                    ChieriMotion("かくれおに立ち右180度回転root", 0.1f, 0);
                    GirlTrs.DORotate(Quaternion.LookRotation(movePos - GirlTrs.position).eulerAngles, 4f).SetEase(Ease.InOutCubic);
                }
            }
            else if (tempV3.x <= 0)
            {
                if (25 < kakusaFloat && kakusaFloat < 135)
                {
                    Debug.Log("hidari90");
                    ChieriMotion("かくれおに立ち左90度回転", 0.1f, 0);
                    GirlTrs.DORotate(Quaternion.LookRotation(movePos - GirlTrs.position).eulerAngles, 4f).SetEase(Ease.OutCubic);
                }
                else if (135 <= kakusaFloat && kakusaFloat <= 180)
                {
                    Debug.Log("hidari180");
                    ChieriMotion("かくれおに立ち左180度回転", 0.1f, 0);
                    GirlTrs.DORotate(Quaternion.LookRotation(movePos - GirlTrs.position).eulerAngles, 4f).SetEase(Ease.InOutCubic);
                }
            }
            //回転しない場合
            if (kakusaFloat <= 25)
            {
                Debug.Log("no回転");
                ChieriMotion("かくれおに探し歩きroot開始", 0.1f, 0);
            }
            #endregion
        }



        bool matagiBool = false;

        //■移動ループ
        while (KO_ChieriWalkColBool == true)
        {
            //■歩いてる最中なら、少しずつ進行方向へ向く
            if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "かくれおに探し歩きrootループ")
            { GirlTrs.rotation = Quaternion.Slerp(GirlTrs.rotation, Quaternion.LookRotation(movePos - GirlTrs.position), 1f * Time.deltaTime); }

            //■目的地にほぼ到着したら、伏せ予約して抜け
            if ((GirlTrs.position - movePos).magnitude < 20f)
            {
                KO_ChieriWalkColBool = false;
                huseBool = true;
                yield break;
            }

            //■視線判定、3色それぞれ
            //Green 視界に3秒以上入ったら、気付き予約、歩き時判定bool入れて抜け
            else if (GreenBool && KO_EyeHitCountFloat > 3)
            {
                KO_ChieriWalkColBool = false;
                kidukiBool = true;
                kidukiWalkBool = true;
                yield break;
            }
            //Yellow2秒で
            else if (YellowBool && KO_EyeHitCountFloat > 2)
            {
                KO_ChieriWalkColBool = false;
                kidukiBool = true;
                kidukiWalkBool = true;
                yield break;
            }
            //Red1秒で
            else if (RedBool && KO_EyeHitCountFloat > 1)
            {
                KO_ChieriWalkColBool = false;
                kidukiBool = true;
                kidukiWalkBool = true;
                yield break;
            }



            //■跨ぎ範囲に跨ぎタグオブジェクトあれば跨ぐ
            if (KO_ChieriMatagiColOnTriggerStayBool && matagiBool == false)
            {
                Debug.Log("またぎ");
                ChieriMotion("かくれおに跨ぎroot", 0.1f, 0);
                matagiBool = true;
            }
            //跨ぎObj接触なくなって跨ぎが終わったらbool戻し
            if (KO_ChieriMatagiColOnTriggerStayBool == false &&
                girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name != "かくれおに跨ぎroot" &&
                matagiBool)
            {
                Debug.Log("またぎ再設定");
                matagiBool = false;
            }


            yield return null;


        }

    }
    IEnumerator KO_ChieriHuseCor(Transform huseTrs)//伏せ
    {
        //重複防止
        if (KO_ChieriHuseColBool) { yield break; }
        KO_ChieriHuseColBool = true;

        //■伏せアニメ 開始
        Debug.Log("伏せ 開始");
        ChieriMotion("かくれおに探し伏せ開始", 0.4f, 0);
        //DOTWeenで回転
        GirlTrs.DORotate(huseTrs.rotation.eulerAngles, 1f);
        //アニメ終わりまでウェイト
        bool tmpBool = true;
        while (tmpBool)
        {
            if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "かくれおに探し伏せ移行ループ")
            { tmpBool = false; }

            #region ■視線判定、3色それぞれ
            //Green 視界に3秒以上入ったら、気付き予約、歩き時判定bool入れて抜け
            if (GreenBool && KO_EyeHitCountFloat > 3)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseStartBool = true;
                yield break;
            }
            //Yellow2秒で
            else if (YellowBool && KO_EyeHitCountFloat > 2)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseStartBool = true;
                yield break;
            }
            //Red1秒で
            else if (RedBool && KO_EyeHitCountFloat > 1)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseStartBool = true;
                yield break;
            }
            #endregion

            yield return null;
        }


        Debug.Log("伏せ 探索");
        ChieriMotion("かくれおに探し伏せ右開始", 0.4f, 0);
        //伏せ探索最中判定Bool
        KO_HuseTansakuBool = true;

        //●気づき状態なら視点プレイヤーへ（暫定）
        if (YellowBool)
        {
            //顔見
            FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
            FollowDOMove(IKLookAtHeadTargetTrs, PlayerHeadTargetTrs);
            DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1);
            DOTweenToLAIKSHead(LAIKHeadS, LAIKSHeadDefWeight, 1);
        }

        //探索中のため時間でウェイト
        float tempCountFloat = 0;
        while (tempCountFloat < 5)
        {
            tempCountFloat += 1 * Time.deltaTime;

            #region ■視線判定、3色それぞれ
            //Green 視界に3秒以上入ったら、気付き予約、歩き時判定bool入れて抜け
            if (GreenBool && KO_EyeHitCountFloat > 3)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseBool = true;
                yield break;
            }
            //Yellow2秒で
            else if (YellowBool && KO_EyeHitCountFloat > 2)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseBool = true;
                yield break;
            }
            //Red1秒で
            else if (RedBool && KO_EyeHitCountFloat > 1)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseBool = true;
                yield break;
            }
            #endregion

            yield return null;
        }
        tempCountFloat = 0;


        //■立ち上がり
        Debug.Log("伏せ 立ち上がり");
        ChieriMotion("かくれおに探し伏せ終了", 0.4f, 0);
        //伏せ最中判定Bool
        KO_HuseTansakuBool = false;

        if (YellowBool || RedBool)
        {
            //「あれーいない」
            Hukidashi("C1126");
            YellowBool =
            RedBool = false;
            GreenBool = true;
        }

        //顔見やめ
        FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
        FollowDOMove(IKLookAtHeadTargetTrs, PlayerHeadTargetTrs);
        DOTweenToLAIKSEyes(LAIKEyeS, 0, 1);
        DOTweenToLAIKSHead(LAIKHeadS, 0, 1);

        //アニメ終わりまでウェイト
        tmpBool = true;
        while (tmpBool)
        {
            if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "かくれおに探し歩きrootポーズ")
            { tmpBool = false; }

            #region ■視線判定、3色それぞれ
            //Green 視界に3秒以上入ったら、気付き予約、歩き時判定bool入れて抜け
            if (GreenBool && KO_EyeHitCountFloat > 3)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseEndBool = true;
                yield break;
            }
            //Yellow2秒で
            else if (YellowBool && KO_EyeHitCountFloat > 2)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseEndBool = true;
                yield break;
            }
            //Red1秒で
            else if (RedBool && KO_EyeHitCountFloat > 1)
            {
                KO_ChieriHuseColBool = false;
                kidukiBool = true;
                kidukiHuseEndBool = true;
                yield break;
            }
            #endregion


            yield return null;
        }


        KO_ChieriHuseColBool = false;
        walkBool = true;
        yield break;
    }
    IEnumerator KO_ChieriKidukiCor()//気付き
    {
        //重複防止
        if (KO_ChieriKidukiColBool == true) { yield break; }
        KO_ChieriKidukiColBool = true;

        Debug.Log("気づき");
        SEPlay(UISEObj, "ui_notification_04");

        //顔見
        FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
        FollowDOMove(IKLookAtHeadTargetTrs, PlayerHeadTargetTrs);
        DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1);
        DOTweenToLAIKSHead(LAIKHeadS, LAIKSHeadDefWeight, 1);

        //■■気付き時の行動がなんだったかで分岐
        //歩きから
        if (kidukiWalkBool)
        {
            #region ■歩きから三色分岐

            if (GreenBool)
            {
                //歩き止めて、探しモードに
                ChieriMotion("かくれおに探し歩きrootポーズ", 0.4f, 0);
                //「ん？」
                Hukidashi("C1110");
            }
            else if (YellowBool)
            {
                //「見つけた！」
                Hukidashi("C1115");
                //そのままリアルタイム追いかけへ
                GreenBool =
                YellowBool = false;
                RedBool = true;
                goto リアルタイム追いかけ;
            }
            else if (RedBool)
            {
                //「いたいた」
                Hukidashi("C1116");
                //そのままリアルタイム追いかけへ
                GreenBool =
                YellowBool = false;
                RedBool = true;
                goto リアルタイム追いかけ;
            }
            #endregion
        }
        //伏せから
        else if (kidukiHuseStartBool)
        {
            #region ■伏せ開始・探索・終了の三つからそれぞれ三色分岐
            if (GreenBool)
            {
                //伏せアニメやめて「ん？」
                //「んん？」
                Hukidashi("C1111");
            }
            else if (YellowBool)
            {
                //「あ、やっぱり！」
                Hukidashi("C1123");
                goto リアルタイム追いかけ;
            }
            else if (RedBool)
            {
                //「諦めないね～」
                Hukidashi("C1124");
                goto リアルタイム追いかけ;
            }

        }
        //探索中
        else if (kidukiHuseBool)
        {
            //■近いかどうかで更に分岐？（ゲームオーバー）
            if (GreenBool)
            {
                //伏せながら「ん？」
                //「んん？」
                Hukidashi("C1111");
                Debug.Log("伏せ探索で発見(Green)");
                Debug.Break();
            }
            else if (YellowBool)
            {
                Debug.Log("伏せ探索で発見");
                Debug.Break();
            }
            else if (RedBool)
            {
                Debug.Log("伏せ探索で発見");
                Debug.Break();
            }
        }
        //立ち上がり
        else if (kidukiHuseEndBool)
        {
            //■見つからず立ち上がりはGreenのみになりそう
            if (GreenBool)
            {
                //立ち上がりながら「見つけた！」
                Hukidashi("C1115");
                goto リアルタイム追いかけ;
            }
            else if (YellowBool)
            {
                //「あ、やっぱり！」
                Hukidashi("C1123");
                goto リアルタイム追いかけ;
            }
            else if (RedBool)
            {
                //「諦めないね～」
                Hukidashi("C1124");
                goto リアルタイム追いかけ;
            }
            #endregion
        }

        #region ■探しモード
        GreenBool =
        RedBool = false;
        YellowBool = true;
        float tempCountFloat = 5;
        bool tempLostBool = false;
        while (YellowBool == true)
        {
            //見られ続けてる場合
            if (KO_isEyeHit)
            {
                tempCountFloat += 1 * Time.deltaTime;
                if (tempCountFloat < 5) { tempCountFloat = 5; }

                //智恵理移動先解除
                if (tempLostBool) { tempLostBool = false; }

                //一定時間見られ続けた場合 フラグRedBool立てて抜ける
                else if (tempCountFloat > 9)
                {
                    GreenBool =
                    YellowBool = false;
                    RedBool = true;



                    #region ■抜ける前に台詞
                    if (kidukiWalkBool) //歩き状態で発見に至った
                    {
                        //「ふっふふ～みーっけ」
                        Hukidashi("C1130");
                    }
                    #endregion
                }
            }
            //視線から外れてる場合 
            else
            {
                tempCountFloat -= 1 * Time.deltaTime;
                if (tempCountFloat > 5) { tempCountFloat = 5; }

                //見失った地点に智恵理移動先オブジェ設定
                if (tempLostBool == false)
                {
                    //見失い位置代入
                    KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].position
                        = new Vector3(KO_ChieriREyeRayHit.point.x, 0, KO_ChieriREyeRayHit.point.z);
                    //移動先オブジェ智恵理からプレイヤーへの方向に回転
                    Vector3 PlayerTargetTrsPosYZeroV3 = new Vector3(PlayerTargetTrs.position.x, 0, PlayerTargetTrs.position.z);
                    KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].rotation
                        = Quaternion.LookRotation(PlayerTargetTrsPosYZeroV3 - GirlTrs.position);
                    tempLostBool = true;
                }

                //一定時間はずれ続けた場合 そのまま抜ける
                if (tempCountFloat < 3)
                {
                    goto 見失い;
                }
            }
            yield return null;
        }
        #endregion 気づいて視線送り

        リアルタイム追いかけ:
        #region ■歩きしてない場合は歩き始める
        if (kidukiWalkBool)
        {
            //■歩き始め
            if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name != "かくれおに探し歩きrootループ")
            { ChieriMotion("かくれおに探し歩きrootループ", 0.4f, 0); }
        }
        #endregion //立ち止まり時は歩き始める

        #region ■伏せ時用アニメーション終了待ち 後、歩き始める
        if (kidukiHuseStartBool)
        {
            //■立ち上がり
            Debug.Log("気付きで伏せから立ち上がり");
            ChieriMotion("かくれおに探し伏せ終了", 0.4f, 0);

            //アニメ終わりまでウェイト
            bool tmpBool = true;
            while (tmpBool)
            {
                if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                    girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "かくれおに探し歩きrootポーズ")
                {
                    tmpBool = false;
                    ChieriMotion("かくれおに探し歩きrootループ", 0.4f, 0);
                }

                yield return null;
            }
        }

        #endregion

        GreenBool =
        YellowBool = false;
        RedBool = true;
        #region ■発見に至って 追いかける
        if (RedBool)
        {
            //■追いかけ
            Vector3 PlayerTargetTrsPosYZeroV3;
            bool matagiBool = false;
            while (RedBool)
            {

                PlayerTargetTrsPosYZeroV3 = new Vector3(PlayerTargetTrs.position.x, 0, PlayerTargetTrs.position.z);

                //歩いてる時に進行方向へ向く
                if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                    girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "かくれおに探し歩きrootループ")
                { GirlTrs.rotation = Quaternion.Slerp(GirlTrs.rotation, Quaternion.LookRotation(PlayerTargetTrsPosYZeroV3 - GirlTrs.position), 1f * Time.deltaTime); }


                //跨ぎ範囲に跨ぎタグオブジェクトあれば跨ぐ
                if (KO_ChieriMatagiColOnTriggerStayBool && matagiBool == false)
                {
                    Debug.Log("またぎ");
                    ChieriMotion("かくれおに跨ぎroot", 0.1f, 0);
                    matagiBool = true;
                }
                //跨ぎObj接触なくなって跨ぎが終わったらbool戻し
                if (KO_ChieriMatagiColOnTriggerStayBool == false &&
                    girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0 && //空の時エラー吐かないように
                    girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name != "かくれおに跨ぎroot" &&
                    matagiBool)
                {
                    Debug.Log("またぎ再設定");
                    matagiBool = false;
                }

                //■隠れたら抜ける （何に隠れたかRayから取得して台詞にできそう）
                if (KO_isEyeHit == false)
                {
                    //見失った地点に智恵理移動先オブジェ設定
                    KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].position
                        = new Vector3(KO_ChieriREyeRayHit.point.x, 0, KO_ChieriREyeRayHit.point.z);
                    //移動先オブジェ　智恵理からプレイヤーへの方向に回転
                    KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].rotation
                        = Quaternion.LookRotation(PlayerTargetTrsPosYZeroV3 - GirlTrs.position);

                    goto 見失い;
                }

                //■■目的地にほぼ到着したら
                //止まり Boolオフ（ゲームオーバー演出へ進む予定）
                if ((GirlTrs.position - PlayerTargetTrsPosYZeroV3).magnitude < 30f)
                {
                    ChieriMotion("かくれおに探し伏せ開始", 0.4f, 0);
                    Debug.Log("ゲームオーバー（直接歩きで到着）");
                    StartCoroutine(KO_ChieriGameOver());
                }
                yield return null;
            }

            Debug.Log("追いかけ終了");
        }

        #endregion//発見されていたら 追いかける

        見失い:
        #region 見失っても最後に見た場所を探される
        //発見したかどうかで台詞替え
        if (RedBool)
        { Hukidashi("C1150"); } //「隠れてる」
        else
        { Hukidashi("C1120"); } //「今この辺に・・」

        Debug.Log("見失い");
        SEPlay(UISEObj, "ui_casual_musical_confirm");

        //最後に見た場所を見続け
        FollowDOMove(IKLookAtEyeTargetTrs, KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].transform);
        FollowDOMove(IKLookAtHeadTargetTrs, KO_ChieriPosTrssList[KO_ChieriPosTrssList.Count - 1].transform);
        DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1);
        DOTweenToLAIKSHead(LAIKHeadS, LAIKSHeadDefWeight, 1);

        //抜ける
        walkBool = true;
        #endregion 見失っても最後に見た場所を探される

        KO_ChieriKidukiColBool = false;
        yield break;
    }
    IEnumerator KO_ChieriNayamuCor()//悩み
    {
        //重複防止
        if (KO_ChieriNayamuColBool == true) { yield break; }
        KO_ChieriNayamuColBool = true;
        yield break;
    }
    IEnumerator KO_ChieriGameOver()//ゲームオーバー
    {
        //重複防止
        if (KO_ChieriGameOverColBool == true) { yield break; }
        KO_ChieriGameOverColBool = true;

        #region//かくれおに終了処理
        isKOSystem =
        KO_chieriSerchCorBool =
        KO_isChieriEyeRayColSystem =
        KO_ChieriWalkColBool =
        KO_ChieriHuseColBool =
        KO_ChieriKidukiColBool =
        KO_ChieriNayamuColBool = false;
        #endregion


        //顔見
        IKLookAtEyeTargetTrs.position = PlayerEyeTargetTrs.position;
        IKLookAtHeadTargetTrs.position = PlayerHeadTargetTrs.position;
        FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
        FollowDOMove(IKLookAtHeadTargetTrs, PlayerHeadTargetTrs);
        DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1);
        DOTweenToLAIKSHead(LAIKHeadS, LAIKSHeadDefWeight, 1);

        SEPlay(UISEObj, "ui_notification_02");

        yield return new WaitForSeconds(3);

        //「もう逃げられないね」
        Hukidashi("C1300");

        yield return new WaitForSeconds(4);

        //「私の勝ち」
        Hukidashi("C1310");


        //■■ここから一時的措置な処理（ゲームオーバー後の処理決まったら作る）
        //暗幕
        FadeBlack(1, 2);
        yield return new WaitForSeconds(2f);

        //暗幕中設定
        #region かくれおに
        //isHwVisLock = false;//宿題ロック解除
        //かくれんぼで消す小物群
        GirlTrs.gameObject.SetActive(true);
        GrasstableTrs.gameObject.SetActive(true);
        DrillTrs.gameObject.SetActive(true);
        Drill_chieriTrs.gameObject.SetActive(true);
        SharpenObj.SetActive(true);
        KeshigomuObj.SetActive(true);
        HomeworkObjectsTrs.gameObject.SetActive(true);
        //かくれんぼで智恵理ゼロ位置解除とアニメスピード変わる
        DB.isChieriPosLock = true;
        girlAnim.speed = 1;
        #endregion
        //かくれおに 智恵理行動システム コルーチン始動



        //開幕
        FadeBlack(0, 2);
        yield return new WaitForSeconds(3f);

        KO_ChieriGameOverColBool = false;
    }
    #endregion //かくれおに システム 変数と入れ子コルーチン群
    #region ■脚のぼりシステム
    #region ■■変数
    [HeaderAttribute("・脚登り")]
    public GameObject //開始時にリソースから読み、終了時に消す用
        EV_C_AsiNobori;
    bool //全終了用Bool
        isANSystem;
    bool //初期化と終了処理を検知bool
        isANSystemLoadComplete = false,
        isANSystemRemoveComplete = true;

    bool //飛び掛り演出用の特殊起動用
        isAN_Tobikakari = false;

    Vector3 //プレイヤー脚のぼり開始前サイズ
        ANstartPrevPlayerSize = new Vector3();
    float //前フレームサイズ
        AN_tmpPrevPlayerScalex;

    //カメラ操作・WASD操作切り替え用
    bool
        AN_isWASDControll = false,
        AN_isWASDControllChangeOnce = false;

    Transform //■プレイヤー肩から手先 範囲コリダー
        AN_PlayerRHandAreaTriggerSphereTrs,
        AN_PlayerLHandAreaTriggerSphereTrs;
    SphereCollider
        AN_PlayerRHandAreaTriggerSphereCollider,
        AN_PlayerLHandAreaTriggerSphereCollider;

    GameObject //掴むObj無い場合の手の位置決めるように、プレイヤー視線奥からRayを出すObj（HandAreaのコリダーにRayを飛ばし、ぶつかった場所に手を置く）
        AN_TargetNullRayRefObj;

    [HideInInspector]
    public Transform //プレイヤー 手
        AN_Hand_R_RootTrs,
        AN_Hand_L_RootTrs;
    Transform
        AN_Kubinekko_RootTrs,//摘み上げられた時など用
        AN_IKRHandPivotTrs,
        AN_IKLHandPivotTrs,
        AN_IKKubinekkoPivotTrs,
        AN_RGrapSignTrs,
        AN_LGrapSignTrs,
        AN_KubinekkoGrapSignTrs,
        //UI非表示用に取得しているが、そもそもPreMoveCube自体が要らなくなったので最終的に消すかも
        PreMoveCubeRTrs,
        PreMoveCubeLTrs,
        PreMoveCubeKubinekkoTrs;

    public enum AN_GrapSignEnum //手の状況
    { 掴めない, 掴める, 掴んでいる }
    public AN_GrapSignEnum
        AN_LGrapSignEnum,
        AN_RGrapSignEnum;

    Material //握れるか 握っているかのサイン用Mat
        GrapSignEnterMat,
        GrapSignOkMat,
        GrapSignNoMat;
    Renderer //サイン用mat変更用レンダラー
        RGrapSignRenderer,
        LGrapSignRenderer;

    Tweener //フラッシュ演出はマテリアルカラーを直接変更。フラッシュ以外はマテリアルを外す。 これで赤で固定されることはなし
        rHandRedFlashTweener,
        lHandRedFlashTweener;

    //■■独自に空気抵抗と重力を与えるので、RigidbodyのDragを0にし、UseGravityを外すことを忘れずに
    Rigidbody AN_PlayerRigidbody;
    SphereCollider AN_PlayerHuseSphereCollider;
    CapsuleCollider AN_PlayerNormalCapsuleCollider;
    public float AN_Drag = 1;   // 空気抵抗係数
    public Vector3 AN_Gravity = new Vector3(0, -9.81f, 0);    // 加速度
    bool AN_GravitiDragBool; //FixedUpdateで処理する用Bool

    //■オリジナル重力と空気抵抗の調整値
    public float dragAdjust = 2.5f;
    public float gravityAdjust = 5;

    ConfigurableJoint //手ぶらさがり用ジョイント
        AN_playerRHandJoint,
        AN_playerLHandJoint,
        AN_playerKubinekkoJoint,
        AN_handJoint,
        AN_handKatateJoint,
        AN_handRyouteJoint;

    Ray //肩Ray
        AN_PlayerRHandAreaSphereFowerdRay,
        AN_PlayerLHandAreaSphereFowerdRay;
    RaycastHit
        AN_RHandAreaRayHit,
        AN_LHandAreaRayHit;

    Vector3 //掴んだ時のノーマル（コリジョンの面を正面とした方向）を取得しておく用
        AN_RhandGrapNormalV3,
        AN_LhandGrapNormalV3,
        AN_KubinekkoGrapNormalV3;

    [HideInInspector]
    public bool //掴んでるかどうかのBool
        AN_isRGrap,
        AN_isRGrapDown,
        AN_isLGrap,
        AN_isLGrapDown,
        AN_isRLGrap,
        AN_isRLGrapDown,
        AN_isKubinekkoGrap,
        AN_isKubinekkoGrapDown;

    bool        //ジャンプ用（今の所未使用）
        AN_GrapJumpBool;
    public float
        AN_GrapPowFloat = 2,
        AN_GrapJumpCountFloat = 99;

    //■ジョイントの値調節用tmpLimitとTweener
    public SoftJointLimit //代入用
        AN_tmpRLimit,
        AN_tmpLLimit,
        AN_tmpKubinekkoLimit;
    Tweener //現在のLimitTween
        AN_RLimitTweener,
        AN_LLimitTweener;
    float //調整用（首根っこの長さ変えるなど）
        AN_AdjustKubinekkoLimit = 0;


    public bool //オプションBool群
        AN_isInputLock,
        AN_isGrapPowerMode = true,
        AN_isClimbMode = true,
        AN_isInputHoldMode,
        AN_isInputToggleMode,
        AN_isInputSwitchEasyMode,
        AN_isInputSwitchNormalMode,
        AN_isInputSwitchHardMode,
        AN_isInputMixMode,
        AN_isPlayerParentMode,
        AN_isPlayerParentCameraAngleMode,
        AN_isUIVis = false,
        AN_isAutoPullLeaveMode = true;

    float //操作ステータス群
        AN_GrapPowMax = 10,//パワー最大値
        AN_GrapPowAdd = 4,//パワー加算量
        AN_GrapPowSub = 1.5f,//パワー減産量
        AN_GrapPowMin = 2,//パワー最小値
        AN_GrapPowBorder = 5,//パワーの境目（これを超えると登ったりジャンプできたり）
        AN_GrapJumpVelocity = 3000, //ジャンプ力
        AN_GrapLimitlength,//■初期化で指定　ぶら下がる腕の長さ （ジョイントのリミット）（1倍サイズ時の値）
        AN_GrapHoldOutLimitlength, //■初期化で指定　踏ん張り登り長さ （ジョイントのリミット）（1倍サイズ時の値）(カメラアンカーのy値が代入される)
        AN_GrapHoldOutSpeed; //■初期化で指定 踏ん張りのスピード

    float
        AN_nowGrapLimitlength; //GrapLimitLengthの計算結果（プレイヤーの大きさをかける）

    //■イベント用に現在サーチしてるオブジェと掴みNGオブジェリスト
    public GameObject
        AN_nowLSerchObj = null,
        AN_nowRSerchObj = null,
        AN_nowLSerchCollObj = null,
        AN_nowRSerchCollObj = null;
    public List<GameObject>
        AN_GrapNGObjList = new List<GameObject>();

    GameObject //UIのObj UIカメラに設置
        ANGrapHandUIObj;


    //目付近からRayテスト
    public GameObject
        AN_RHandRayShooterObj,
        AN_LHandRayShooterObj;

    GameObject //矢印Obj
        AN_ArrowObj;
    GameObject
        AN_HandControlObj;
    Vector3 //回転代入用Vector3(WASDでも視点操作でも、この値をAN_HandControlObjに送るようにできてる)
        AN_HandControlLocalEul = new Vector3();

    #region SkinGrap用

    bool
        isAN_RSkinGrap = false,
        isAN_LSkinGrap = false;

    bool //一時的スキンメッシュ掴み用
        isAN_TobikakariSkinGrap = false;

    GameObject
        RHandSkinGrapPoints,
        RHandSkinGrapOutPoint,
        RHandSkinGrapHitPoint,
        RHandSkinGrapInPoint;
    GameObject
        LHandSkinGrapPoints,
        LHandSkinGrapOutPoint,
        LHandSkinGrapHitPoint,
        LHandSkinGrapInPoint;

    Collider
        RGrapSkinCollider = new Collider(),
        LGrapSkinCollider = new Collider();
    #endregion

    #endregion//□変数

    //重力部分の初期化を分離（単体起動可能）（終了処理はAsinoboriSystemロードアンロードか、手動でrigidbodyを消してFixed処理のboolをfalse）
    void AN_SetPlayerRigidbody()
    {
        //■プレイヤーがrigidbodyを持っていなければAddして値渡し　持っていたらそれに値渡し
        if (CameraObjectsTrs.GetComponent<Rigidbody>() != null)
        { AN_PlayerRigidbody = CameraObjectsTrs.gameObject.GetComponent<Rigidbody>(); }
        else
        { AN_PlayerRigidbody = CameraObjectsTrs.gameObject.AddComponent<Rigidbody>(); }

        //値読み込み
        GameObject PlayerRigidbodyColliderObj
            = Resources.Load("EventSystem/Asinobori/Prefab/PlayerRigidbodyColliderObj") as GameObject;
        Rigidbody tmpPlayerRigidBody
            = PlayerRigidbodyColliderObj.GetComponent<Rigidbody>();
        //値渡し（もっと一発でやる方法はないものか）
        AN_PlayerRigidbody.mass = tmpPlayerRigidBody.mass;
        AN_PlayerRigidbody.drag = tmpPlayerRigidBody.drag;
        AN_PlayerRigidbody.angularDrag = tmpPlayerRigidBody.angularDrag;
        AN_PlayerRigidbody.useGravity = tmpPlayerRigidBody.useGravity;
        AN_PlayerRigidbody.isKinematic = tmpPlayerRigidBody.isKinematic;
        AN_PlayerRigidbody.interpolation = tmpPlayerRigidBody.interpolation;
        AN_PlayerRigidbody.collisionDetectionMode = tmpPlayerRigidBody.collisionDetectionMode;
        AN_PlayerRigidbody.constraints = tmpPlayerRigidBody.constraints;

        #region ■■伏せかそのままかでコリダー切り替え
        //■プレイヤーがSphereColliderを持っていなければAddして値渡し　持っていたらそれに値渡し
        if (CameraObjectsTrs.GetComponent<SphereCollider>() != null)
        { AN_PlayerHuseSphereCollider = CameraObjectsTrs.gameObject.GetComponent<SphereCollider>(); }
        else
        { AN_PlayerHuseSphereCollider = CameraObjectsTrs.gameObject.AddComponent<SphereCollider>(); }

        //■プレイヤーがCapsuleColliderを持っていなければAddして値渡し　持っていたらそれに値渡し
        if (CameraObjectsTrs.GetComponent<CapsuleCollider>() != null)
        { AN_PlayerNormalCapsuleCollider = CameraObjectsTrs.gameObject.GetComponent<CapsuleCollider>(); }
        else
        { AN_PlayerNormalCapsuleCollider = CameraObjectsTrs.gameObject.AddComponent<CapsuleCollider>(); }


        //一旦どちらもOFF
        AN_PlayerHuseSphereCollider.enabled = false;
        AN_PlayerNormalCapsuleCollider.enabled = false;

        //HuseSphere値読み込み
        SphereCollider tmpPlayerSphereCollider
            = PlayerRigidbodyColliderObj.GetComponent<SphereCollider>();

        //値渡し（もっと一発でやる方法はないものか）
        AN_PlayerHuseSphereCollider.isTrigger = tmpPlayerSphereCollider.isTrigger;
        AN_PlayerHuseSphereCollider.material = tmpPlayerSphereCollider.material;
        AN_PlayerHuseSphereCollider.center = tmpPlayerSphereCollider.center;
        AN_PlayerHuseSphereCollider.radius = tmpPlayerSphereCollider.radius;

        //NormalCapsule値読み込み
        CapsuleCollider tmpPlayerCapsuleCollider
            = PlayerRigidbodyColliderObj.GetComponent<CapsuleCollider>();

        //値渡し（もっと一発でやる方法はないものか）
        AN_PlayerNormalCapsuleCollider.isTrigger = tmpPlayerCapsuleCollider.isTrigger;
        AN_PlayerNormalCapsuleCollider.material = tmpPlayerCapsuleCollider.material;
        AN_PlayerNormalCapsuleCollider.center = tmpPlayerCapsuleCollider.center;
        AN_PlayerNormalCapsuleCollider.radius = tmpPlayerCapsuleCollider.radius;
        AN_PlayerNormalCapsuleCollider.height = tmpPlayerCapsuleCollider.height;
        AN_PlayerNormalCapsuleCollider.direction = tmpPlayerCapsuleCollider.direction;

        #endregion
        //■伏せか立ちかenableで切り替える。
        //AN_PlayerHuseSphereCollider.enabled = true;
        AN_PlayerNormalCapsuleCollider.enabled = true;


        //重力と空気抵抗を独自に与える（処理はFixedUpdateにある）
        AN_GravitiDragBool = true;

    }

    //一定時間AddForceシステム（風など）(ドア吸い込まれで実装したが別方法で行ったので未使用)
    IEnumerator AddForceTimed(Rigidbody rb, Vector3 force, float time)
    {
        float timeCounter = 0;
        while (time > timeCounter)
        {
            rb.AddForce(force);
            timeCounter += 1 * Time.deltaTime;
            yield return null;
        }
        yield break;
    }

    //■コルーチン
    IEnumerator AsinoboriSystem(float handVisTime = 2)
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isANSystem) { Debug.Log("脚のぼりロードキャンセル"); yield break; }
        isANSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region WASDで操作用
        //前は、VRカメラに直接肩エリアくっつけて、そこからRayを出して操作（ヘッドトラッキング操作）
        //WASD操作は、肩エリアとRayの方向決めをCameraObjects直下にAN_HandControlObjを置いて、それを回転操作する（カメラと操作を分離）
        //※書き換えたのは三つ　肩エリアのペアレントと、Ray方向（AN_TargetNullRayRefObj）のペアレントをこのObj(AN_HandControlObj)に

        AN_HandControlObj = new GameObject();

        exitDestroyObjList.Add(AN_HandControlObj);

        AN_HandControlObj.name = "AN_HandControlObj";
        AN_HandControlObj.transform.SetParent(CameraObjectsTrs, false);
        //CameraAnchorと同じPosRot
        AN_HandControlObj.transform.localPosition = CameraAnchorTrs.localPosition;
        AN_HandControlObj.transform.localEulerAngles = CameraAnchorTrs.localEulerAngles;


        float
            dainyuuSpeed = 100;

        #endregion

        #region 初期化
        //■脚のぼりPrefabなければ生成
        if (GameObject.Find("EV_C_Asinobori") == null)
        {
            EV_C_AsiNobori = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/EV_C_Asinobori") as GameObject);
            EV_C_AsiNobori.transform.SetParent(EventObjectsTrs, false);
        }
        //編集用にすでに配置してある場合
        else { EV_C_AsiNobori = GameObject.Find("EV_C_Asinobori"); }

        //プレイヤーRigidbodyとCollider値渡しし、
        //重力と空気抵抗を独自に与える（重力処理はFixedUpdateにある）
        AN_SetPlayerRigidbody();


        //■プレイヤー肩から手の範囲コリダー(これのペアレント先をAN_HandControlObjにすることでWASDコントロール化(元はVRCameraTrs))
        GameObject tmpRObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/AN_PlayerRHandAreaTriggerSphere") as GameObject
            , VRCameraTrs
            , false);
        AN_PlayerRHandAreaTriggerSphereTrs = tmpRObj.transform;
        GameObject tmpLObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/AN_PlayerLHandAreaTriggerSphere") as GameObject,
            VRCameraTrs
            , false);
        AN_PlayerLHandAreaTriggerSphereTrs = tmpLObj.transform;

        AN_PlayerRHandAreaTriggerSphereCollider
            = AN_PlayerRHandAreaTriggerSphereTrs.GetComponent<SphereCollider>();
        AN_PlayerLHandAreaTriggerSphereCollider
            = AN_PlayerLHandAreaTriggerSphereTrs.GetComponent<SphereCollider>();

        //■掴むObj無い場合の手の位置決めるように、プレイヤー視線奥からRayを出すObj（このObjからHandRayShooterにコリダーRayを飛ばし、ぶつかった場所に手を置く）(これのペアレント先をAN_HandControlObjにすることでWASDコントロール化(元はVRCameraTrs))
        GameObject tmpRayObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/AN_TargetNullRayRefObj") as GameObject
            , VRCameraTrs
            , false);
        AN_TargetNullRayRefObj = tmpRayObj;


        //■Ray発射Obj
        AN_RHandRayShooterObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/AN_RHandRayShooterObj") as GameObject
            , VRCameraTrs
            , false);
        exitDestroyObjList.Add(AN_RHandRayShooterObj);

        AN_LHandRayShooterObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/AN_LHandRayShooterObj") as GameObject
            , VRCameraTrs
            , false);
        exitDestroyObjList.Add(AN_LHandRayShooterObj);



        #region//ジョイント
        //プレイヤーのジョイント本体(自動でRigidbodyも追加されてしまうので注意)
        AN_playerRHandJoint = CameraObjectsTrs.gameObject.AddComponent<ConfigurableJoint>();
        AN_playerLHandJoint = CameraObjectsTrs.gameObject.AddComponent<ConfigurableJoint>();
        AN_playerKubinekkoJoint = CameraObjectsTrs.gameObject.AddComponent<ConfigurableJoint>();
        //パラメーター代入用ジョイント
        AN_handJoint
            = EV_C_AsiNobori.transform.Find("JointObjs").Find("HandJoint").GetComponent<ConfigurableJoint>();
        AN_handKatateJoint
            = EV_C_AsiNobori.transform.Find("JointObjs").Find("HandKatateJoint").GetComponent<ConfigurableJoint>();
        AN_handRyouteJoint
            = EV_C_AsiNobori.transform.Find("JointObjs").Find("HandRyouteJoint").GetComponent<ConfigurableJoint>();


        //■右手 初期値代入
        AN_playerRHandJoint.connectedBody = PlayerIKRHandTargetTrs.GetComponent<Rigidbody>();

        AN_playerRHandJoint.anchor = AN_handJoint.anchor;
        AN_playerRHandJoint.axis = AN_handJoint.axis;
        AN_playerRHandJoint.secondaryAxis = AN_handJoint.secondaryAxis;
        AN_playerRHandJoint.enableCollision = AN_handJoint.enableCollision;
        AN_playerRHandJoint.enablePreprocessing = AN_handJoint.enablePreprocessing;
        AN_playerRHandJoint.autoConfigureConnectedAnchor = AN_handJoint.autoConfigureConnectedAnchor;
        AN_playerRHandJoint.connectedAnchor = AN_handJoint.connectedAnchor;

        AN_playerRHandJoint.angularXMotion = AN_handJoint.angularXMotion;
        AN_playerRHandJoint.angularYMotion = AN_handJoint.angularYMotion;
        AN_playerRHandJoint.angularZMotion = AN_handJoint.angularZMotion;

        //頻繁に変える値
        AN_playerRHandJoint.linearLimit = AN_handJoint.linearLimit;
        AN_playerRHandJoint.xMotion = AN_handJoint.xMotion;
        AN_playerRHandJoint.yMotion = AN_handJoint.yMotion;
        AN_playerRHandJoint.zMotion = AN_handJoint.zMotion;
        AN_playerRHandJoint.xDrive = AN_handJoint.xDrive;
        AN_playerRHandJoint.yDrive = AN_handJoint.yDrive;
        AN_playerRHandJoint.zDrive = AN_handJoint.zDrive;

        //■左手 初期値代入
        AN_playerLHandJoint.connectedBody = PlayerIKLHandTargetTrs.GetComponent<Rigidbody>();

        AN_playerLHandJoint.anchor = AN_handJoint.anchor;
        AN_playerLHandJoint.axis = AN_handJoint.axis;
        AN_playerLHandJoint.secondaryAxis = AN_handJoint.secondaryAxis;
        AN_playerLHandJoint.enableCollision = AN_handJoint.enableCollision;
        AN_playerLHandJoint.enablePreprocessing = AN_handJoint.enablePreprocessing;
        AN_playerLHandJoint.autoConfigureConnectedAnchor = AN_handJoint.autoConfigureConnectedAnchor;
        AN_playerLHandJoint.connectedAnchor = AN_handJoint.connectedAnchor;

        AN_playerLHandJoint.angularXMotion = AN_handJoint.angularXMotion;
        AN_playerLHandJoint.angularYMotion = AN_handJoint.angularYMotion;
        AN_playerLHandJoint.angularZMotion = AN_handJoint.angularZMotion;

        //頻繁に変える値
        AN_playerLHandJoint.linearLimit = AN_handJoint.linearLimit;
        AN_playerLHandJoint.xMotion = AN_handJoint.xMotion;
        AN_playerLHandJoint.yMotion = AN_handJoint.yMotion;
        AN_playerLHandJoint.zMotion = AN_handJoint.zMotion;
        AN_playerLHandJoint.xDrive = AN_handJoint.xDrive;
        AN_playerLHandJoint.yDrive = AN_handJoint.yDrive;
        AN_playerLHandJoint.zDrive = AN_handJoint.zDrive;


        //■首根っこ 初期値代入

        AN_playerKubinekkoJoint.anchor = AN_handJoint.anchor;
        AN_playerKubinekkoJoint.axis = AN_handJoint.axis;
        AN_playerKubinekkoJoint.secondaryAxis = AN_handJoint.secondaryAxis;
        AN_playerKubinekkoJoint.enableCollision = AN_handJoint.enableCollision;
        AN_playerKubinekkoJoint.enablePreprocessing = AN_handJoint.enablePreprocessing;
        AN_playerKubinekkoJoint.autoConfigureConnectedAnchor = AN_handJoint.autoConfigureConnectedAnchor;
        AN_playerKubinekkoJoint.connectedAnchor = AN_handJoint.connectedAnchor;

        AN_playerKubinekkoJoint.angularXMotion = AN_handJoint.angularXMotion;
        AN_playerKubinekkoJoint.angularYMotion = AN_handJoint.angularYMotion;
        AN_playerKubinekkoJoint.angularZMotion = AN_handJoint.angularZMotion;

        //頻繁に変える値
        AN_playerKubinekkoJoint.linearLimit = AN_handJoint.linearLimit;
        AN_playerKubinekkoJoint.xMotion = AN_handJoint.xMotion;
        AN_playerKubinekkoJoint.yMotion = AN_handJoint.yMotion;
        AN_playerKubinekkoJoint.zMotion = AN_handJoint.zMotion;
        AN_playerKubinekkoJoint.xDrive = AN_handJoint.xDrive;
        AN_playerKubinekkoJoint.yDrive = AN_handJoint.yDrive;
        AN_playerKubinekkoJoint.zDrive = AN_handJoint.zDrive;


        #endregion//ジョイント
        //ジョイントのリミット調節用Tweener  //Durationは0より大きい数字じゃないと後から変更効かない
        AN_tmpRLimit =
        AN_tmpLLimit = AN_handKatateJoint.linearLimit;
        //AN_tmpKubinekkoLimit =

        AN_RLimitTweener = DOTween.To(() => AN_tmpRLimit.limit, (x) => AN_tmpRLimit.limit = x
            , 4
            , 0.01f)
            .SetAutoKill(false);
        AN_LLimitTweener = DOTween.To(() => AN_tmpLLimit.limit, (x) => AN_tmpLLimit.limit = x
            , 4
            , 0.01f)
            .SetAutoKill(false);


        //■プレイヤー 手 取得
        GameObject Hand_R_RootObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/Hand_R_Root") as GameObject
            , GameObjectsTrs
            , false);
        GameObject Hand_L_RootObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/Hand_L_Root") as GameObject
            , GameObjectsTrs
            , false);
        //■首根っこは首根っこに設置
        GameObject Kubinekko_RootObj
            = Instantiate(Resources.Load("EventSystem/Asinobori/Prefab/Kubinekko_Root") as GameObject
            , PlayerKubiNekkoPosObjTrs
            , false);
        AN_Kubinekko_RootTrs = Kubinekko_RootObj.transform;
        AN_playerKubinekkoJoint.connectedBody = AN_Kubinekko_RootTrs.GetComponent<Rigidbody>();


        //■UI非表示用に取得//首根っこ
        AN_IKKubinekkoPivotTrs = AN_Kubinekko_RootTrs.Find("IKKubinekkoPivot").transform;
        AN_KubinekkoGrapSignTrs = AN_IKKubinekkoPivotTrs.Find("GrapSignSphere").transform;
        PreMoveCubeKubinekkoTrs = AN_Kubinekko_RootTrs.transform.Find("PreMoveCube").transform;
        PreMoveCubeKubinekkoTrs.gameObject.SetActive(false);

        //手
        AN_Hand_R_RootTrs = Hand_R_RootObj.transform;
        AN_Hand_L_RootTrs = Hand_L_RootObj.transform;
        AN_IKRHandPivotTrs = AN_Hand_R_RootTrs.Find("IKRHandPivot").transform;
        AN_IKLHandPivotTrs = AN_Hand_L_RootTrs.Find("IKLHandPivot").transform;

        AN_RGrapSignTrs = AN_IKRHandPivotTrs.Find("GrapSignSphere").transform;
        AN_LGrapSignTrs = AN_IKLHandPivotTrs.Find("GrapSignSphere").transform;

        RGrapSignRenderer = AN_RGrapSignTrs.GetComponent<Renderer>();
        LGrapSignRenderer = AN_LGrapSignTrs.GetComponent<Renderer>();



        //表示オフ用
        PreMoveCubeRTrs = AN_Hand_R_RootTrs.transform.Find("PreMoveCube").transform;
        PreMoveCubeLTrs = AN_Hand_L_RootTrs.transform.Find("PreMoveCube").transform;
        PreMoveCubeLTrs.gameObject.SetActive(false);
        PreMoveCubeRTrs.gameObject.SetActive(false);


        //■Material　握れるか 握っているかサイン用Mat
        GrapSignEnterMat = Instantiate(Resources.Load("EventSystem/Asinobori/Mat/grapSignEnter") as Material);
        GrapSignOkMat = Instantiate(Resources.Load("EventSystem/Asinobori/Mat/grapSignOk") as Material);
        GrapSignNoMat = Instantiate(Resources.Load("EventSystem/Asinobori/Mat/grapSignNo") as Material);


        //■ダミーボディの表示非表示
        //FPS時は体表示消して手表示
        if (tPSModeInt == 0)
        {
            Dummy_Body.SetActive(false);
            isDummyHandVis = true;
            Dummy_Hand.SetActive(true);
        }
        //TPS時は手だけ消す
        else
        {
            isDummyHandVis = true;
            Dummy_Hand.SetActive(false);
        }

        //UI表示ONOFF用２次Bool
        bool tmpUIVis = true;

        #region ■新UIデータ初期化
        //UIのObj UIカメラに設置
        ANGrapHandUIObj
        = Instantiate(Resources.Load("EventSystem/Asinobori/UI/ANGrapHandUI") as GameObject
        , VRUICameraTrs
        , false);

        Image
            HandRIconImage
            = ANGrapHandUIObj.transform.Find("Canvas").Find("HandRIcon").GetComponent<Image>(),
            HandLIconImage
            = ANGrapHandUIObj.transform.Find("Canvas").Find("HandLIcon").GetComponent<Image>();

        Material //右手も左手も同じマテリアルだが、個別に変化するので2個取得　//Redは掴めなかった時使用
            rHandAlphaMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIAlphaMat")),
            lHandAlphaMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIAlphaMat")),
            alphaRedMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIAlphaRedMat")),
            rHandWhiteMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIWhiteMat")),
            lHandWhiteMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIWhiteMat")),
            rHandBlueMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIBlueMat")),
            lHandBlueMat = Instantiate(Resources.Load<Material>("EventSystem/Asinobori/UI/HandUIBlueMat"));

        Color //Colorはただの数値なので1つずつ取得
            alphaColor = rHandAlphaMat.color,
            alphaRedColor = alphaRedMat.color;

        //フラッシュ演出はマテリアルカラーを直接変更。フラッシュ以外はマテリアルを外す。 これで赤で固定されることはなし
        rHandRedFlashTweener = rHandAlphaMat.DOColor(alphaRedColor, 0.05f).SetLoops(6, LoopType.Yoyo)
            .Pause().SetAutoKill(false);
        lHandRedFlashTweener = lHandAlphaMat.DOColor(alphaRedColor, 0.05f).SetLoops(6, LoopType.Yoyo)
            .Pause().SetAutoKill(false);

        bool //それぞれ書き込み続けないようにboolで判定
            isRGrapUI = false,
            isRLeaveUI = false,
            isRNoneUI = false,
            isLGrapUI = false,
            isLLeaveUI = false,
            isLNoneUI = false;


        //矢印Obj
        AN_ArrowObj = ANGrapHandUIObj.transform.Find("Canvas").Find("ArrowObj").gameObject;
        //色変更用
        Renderer
            arrowRenderer = AN_ArrowObj.transform.Find("Top").GetComponent<Renderer>();
        Material
            arrowFowardMat = Resources.Load<Material>("EventSystem/Asinobori/UI/ArrowTopFowardMat"),
            arrowWASDMat = Resources.Load<Material>("EventSystem/Asinobori/UI/ArrowTopWASDMat");
        #endregion

        //■■コリダー半径 + Jointアンカー位置からコリダーまでの距離　をリミット最長値デフォルトに
        //（アンカーは0に戻したが、この方式でうまくいくので「手動で1.2f指定」していたのをやめてこれを使う）
        AN_GrapLimitlength = AN_PlayerRHandAreaTriggerSphereCollider.radius
            + Vector3.Distance(
                AN_playerRHandJoint.anchor,
                AN_PlayerRHandAreaTriggerSphereCollider.gameObject.transform.localPosition
                + CameraAnchorTrs.localPosition //コリダーまでの距離に"カメラの"アンカーのPosも含む
                );

        //踏ん張り長さ　を、カメラアンカーの高さの距離に
        AN_GrapHoldOutLimitlength = CameraAnchorTrs.localPosition.y;

        //踏ん張りスピードをハードなら0.5　それ以外1
        if (AN_isInputSwitchHardMode)
        { AN_GrapHoldOutSpeed = 0.5f; }
        else { AN_GrapHoldOutSpeed = 1; }

        //ノーマル操作で初期化（WASD操作モードじゃないということ）
        AN_isWASDControll = false;
        AN_PlayerRHandAreaTriggerSphereTrs.SetParent(VRCameraTrs, false);
        AN_PlayerLHandAreaTriggerSphereTrs.SetParent(VRCameraTrs, false);
        AN_TargetNullRayRefObj.transform.SetParent(VRCameraTrs, false);

        //とびかかりならWASD操作状態（手固定のため）
        if (isAN_Tobikakari)
        {
            AN_isWASDControll = true;
            AN_PlayerRHandAreaTriggerSphereTrs.SetParent(AN_HandControlObj.transform, false);
            AN_PlayerLHandAreaTriggerSphereTrs.SetParent(AN_HandControlObj.transform, false);
            AN_TargetNullRayRefObj.transform.SetParent(AN_HandControlObj.transform, false);
            AN_RHandRayShooterObj.transform.SetParent(AN_HandControlObj.transform, false);
            AN_LHandRayShooterObj.transform.SetParent(AN_HandControlObj.transform, false);
        }

        int //tPSModeIntの変更を取得して、そのタイミングで変更処理する用
            prevTPSModeInt = tPSModeInt;

        #endregion □初期化



        #region AN時プレイヤーダミー回転オフ時は、手IKもつけない（つまみ上げられ時など）
        if (isPlayerANRotate)
        {
            //IKターゲットをペアレント化
            PlayerIKRHandTargetTrs.SetParent(AN_IKRHandPivotTrs, false);
            PlayerIKLHandTargetTrs.SetParent(AN_IKLHandPivotTrs, false);
            #region 手出現の演出
            //プレイヤーIK手設定
            PlayerIKRHandEf.positionWeight =
            PlayerIKLHandEf.positionWeight =
            PlayerIKRHandEf.rotationWeight =
            PlayerIKLHandEf.rotationWeight = 0;
            yield return null;
            //プレイヤーIK手設定
            DOTweenToIKEfPos(PlayerIKRHandEf, 1, handVisTime);
            DOTweenToIKEfRot(PlayerIKRHandEf, 1, handVisTime);
            DOTweenToIKEfPos(PlayerIKLHandEf, 1, handVisTime);
            DOTweenToIKEfRot(PlayerIKLHandEf, 1, handVisTime);
            #endregion
        }
        #endregion


        //初期化・終了処理検知のbool
        isANSystemLoadComplete = true;
        isANSystemRemoveComplete = false;
        Debug.Log("脚登りシステム初期化");



        #region SkinGrap用取得
        RHandSkinGrapPoints = AN_Hand_R_RootTrs.Find("SkinGrapPoints").gameObject;
        RHandSkinGrapOutPoint = RHandSkinGrapPoints.transform.Find("SkinGrapOutPoint").gameObject;
        RHandSkinGrapHitPoint = RHandSkinGrapPoints.transform.Find("SkinGrapHitPoint").gameObject;
        RHandSkinGrapInPoint = RHandSkinGrapPoints.transform.Find("SkinGrapInPoint").gameObject;

        LHandSkinGrapPoints = AN_Hand_L_RootTrs.Find("SkinGrapPoints").gameObject;
        LHandSkinGrapOutPoint = LHandSkinGrapPoints.transform.Find("SkinGrapOutPoint").gameObject;
        LHandSkinGrapHitPoint = LHandSkinGrapPoints.transform.Find("SkinGrapHitPoint").gameObject;
        LHandSkinGrapInPoint = LHandSkinGrapPoints.transform.Find("SkinGrapInPoint").gameObject;

        LayerMask //
        skinGrapLayerMask = (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));

        Ray
            skinGrapRay = new Ray();
        RaycastHit
            skinGrapRayHit = new RaycastHit();


        #endregion

        #region ループ
        while (isANSystem)
        {
            AN_LateAction(() =>
            {
                //ポーズ中は止め
                if (isGamePause == false)
                {
                    //■入力 ロックされてるかどうか。
                    if (AN_isInputLock == false)
                    {
                        //されてなかったらトグルかホールドかスイッチか
                        if (AN_isInputHoldMode)
                        { PlayerRLInput(); }
                        else if (AN_isInputToggleMode)
                        { PlayerRLInputToggle(); }
                        else if (AN_isInputSwitchEasyMode)
                        { PlayerRLInputSwitchEasy(); }
                        else if (AN_isInputSwitchNormalMode)
                        { PlayerRLInputSwitchNormal(); }
                        else if (AN_isInputSwitchHardMode)
                        { PlayerRLInputSwitchHard(); }

                        else if (AN_isInputMixMode)
                        { PlayerRLInputSwitchMix(); }

                    }
                    else //ロックされてたらDown系全部false
                    {
                        if (isRInputDown || isLInputDown)
                        { isRInputDown = isLInputDown = false; }
                    }

                    //WASD操作ON時
                    if (AN_isWASDControll)
                    {
                        #region WASDで手操作

                        //飛び掛り演出でない時（通常時）
                        if (isAN_Tobikakari == false)
                        {
                            if (Input.GetKey(KeyCode.UpArrow))//|| sentakuAxisY >= 0.1 上下Axis兼用のため今はなし
                            {
                                AN_HandControlLocalEul.x += -dainyuuSpeed * Time.unscaledDeltaTime;
                            }
                            if (Input.GetKey(KeyCode.DownArrow))// || sentakuAxisY <= -0.1
                            {
                                AN_HandControlLocalEul.x += dainyuuSpeed * Time.unscaledDeltaTime;
                            }
                            if (Input.GetKey(KeyCode.LeftArrow))//|| Input.GetAxis(DB.inputDict["選択左右"]) <= -0.1
                            {
                                AN_HandControlLocalEul.y += -dainyuuSpeed * Time.unscaledDeltaTime;
                            }
                            if (Input.GetKey(KeyCode.RightArrow))//|| Input.GetAxis(DB.inputDict["選択左右"]) >= 0.1
                            {
                                AN_HandControlLocalEul.y += dainyuuSpeed * Time.unscaledDeltaTime;
                            }

                            //コントローラーに代入
                            AN_HandControlObj.transform.localEulerAngles = AN_HandControlLocalEul;
                        }

                        #endregion


                        if (isAN_Tobikakari == false)//飛び掛り演出でなければ
                        {
                            //Tキーでカメラ操作に戻る //TPSモードオフでも戻る
                            if (Input.GetKeyDown(KeyCode.T) || DB.isUserTPSMode == false)
                            { AN_isWASDControll = false; }
                        }
                    }
                    else
                    {
                        #region TPSモード時、WASD押すとWASD操作に切り替わる(上下AXIS兼用のため、今はキーボードのみに)
                        if (DB.isUserTPSMode)
                        {
                            if (
                            Input.GetKeyDown(KeyCode.UpArrow) ||// sentakuAxisY >= 0.1 ||
                                Input.GetKeyDown(KeyCode.DownArrow) ||// sentakuAxisY <= -0.1 ||
                                Input.GetKeyDown(KeyCode.LeftArrow) ||// Input.GetAxis(DB.inputDict["選択左右"]) <= -0.1 ||
                                Input.GetKeyDown(KeyCode.RightArrow) //|| Input.GetAxis(DB.inputDict["選択左右"]) >= 0.1
                            )
                            { AN_isWASDControll = true; }
                        }
                        #endregion

                    }

                    #region FPS TPS切り替え時、カメラ操作と手操作を切り替え
                    //カメラ切り替えボタンでカメラ操作に切り替え
                    if (Input.GetButtonDown(DB.inputDict["カメラ切り替え"]))
                    { if (AN_isWASDControll && isAN_Tobikakari == false) { AN_isWASDControll = false; } }

                    //手操作切り替え
                    if (AN_isWASDControll
                        && AN_isWASDControllChangeOnce == false)
                    {
                        AN_isWASDControllChangeOnce = true;
                        AN_PlayerRHandAreaTriggerSphereTrs.SetParent(AN_HandControlObj.transform, false);
                        AN_PlayerLHandAreaTriggerSphereTrs.SetParent(AN_HandControlObj.transform, false);
                        AN_TargetNullRayRefObj.transform.SetParent(AN_HandControlObj.transform, false);
                        AN_RHandRayShooterObj.transform.SetParent(AN_HandControlObj.transform, false);
                        AN_LHandRayShooterObj.transform.SetParent(AN_HandControlObj.transform, false);

                        if (isAN_Tobikakari == false)//飛び掛り演出でなければ 手コントロール位置初期化
                        {
                            AN_HandControlLocalEul.x = VRCameraTrs.localEulerAngles.x + CameraAnchorTrs.localEulerAngles.x;
                            AN_HandControlLocalEul.y = VRCameraTrs.localEulerAngles.y + CameraAnchorTrs.localEulerAngles.y;
                        }

                    }
                    else if (AN_isWASDControll == false
                        && AN_isWASDControllChangeOnce)
                    {
                        AN_isWASDControllChangeOnce = false;
                        AN_PlayerRHandAreaTriggerSphereTrs.SetParent(VRCameraTrs, false);
                        AN_PlayerLHandAreaTriggerSphereTrs.SetParent(VRCameraTrs, false);
                        AN_TargetNullRayRefObj.transform.SetParent(VRCameraTrs, false);
                        AN_RHandRayShooterObj.transform.SetParent(VRCameraTrs, false);
                        AN_LHandRayShooterObj.transform.SetParent(VRCameraTrs, false);
                    }
                    #endregion

                    #region//デバッグ ポーズ変え
                    //if (Input.GetKeyDown(KeyCode.V))
                    //{
                    //    ChieriMotion("脚のぼり後ろ手→体育座り", 0.4f, 0);
                    //}
                    //if (Input.GetKeyDown(KeyCode.B))
                    //{
                    //    ChieriMotion("脚のぼり後ろ手→左足上げ", 0.4f, 0);
                    //}
                    //if (Input.GetKeyDown(KeyCode.N))
                    //{
                    //    Vector3 tmpScale = nowPlayerLocalScl / 1.5f;
                    //    DOTween.To(() => nowPlayerLocalScl, (x) => nowPlayerLocalScl = x, tmpScale, 3f);
                    //}
                    //if (Input.GetKeyDown(KeyCode.M))
                    //{
                    //    Vector3 tmpScale = nowPlayerLocalScl * 1.5f;
                    //    DOTween.To(() => nowPlayerLocalScl, (x) => nowPlayerLocalScl = x, tmpScale, 3f);
                    //}
                    #endregion//デバッグ

                    #region //デバッグ nowGrapLimitなどの情報表示
                    //if (Input.GetKeyDown(KeyCode.V))
                    //{
                    //    Debug.Log(AN_nowGrapLimitlength);
                    //}
                    //if (Input.GetKeyDown(KeyCode.B))
                    //{
                    //    //■■コリダー半径 + Jointアンカー位置からコリダーまでの距離　をリミット最長値デフォルトに
                    //    //（アンカーは0に戻したが、この方式でうまくいくので「手動で1.2f指定」していたのをやめてこれを使う）
                    //    AN_GrapLimitlength = AN_PlayerRHandAreaTriggerSphereCollider.radius
                    //        + Vector3.Distance(
                    //            AN_playerRHandJoint.anchor,//つまりCameraObjectsの位置
                    //            AN_PlayerRHandAreaTriggerSphereCollider.gameObject.transform.localPosition
                    //            //カメラアンカーPosを含
                    //            + CameraAnchorTrs.localPosition //コリダーまでの距離にカメラアンカーのPosも含む
                    //            );


                    //    Debug.Log(

                    //        Vector3.Distance(
                    //        AN_playerRHandJoint.anchor,
                    //        AN_PlayerRHandAreaTriggerSphereCollider.gameObject.transform.localPosition
                    //        //+ CameraAnchorTrs.localPosition
                    //        ));
                    //}
                    #endregion



                    //■リアルタイムスケール変化に対応
                    //手のリミット最長値
                    AN_nowGrapLimitlength =
                        AN_GrapLimitlength
                        * (nowPlayerLocalScale.x * GameObjectsTrs.localScale.x);

                    //■手(IK移動先のObj) 大きさリアルタイム変化
                    if (AN_Hand_R_RootTrs.localScale != nowPlayerLocalScale)
                    { AN_Hand_R_RootTrs.localScale = nowPlayerLocalScale; }
                    if (AN_Hand_L_RootTrs.localScale != nowPlayerLocalScale)
                    { AN_Hand_L_RootTrs.localScale = nowPlayerLocalScale; }
                    if (AN_Kubinekko_RootTrs.localScale != nowPlayerLocalScale)
                    { AN_Kubinekko_RootTrs.localScale = nowPlayerLocalScale; }


                    //■パワー表示 大きさ直接指定
                    Vector3 tmpSignScale = 5f * new Vector3(AN_GrapPowFloat, AN_GrapPowFloat, AN_GrapPowFloat);
                    AN_RGrapSignTrs.localScale = tmpSignScale;
                    AN_LGrapSignTrs.localScale = tmpSignScale;

                    #region 右手
                    #region Ray作成

                    ////肩Ray作成
                    //AN_PlayerRHandAreaSphereFowerdRay = new Ray
                    //    (AN_PlayerRHandAreaTriggerSphereTrs.position
                    //    , AN_PlayerRHandAreaTriggerSphereTrs.forward);
                    ////Debug.DrawRay(AN_PlayerRHandAreaSphereFowerdRay.origin, AN_PlayerRHandAreaSphereFowerdRay.direction * 100);

                    //肩からRayだったが 顔付近から発射にした
                    AN_PlayerRHandAreaSphereFowerdRay = new Ray
                        (AN_RHandRayShooterObj.transform.position
                        , AN_RHandRayShooterObj.transform.forward);

                    #endregion

                    //Ray　レイヤーマスクはseeRayBlockレイヤーとGrapSupportColliderレイヤーとSeeGirlIgnoreColliderが含まれる利用
                    if (Physics.Raycast(AN_PlayerRHandAreaSphereFowerdRay, out AN_RHandAreaRayHit, Mathf.Infinity, AN_GrapLayerMask))
                    {
                        //ボタン押してない時はサーチ状態
                        if (!isRInput)
                        { AsinoboriHandSerch(AN_Hand_R_RootTrs); }

                        //押し瞬間に
                        if (isRInputDown)
                        {
                            #region ぶっとぶバグ対応
                            //■手目標先がコリダー外の場合 （掴めない）
                            //(肩Sphereのコリダー半径に ワールドサイズ*プレイヤーサイズをかけて、ワールド座標でのコリダー距離を出している)
                            if (Vector3.Distance(AN_PlayerRHandAreaTriggerSphereTrs.position, AN_RHandAreaRayHit.point)
                                >
                                AN_PlayerRHandAreaTriggerSphereCollider.radius *
                                GameObjectsTrs.localScale.z *
                                nowPlayerLocalScale.z
                                || //Null（何にもヒットしてない)場合でも
                                AN_RHandAreaRayHit.transform == null
                                )
                            {
                                //掴めなかった時スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_R_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 2);
                                rHandRedFlashTweener.Restart();

                                //トグルモードの場合はキャンセル
                                if (AN_isInputToggleMode || AN_isInputMixMode) { isRInputUp = true; isRInput = false; }
                                goto 右手抜け;
                            }
                            #endregion

                            //■掴める かつ NGリストになければ
                            if (AN_RGrapSignEnum == AN_GrapSignEnum.掴める
                                && AN_GrapNGObjList.Contains(AN_nowRSerchObj) == false)
                            {
                                AsinoboriHandGrap(AN_Hand_R_RootTrs);
                            }
                            else
                            {
                                //掴めなかった時スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_R_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 2);
                                rHandRedFlashTweener.Restart();

                                //トグルモードの場合はキャンセル
                                if (AN_isInputToggleMode || AN_isInputMixMode) { isRInputUp = true; isRInput = false; }
                            }

                        }
                        //押してるけどつかめてない時はサーチのまま
                        else if (isRInput && !AN_isRGrap)
                        { AsinoboriHandSerch(AN_Hand_R_RootTrs); }
                    }
                    else //Rayが何にもヒットしていない場合（Null）でもサーチ状態
                    {
                        //掴んでない時サーチ状態
                        if (AN_isRGrap == false)
                        { AsinoboriHandSerch(AN_Hand_R_RootTrs); }
                    }

                    //離した瞬間
                    if (isRInputUp)
                    {
                        //SEPlay(AN_Hand_R_RootTrs.gameObject, "UI_fu");
                        AsinoboriHandLeave(AN_Hand_R_RootTrs, AN_playerRHandJoint);
                    }

                    #endregion //□右手
                    右手抜け:

                    #region 左手
                    #region Ray作成
                    ////肩Ray作成
                    //AN_PlayerLHandAreaSphereFowerdRay = new Ray
                    //    (AN_PlayerLHandAreaTriggerSphereTrs.position
                    //    , AN_PlayerLHandAreaTriggerSphereTrs.forward);

                    //肩からRayだったのを、顔付近から発射に
                    AN_PlayerLHandAreaSphereFowerdRay = new Ray
                        (AN_LHandRayShooterObj.transform.position
                        , AN_LHandRayShooterObj.transform.forward);
                    #endregion


                    //Ray　レイヤーマスクはseeRayBlockレイヤーとGrapSupportLayerレイヤーとSeeGirlIgnoreColliderが含まれる
                    if (Physics.Raycast(AN_PlayerLHandAreaSphereFowerdRay, out AN_LHandAreaRayHit, Mathf.Infinity, AN_GrapLayerMask))
                    {
                        //ボタン押してない時
                        if (!isLInput)
                        { AsinoboriHandSerch(AN_Hand_L_RootTrs); }

                        //押し瞬間
                        if (isLInputDown)
                        {
                            #region ぶっとぶバグ対応
                            //■手目標先がコリダー外の場合 （掴めない）
                            //(肩Sphereのコリダー半径に ワールドサイズ*プレイヤーサイズをかけて、ワールド座標でのコリダー距離を出している)
                            if (Vector3.Distance(AN_PlayerLHandAreaTriggerSphereTrs.position, AN_LHandAreaRayHit.point)
                                >
                                AN_PlayerLHandAreaTriggerSphereCollider.radius *
                                GameObjectsTrs.localScale.z *
                                nowPlayerLocalScale.z
                                || //Null（何にもヒットしてない)場合でも
                                AN_LHandAreaRayHit.transform == null
                                )
                            {
                                //■掴めなかった時スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_L_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 3);
                                lHandRedFlashTweener.Restart();

                                //トグルモードの場合はキャンセル
                                if (AN_isInputToggleMode || AN_isInputMixMode) { isLInputUp = true; isLInput = false; }
                                goto 左手抜け;
                            }
                            #endregion

                            //■掴める かつ NGリストになければ
                            if (AN_LGrapSignEnum == AN_GrapSignEnum.掴める
                                && AN_GrapNGObjList.Contains(AN_nowLSerchObj) == false)
                            {
                                AsinoboriHandGrap(AN_Hand_L_RootTrs);
                            }
                            else
                            {
                                //■掴めなかった時スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_L_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 3);
                                lHandRedFlashTweener.Restart();

                                //トグルモードの場合はキャンセル
                                if (AN_isInputToggleMode || AN_isInputMixMode) { isLInputUp = true; isLInput = false; }
                            }
                        }
                        //押してるけどつかめてない時
                        else if (isLInput && !AN_isLGrap)
                        { AsinoboriHandSerch(AN_Hand_L_RootTrs); }
                    }

                    else //Rayが何にもヒットしていない場合(Nullにヒット)
                    {
                        //掴んでない時サーチ状態
                        if (AN_isLGrap == false)
                        { AsinoboriHandSerch(AN_Hand_L_RootTrs); }
                    }

                    //離した瞬間
                    if (isLInputUp)
                    {
                        //SEPlay(AN_Hand_L_RootTrs.gameObject, "UI_fu");
                        AsinoboriHandLeave(AN_Hand_L_RootTrs, AN_playerLHandJoint);
                    }

                    #endregion 左手
                    左手抜け:

                    #region 掴んでいる間、手首を肩に向け、コリジョンの面から正面を頭上とする(Grap時に取得したもの)
                    if (AN_isRGrap)
                    { AN_Hand_R_RootTrs.LookAt(AN_PlayerRHandAreaTriggerSphereTrs, AN_RhandGrapNormalV3); }
                    if (AN_isLGrap)
                    { AN_Hand_L_RootTrs.LookAt(AN_PlayerLHandAreaTriggerSphereTrs, AN_LhandGrapNormalV3); }
                    #endregion

                    #region ■パワーゲージで踏ん張りTweenerストップ + リアルタイム縮小

                    //パワー（RLGrapPowerFloat）と 掴み時間（GrapCountFloat）は別物注意

                    #region Climbモード時は、ボーダー値を0で固定
                    if (AN_isClimbMode)
                    { if (AN_GrapPowBorder != 0) { AN_GrapPowBorder = 0; } }
                    else { if (AN_GrapPowBorder != 5) { AN_GrapPowBorder = 5; } }
                    #endregion

                    //■■両手で掴んだら 
                    if (AN_isRLGrap)
                    {
                        //1フレーム目は現在の距離で両手リミットを固定し
                        if (AN_isRLGrapDown)
                        {
                            //ジャンプ判定カウントリセット（今の所未使用）
                            AN_GrapJumpCountFloat = 0;
                        }

                        //■パワー溜まり
                        //パワー溜まりモードON時のみ
                        if (AN_isGrapPowerMode)
                        {
                            if (AN_GrapPowMax > AN_GrapPowFloat)
                            { AN_GrapPowFloat += AN_GrapPowAdd * Time.deltaTime; }
                        }

                        #region 肩から手までの距離が"現在の"リミットを越えたら離す
                        //自動引っ張られ離しモードOn時のみ
                        if (AN_isAutoPullLeaveMode)
                        {
                            //（本来リミットはプレイヤーから手までの距離のはずだが、どうも飛び出るので、有余も含めて肩から）

                            //右肩から右手までの距離が"現在の"リミットを越えたら
                            if (Vector3.Distance(AN_PlayerRHandAreaTriggerSphereTrs.position, AN_Hand_R_RootTrs.position) > AN_nowGrapLimitlength / 0.9f)
                            {
                                //パワーなくして手を離す
                                AN_GrapPowFloat = AN_GrapPowMin;
                                #region スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_R_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 2);
                                rHandRedFlashTweener.Restart();
                                #endregion

                                AsinoboriHandLeave
                                    (
                                    AN_Hand_R_RootTrs,
                                    AN_playerRHandJoint
                                    );
                            }
                            //左肩から左手までの距離が"現在の"リミットを越えたら
                            if (Vector3.Distance(AN_PlayerLHandAreaTriggerSphereTrs.position, AN_Hand_L_RootTrs.position) > AN_nowGrapLimitlength / 0.9f)
                            {
                                //パワーなくして手を離す
                                AN_GrapPowFloat = AN_GrapPowMin;
                                #region スカり演出 
                                SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_L_RootTrs.gameObject);
                                PlayerMotion("登りグーからパー", 0f, 3);
                                lHandRedFlashTweener.Restart();
                                #endregion

                                AsinoboriHandLeave
                                    (
                                    AN_Hand_L_RootTrs,
                                    AN_playerLHandJoint
                                    );
                            }
                        }
                        #endregion

                    }
                    else //■■両手で掴んでない場合（片手掴み と 手放し時）
                    {
                        //■パワー減り
                        //パワー溜まりモードON時のみ
                        if (AN_isGrapPowerMode)
                        {
                            if (AN_GrapPowMin < AN_GrapPowFloat)
                            { AN_GrapPowFloat -= AN_GrapPowSub * Time.deltaTime; }
                        }
                        //パワーがボーダーより下がったらぶらりん
                        if (AN_GrapPowBorder > AN_GrapPowFloat)
                        {
                            AN_RLimitTweener.Pause();
                            AN_LLimitTweener.Pause();

                            AN_tmpRLimit.limit =
                            AN_tmpLLimit.limit = AN_nowGrapLimitlength;
                        }

                    }

                    //if (AN_isKubinekkoGrap)
                    //{
                    //    //ぶらりん
                    //    AN_tmpKubinekkoLimit.limit = AN_nowGrapLimitlength + AN_AdjustKubinekkoLimit;
                    //}


                    #region パワーゲージ演出（明るさ）
                    if (AN_GrapPowBorder < AN_GrapPowFloat)
                    {
                        //明るくなかったら明るく
                        if (GrapSignEnterMat.color.a != 0.4f)
                        {
                            Color tmpColor = GrapSignEnterMat.color;
                            GrapSignEnterMat.color = new Color(tmpColor.r, tmpColor.g, tmpColor.b, 0.4f);
                            tmpColor = GrapSignOkMat.color;
                            GrapSignOkMat.color = new Color(tmpColor.r, tmpColor.g, tmpColor.b, 0.4f);
                            tmpColor = GrapSignNoMat.color;
                            GrapSignNoMat.color = new Color(tmpColor.r, tmpColor.g, tmpColor.b, 0.4f);
                        }
                    }
                    else if (AN_GrapPowBorder > AN_GrapPowFloat)
                    {
                        //暗くなかったら暗く
                        if (GrapSignEnterMat.color.a != 0.1f)
                        {
                            Color tmp = GrapSignEnterMat.color;
                            GrapSignEnterMat.color = new Color(tmp.r, tmp.g, tmp.b, 0.1f);
                            tmp = GrapSignOkMat.color;
                            GrapSignOkMat.color = new Color(tmp.r, tmp.g, tmp.b, 0.1f);
                            tmp = GrapSignNoMat.color;
                            GrapSignNoMat.color = new Color(tmp.r, tmp.g, tmp.b, 0.1f);
                        }
                    }
                    #endregion

                    #region プレイヤー掴み先にペアレントモード（角度戻すなら必要なさそう けど、叩きつけ防止にもなりそうなので保留する。Boolで切り替えるように）

                    //■プレイヤーペアレントモード
                    if (AN_isPlayerParentMode)
                    {
                        if (AN_isRGrapDown)
                        { CameraObjectsTrs.SetParent(AN_Hand_R_RootTrs.parent); }
                        if (AN_isLGrapDown)
                        { CameraObjectsTrs.SetParent(AN_Hand_L_RootTrs.parent); }

                        //両手離したらGameobjectsへ
                        if (!AN_isRGrap && !AN_isLGrap &&
                            CameraObjectsTrs.parent != GameObjectsTrs)
                        { CameraObjectsTrs.SetParent(GameObjectsTrs); }

                        //■角度を変えないモード（掴まってると動いた時上下が変わるので対策 （通常時ブレる））
                        if (AN_isPlayerParentCameraAngleMode)
                        {
                            if (CameraObjectsTrs.eulerAngles.x != 0 || CameraObjectsTrs.eulerAngles.z != 0)
                            { CameraObjectsTrs.eulerAngles = new Vector3(0, CameraObjectsTrs.eulerAngles.y, 0); }
                        }
                    }


                    #endregion

                    //■どちらか掴んでいる時に大きさ変化したらリミット値を合わせる
                    if (AN_isRGrap || AN_isLGrap || AN_isKubinekkoGrap)
                    {
                        //前フレームと大きさが異なっていた時のみ
                        if (AN_tmpPrevPlayerScalex != nowPlayerLocalScale.x)
                        {
                            AN_tmpPrevPlayerScalex = nowPlayerLocalScale.x;

                            //■Tweener踏ん張りが走ってなければ両手のリミットを今のリミットへ
                            if (AN_LLimitTweener.IsActive() == false && AN_RLimitTweener.IsActive() == false)
                            {
                                AN_tmpRLimit.limit =
                                AN_tmpLLimit.limit = AN_nowGrapLimitlength;
                            }

                        }
                    }

                    #endregion

                    //諸々計算後 最後にLimitを代入
                    AN_playerRHandJoint.linearLimit = AN_tmpRLimit;
                    AN_playerLHandJoint.linearLimit = AN_tmpLLimit;
                    //AN_playerKubinekkoJoint.linearLimit = AN_tmpKubinekkoLimit;
                    //DownBool解除
                    AN_isRLGrapDown = AN_isRGrapDown = AN_isLGrapDown = AN_isKubinekkoGrapDown = false;

                    #region 旧UIの表示命令
                    if (AN_isUIVis && !tmpUIVis)
                    {
                        tmpUIVis = true;

                        AN_LGrapSignTrs.gameObject.SetActive(true);
                        AN_RGrapSignTrs.gameObject.SetActive(true);
                        AN_KubinekkoGrapSignTrs.gameObject.SetActive(true);
                    }
                    else if (!AN_isUIVis && tmpUIVis)
                    {
                        tmpUIVis = false;

                        AN_LGrapSignTrs.gameObject.SetActive(false);
                        AN_RGrapSignTrs.gameObject.SetActive(false);
                        AN_KubinekkoGrapSignTrs.gameObject.SetActive(false);
                    }
                    #endregion

                    #region ■新UIの表示命令
                    //左手
                    if (isLLeaveUI == false &&
                        AN_LGrapSignEnum == AN_GrapSignEnum.掴める)
                    {
                        isLLeaveUI = true; isLGrapUI = false; isLNoneUI = false;
                        HandLIconImage.material = null;
                        HandLIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Possible_L");
                        #region WASD矢印
                        if (arrowRenderer.material != arrowWASDMat)
                        { arrowRenderer.material = arrowWASDMat; }
                        #endregion
                    }
                    else if (isLGrapUI == false &&
                        AN_LGrapSignEnum == AN_GrapSignEnum.掴んでいる)
                    {
                        isLLeaveUI = false; isLGrapUI = true; isLNoneUI = false;
                        HandLIconImage.material = null;
                        HandLIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Grap_L");
                    }
                    else if (isLNoneUI == false &&
                        AN_LGrapSignEnum == AN_GrapSignEnum.掴めない)
                    {
                        isLLeaveUI = false; isLGrapUI = false; isLNoneUI = true;
                        HandLIconImage.material = lHandAlphaMat;
                        HandLIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Leave_L");
                        #region WASD矢印
                        if (arrowRenderer.material != arrowFowardMat)
                        { arrowRenderer.material = arrowFowardMat; }
                        #endregion
                    }

                    //右手
                    if (isRLeaveUI == false &&
                    AN_RGrapSignEnum == AN_GrapSignEnum.掴める)
                    {
                        isRLeaveUI = true; isRGrapUI = false; isRNoneUI = false;
                        HandRIconImage.material = null;
                        HandRIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Possible_R");
                        #region WASD矢印
                        if (arrowRenderer.material != arrowWASDMat)
                        { arrowRenderer.material = arrowWASDMat; }
                        #endregion
                    }
                    if (isRGrapUI == false &&
                        AN_RGrapSignEnum == AN_GrapSignEnum.掴んでいる)
                    {
                        isRLeaveUI = false; isRGrapUI = true; isRNoneUI = false;
                        HandRIconImage.material = null;
                        HandRIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Grap_R");
                    }

                    if (isRNoneUI == false &&
                        AN_RGrapSignEnum == AN_GrapSignEnum.掴めない)
                    {
                        isRLeaveUI = false; isRGrapUI = false; isRNoneUI = true;
                        HandRIconImage.material = rHandAlphaMat;
                        HandRIconImage.sprite = Resources.Load<Sprite>("EventSystem/Asinobori/UI/Nobori_Leave_R");
                        #region WASD矢印
                        if (arrowRenderer.material != arrowFowardMat)
                        { arrowRenderer.material = arrowFowardMat; }
                        #endregion
                    }

                    #endregion

                    #region WASD時矢印OBJの表示と回転
                    if (AN_isWASDControll)
                    {
                        AN_ArrowObj.transform.forward = AN_HandControlObj.transform.forward;
                        if (AN_ArrowObj.activeSelf == false)
                        { AN_ArrowObj.SetActive(true); }
                    }
                    else
                    {
                        AN_ArrowObj.transform.forward = VRCameraTrs.forward;
                        if (AN_ArrowObj.activeSelf)
                        { AN_ArrowObj.SetActive(false); }
                    }
                    #endregion


                    #region スキンメッシュコリダー掴み用 埋まり対策テスト

                    //モーフで動かれると、ペアレントした位置から変形して埋まったり離れたりするため
                    //それに対応するための処理


                    //手にRayを打つようオブジェ群（SkinGrapPoints）があり
                    //（O-H-I）こんなイメージ（I不使用）
                    //掴んだ際にまずそのオブジェ群が指定Trsのその位置にペアレントされる。

                    //OからHit地点にRayが飛び、SkinMeshコリダーにぶつかった場所にHが置かれ続ける（膨らんだりへこんだりしても大丈夫なように）
                    //H（HitObj）に手をペアレントする

                    //掴み時にSkinGrapPointsと手のペアレントは済ませたので
                    //↓でRayでHitObj位置更新し続ける

                    //■右手Grap処理でSkinMeshだったらループで掴み場所指定処理
                    if (isAN_RSkinGrap)
                    {
                        //■まずハンドから正面へRayが飛ばせるか
                        //ハンドのY軸が正面だったのでそれを利用してPoint設置した

                        //スキン情報　ReloadSkinMeshCollider Tag SeeGirlIgnoreCollider Layer

                        #region Ray作成
                        skinGrapRay = new Ray
                            (RHandSkinGrapOutPoint.transform.position
                            , RHandSkinGrapOutPoint.transform.forward);

                        Debug.DrawRay(skinGrapRay.origin, skinGrapRay.direction * 100, Color.red);

                        #endregion

                        //Ray マスクはSeeGirlIgnoreCollider
                        if (Physics.Raycast(skinGrapRay, out skinGrapRayHit, Mathf.Infinity, skinGrapLayerMask))
                        {
                            if (skinGrapRayHit.collider == RGrapSkinCollider)
                            {
                                //HitObjをぶつかった位置に
                                RHandSkinGrapHitPoint.transform.position = skinGrapRayHit.point;
                            }
                        }

                        //コリダーRayだと、なぜか一番奥の接触点を参照してしまうのでやっぱやめ
                        ////Ray 掴んでるコリダーのRayで
                        //if (RGrapSkinCollider.Raycast(skinGrapRay, out skinGrapRayHit, Mathf.Infinity))
                        //{
                        //    //HitObjをぶつかった位置に
                        //    RHandSkinGrapHitPoint.transform.position = skinGrapRayHit.point;
                        //}

                        AN_Hand_R_RootTrs.localPosition = Vector3.zero;

                    }
                    //■左手Grap処理でSkinMeshだったらループで掴み場所指定処理
                    if (isAN_LSkinGrap)
                    {
                        //■まずハンドから正面へRayが飛ばせるか
                        //ハンドのY軸が正面だったのでそれを利用してPoint設置した

                        //スキン情報　ReloadSkinMeshCollider Tag SeeGirlIgnoreCollider Layer

                        #region Ray作成
                        skinGrapRay = new Ray
                            (LHandSkinGrapOutPoint.transform.position
                            , LHandSkinGrapOutPoint.transform.forward);

                        Debug.DrawRay(skinGrapRay.origin, skinGrapRay.direction * 100, Color.red);

                        #endregion

                        //Ray マスクはSeeGirlIgnoreCollider
                        if (Physics.Raycast(skinGrapRay, out skinGrapRayHit, Mathf.Infinity, skinGrapLayerMask))
                        {
                            if (skinGrapRayHit.collider == LGrapSkinCollider)
                            {
                                LHandSkinGrapHitPoint.transform.position = skinGrapRayHit.point;
                            }
                            //Debug.Log("hit");
                        }

                        //コリダーRayだと、なぜか一番奥の接触点を参照してしまうのでやっぱやめ
                        ////Ray 掴んでるコリダーのRayで
                        //if (LGrapSkinCollider.Raycast(skinGrapRay, out skinGrapRayHit, Mathf.Infinity))
                        //{
                        //    //HitObjをぶつかった位置に
                        //    LHandSkinGrapHitPoint.transform.position = skinGrapRayHit.point;
                        //}

                        AN_Hand_L_RootTrs.localPosition = Vector3.zero;

                    }


                    #region ■飛び掛りシーン専用に残し
                    if (isAN_TobikakariSkinGrap)
                    {

                        //■まずハンドから正面へRayが飛ばせるか
                        //ハンドのY軸が正面だったのでそれを利用してPoint設置した


                        //■スキン情報　ReloadSkinMeshCollider Tag SeeGirlIgnoreCollider Layer
                        #region Ray作成
                        skinGrapRay = new Ray
                            (LHandSkinGrapOutPoint.transform.position
                            , -LHandSkinGrapOutPoint.transform.up);

                        Debug.DrawRay(skinGrapRay.origin, skinGrapRay.direction * 100, Color.red);

                        #endregion

                        //Ray マスクはSeeGirlIgnoreCollider
                        if (Physics.Raycast(skinGrapRay, out skinGrapRayHit, Mathf.Infinity, skinGrapLayerMask))
                        {
                            LHandSkinGrapHitPoint.transform.position = skinGrapRayHit.point;
                            //Debug.Log("hit");
                        }

                        AN_Hand_L_RootTrs.localPosition = Vector3.zero;


                    }
                    #endregion

                    #endregion


                }

            });
            yield return null;
        }


        #endregion

        #region 終了処理

        //プレイヤーIKHandTarget取り出し
        PlayerIKLHandTargetTrs.SetParent(TargetsTrs, false);
        PlayerIKLHandTargetTrs.position =
        PlayerIKLHandTargetTrs.localEulerAngles = Vector3.zero;
        PlayerIKLHandTargetTrs.localScale = Vector3.one;

        PlayerIKRHandTargetTrs.SetParent(TargetsTrs, false);
        PlayerIKRHandTargetTrs.position =
        PlayerIKRHandTargetTrs.localEulerAngles = Vector3.zero;
        PlayerIKRHandTargetTrs.localScale = Vector3.one;

        //Tween
        AN_RLimitTweener.Kill();
        AN_LLimitTweener.Kill();

        //オブジェ群
        Destroy(EV_C_AsiNobori);
        Destroy(AN_Kubinekko_RootTrs.gameObject);

        #region HandRootはIKHandTargetがペアレント外れているのを入念にチェックしながら削除
        //もしIKHandTargetがまだPivotの中に入っていたら（そういうエラーが出た）
        while (AN_IKLHandPivotTrs.Find("PlayerIKLHandTarget") != null)
        {
            //再度プレイヤーIKHandTarget取り出し
            PlayerIKLHandTargetTrs.SetParent(TargetsTrs, false);
            PlayerIKLHandTargetTrs.position =
            PlayerIKLHandTargetTrs.localEulerAngles = Vector3.zero;
            PlayerIKLHandTargetTrs.localScale = Vector3.one;

            yield return null;
        }
        while (AN_IKLHandPivotTrs.Find("PlayerIKRHandTarget") != null)
        {
            //再度プレイヤーIKHandTarget取り出し
            PlayerIKRHandTargetTrs.SetParent(TargetsTrs, false);
            PlayerIKRHandTargetTrs.position =
            PlayerIKRHandTargetTrs.localEulerAngles = Vector3.zero;
            PlayerIKRHandTargetTrs.localScale = Vector3.one;

            yield return null;
        }
        Destroy(AN_Hand_R_RootTrs.gameObject);
        Destroy(AN_Hand_L_RootTrs.gameObject);
        #endregion


        //Rigidbodyが消えるので、RigidReadSystemを強制で止める
        isRigidReadSystem = false;
        //プレイヤーコンポーネント（RigidBody コリダー ジョイント）
        Destroy(AN_playerRHandJoint);
        Destroy(AN_playerLHandJoint);
        Destroy(AN_playerKubinekkoJoint);
        Destroy(AN_PlayerHuseSphereCollider);
        Destroy(AN_PlayerRigidbody);
        //rigidbodyが最後じゃないとエラーがでる


        //bool群false
        AN_isRGrap =
        AN_isRGrapDown =
        AN_isLGrap =
        AN_isLGrapDown =
        AN_isRLGrap =
        AN_isRLGrapDown =
        AN_isKubinekkoGrap =
        AN_isKubinekkoGrapDown =
        AN_GrapJumpBool =
        AN_GravitiDragBool =

        isRInput =
        isRInputDown =
        isRInputUp =
        isLInput =
        isLInputDown =
        isLInputUp = false;

        ////プレイヤーIK手設定
        //PlayerIKRHandEf.positionWeight = 0;
        //PlayerIKLHandEf.positionWeight = 0;
        //PlayerIKRHandEf.rotationWeight = 0;
        //PlayerIKLHandEf.rotationWeight = 0;
        //プレイヤーIK手設定（手出現演出している最中にオフにするためにDOTweenToIKEfを使う）
        DOTweenToIKEfPos(PlayerIKRHandEf, 0, 0);
        DOTweenToIKEfRot(PlayerIKRHandEf, 0, 0);
        DOTweenToIKEfPos(PlayerIKLHandEf, 0, 0);
        DOTweenToIKEfRot(PlayerIKLHandEf, 0, 0);


        //■ダミーボディの表示非表示
        //FPS時は全部表示消す
        if (tPSModeInt == 0)
        {
            if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }
            if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); }
        }
        //TPS時でも手は消す
        isDummyHandVis = false;
        Dummy_Hand.SetActive(false);

        Destroy(AN_PlayerRHandAreaTriggerSphereTrs.gameObject);
        Destroy(AN_PlayerLHandAreaTriggerSphereTrs.gameObject);
        Destroy(AN_TargetNullRayRefObj);


        //UIオブジェ
        Destroy(ANGrapHandUIObj);
        //赤点滅は手動で切る。
        rHandRedFlashTweener.Kill();
        lHandRedFlashTweener.Kill();

        //FPS移動用にWASD操作切り
        AN_isWASDControll = false;

        //RSMCスキンメッシュ更新止めて削除
        for (int i = 0; i < RSMC_isMeshReloadList.Count; i++)
        {
            RSMC_isMeshReloadList[i] = false;
            //スキンメッシュコリダー終了してなければメッシュ削除（終了してると、既にリストから削除されていてエラーになる。）
            if (RSMC_MeshColliderList[i] != null)
            { RSMC_MeshColliderList[i].sharedMesh = null; }

        }


        //リスト式消し（WASD機能とHandRayShooterのみ追加した）
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion

        isANSystemLoadComplete = false;
        isANSystemRemoveComplete = true;
        Debug.Log("脚のぼりシステム終了処理完了");
        yield break;
    }

    void AsinoboriHandSerch(Transform HandRootTrs)
    {
        #region 右手か左手かで変数に代入
        Transform playerHandAreaSphereTrs = null;
        SphereCollider playerHandAreaSphereCollider = null;
        RaycastHit asinoboriRayHit = new RaycastHit();
        Renderer grapSignRenderer = null;
        Tweener limitTweener = null;
        GameObject HandRayShooter = null;

        if (HandRootTrs == AN_Hand_R_RootTrs)
        {
            asinoboriRayHit = AN_RHandAreaRayHit;
            playerHandAreaSphereTrs = AN_PlayerRHandAreaTriggerSphereTrs;
            playerHandAreaSphereCollider = AN_PlayerRHandAreaTriggerSphereCollider;
            grapSignRenderer = RGrapSignRenderer;
            limitTweener = AN_RLimitTweener;
            HandRayShooter = AN_RHandRayShooterObj;
        }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        {
            asinoboriRayHit = AN_LHandAreaRayHit;
            playerHandAreaSphereTrs = AN_PlayerLHandAreaTriggerSphereTrs;
            playerHandAreaSphereCollider = AN_PlayerLHandAreaTriggerSphereCollider;
            grapSignRenderer = LGrapSignRenderer;
            limitTweener = AN_LLimitTweener;
            HandRayShooter = AN_LHandRayShooterObj;
        }

        #endregion

        //■手目標先がコリダー外の場合 （掴めない）
        //(肩Sphereのコリダー半径に ワールドサイズ*プレイヤーサイズをかけて、ワールド座標でのコリダー距離を出している)
        if (Vector3.Distance(playerHandAreaSphereTrs.position, asinoboriRayHit.point)
            >
            playerHandAreaSphereCollider.radius *
            GameObjectsTrs.localScale.z *
            nowPlayerLocalScale.z
            || //Null（何にもヒットしてない)場合でも
            asinoboriRayHit.transform == null
            )
        {
            #region 掴めない触れない処理
            //掴めないサインEnum■■■■■■■■■■■■■■■
            if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴めない)
            { AN_LGrapSignEnum = AN_GrapSignEnum.掴めない; }
            else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴めない)
            { AN_RGrapSignEnum = AN_GrapSignEnum.掴めない; }
            //掴めないサイン
            if (grapSignRenderer.material != GrapSignNoMat)
            { grapSignRenderer.material = GrapSignNoMat; }

            #region ■視線奥Objから手範囲コリダーにRayを出し、コリダー外側に手浮かし

            // Ray出すオブジェクトとの差分を求め
            Vector3 tempV3 = HandRayShooter.transform.position - AN_TargetNullRayRefObj.transform.position;
            // 正規化して方向ベクトルを求める(Rayはターゲットへの場所ではなく"方向"を指定するため)
            Vector3 normal = tempV3.normalized;
            // Rayの作成
            Ray tmpRayRefPosObjToHandAreaRay = new Ray(AN_TargetNullRayRefObj.transform.position, normal);
            RaycastHit tmpRayRefPosObjToHandAreaRayHit;

            if (playerHandAreaSphereCollider.Raycast(tmpRayRefPosObjToHandAreaRay, out tmpRayRefPosObjToHandAreaRayHit, Mathf.Infinity))
            { HandRootTrs.position = tmpRayRefPosObjToHandAreaRayHit.point; }



            #region //以前の。　以前はぶつかったポイントから発射していたが、Nullの場合動かないので 専用のObjを置いた
            //// ターゲットオブジェクトとの差分を求め
            //Vector3 tempV3 = PlayerHandAreaSphereTrs.position - asinoboriRayHit.point;
            //// 正規化して方向ベクトルを求める(Rayはターゲットへの場所ではなく"方向"を指定するため)
            //Vector3 normal = tempV3.normalized;
            //// Rayの作成
            //Ray tempRayHitPointToHandAreaRay = new Ray(asinoboriRayHit.point, normal);
            //RaycastHit tempRayHitPointToHandAreaRayHit;

            //if (PlayerHandAreaSphereCollider.Raycast(tempRayHitPointToHandAreaRay, out tempRayHitPointToHandAreaRayHit, Mathf.Infinity))
            //{
            //    HandRootTrs.position = tempRayHitPointToHandAreaRayHit.point;
            //}
            #endregion


            #endregion

            //手首を肩にデフォルトで向ける
            HandRootTrs.LookAt(playerHandAreaSphereTrs);

            #region イベント用に、掴める物体の情報をnullに
            if (HandRootTrs == AN_Hand_L_RootTrs)
            {
                if (AN_nowLSerchObj != null)
                { AN_nowLSerchObj = AN_nowLSerchCollObj = null; }
            }
            else if (HandRootTrs == AN_Hand_R_RootTrs)
            {
                if (AN_nowRSerchObj != null)
                { AN_nowRSerchObj = AN_nowRSerchCollObj = null; }
            }
            #endregion
            #endregion
        }
        //■コリダー内（掴める）の場合
        else
        {
            #region イベント用に、掴める物体の情報を更新
            if (HandRootTrs == AN_Hand_L_RootTrs)
            {
                if (AN_nowLSerchObj != asinoboriRayHit.transform.parent.parent.gameObject)
                { AN_nowLSerchObj = asinoboriRayHit.transform.parent.parent.gameObject; }
                if (AN_nowLSerchCollObj != asinoboriRayHit.transform.gameObject)
                { AN_nowLSerchCollObj = asinoboriRayHit.transform.gameObject; }
            }
            else if (HandRootTrs == AN_Hand_R_RootTrs)
            {
                if (AN_nowRSerchObj != asinoboriRayHit.transform.parent.parent.gameObject)
                { AN_nowRSerchObj = asinoboriRayHit.transform.parent.parent.gameObject; }
                if (AN_nowRSerchCollObj != asinoboriRayHit.transform.gameObject)
                { AN_nowRSerchCollObj = asinoboriRayHit.transform.gameObject; }
            }
            #endregion

            //■触れるけど掴めないObjリストにあったら掴めない（けど手は沿わせる）
            if (AN_GrapNGObjList.Contains(asinoboriRayHit.transform.parent.parent.gameObject) == true)
            {
                #region 触れるけど掴めない処理
                //掴めないサインEnum■■■■■■■■■■■■■■■
                if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴めない)
                { AN_LGrapSignEnum = AN_GrapSignEnum.掴めない; }
                else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴めない)
                { AN_RGrapSignEnum = AN_GrapSignEnum.掴めない; }

                //掴めないサイン
                if (grapSignRenderer.material != GrapSignNoMat)
                { grapSignRenderer.material = GrapSignNoMat; }

                //手沿わし
                HandRootTrs.position = asinoboriRayHit.point;
                //手首を肩に向け、コリジョンの面から正面を頭上とする
                HandRootTrs.LookAt(playerHandAreaSphereTrs, asinoboriRayHit.normal);
                #endregion
            }

            //■GrapSupportColliderだった場合 さらに入れ子で処理
            else if (asinoboriRayHit.collider.tag == "GrapSupportCollider")
            {
                #region さらに入れ子で掴めるか処理

                #region ■ぶつかったポイントから高さは変えずに内包されているコリダーへ向けてRay（激しく動いていると駄目？　かも知れないので修正検討）
                //■激ややこしい
                //「当たったコリダーのルートObj」のLocalゼロ位置を、ワールド座標に変換して取得
                //ただし、x（ケーブルObjの高さ値）だけは当たった位置のまま
                Vector3 tmpLocalZeroWorldV3 =
                    asinoboriRayHit.collider.gameObject.transform.TransformPoint(
                        new Vector3(asinoboriRayHit.collider.gameObject.transform.InverseTransformPoint
                        (asinoboriRayHit.point).x, 0, 0));
                //↑これでローカル高さのみ当たった場所のままのローカルゼロ位置のワールド位置取得

                //方向作成
                Vector3
                    tmpV3Normal =
                    (tmpLocalZeroWorldV3 - asinoboriRayHit.point).normalized;

                //Ray作成
                Ray
                    tmpSupportRay =
                    new Ray(asinoboriRayHit.point, tmpV3Normal);
                RaycastHit
                    tmpSuppotrRayHit;

                //Ray　レイヤーマスクはAN_GrapLayerMaskからGrapSupportを抜いたもの
                Physics.Raycast(tmpSupportRay, out tmpSuppotrRayHit, Mathf.Infinity, AN_GrapSupportLayerMask);

                #endregion

                //(肩Sphereのコリダー半径*
                //ワールドサイズ*
                //プレイヤーサイズ*
                //肩Sphereサイズをかけて、
                //ワールド座標でのコリダー距離を出している)（サポートなのでtmpSuppotrRayHitなことに注意）
                if (Vector3.Distance(playerHandAreaSphereTrs.position, tmpSuppotrRayHit.point)
                    >
                    playerHandAreaSphereCollider.radius *
                    GameObjectsTrs.localScale.z *
                    nowPlayerLocalScale.z *
                    playerHandAreaSphereTrs.localScale.z
                    || //Null（何にもヒットしてない)場合でも
                    asinoboriRayHit.transform == null
                    )
                {
                    #region サポートで掴めない触れない処理
                    //掴めないサインEnum■■■■■■■■■■■■■■■
                    if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴めない)
                    { AN_LGrapSignEnum = AN_GrapSignEnum.掴めない; }
                    else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴めない)
                    { AN_RGrapSignEnum = AN_GrapSignEnum.掴めない; }
                    //掴めないサイン
                    if (grapSignRenderer.material != GrapSignNoMat)
                    { grapSignRenderer.material = GrapSignNoMat; }

                    #region ■視線奥Objから手範囲コリダーにRayを出し、コリダー外側に手浮かし

                    // Ray出すオブジェクトとの差分を求め
                    Vector3 tempV3 = playerHandAreaSphereTrs.position - AN_TargetNullRayRefObj.transform.position;
                    // 正規化して方向ベクトルを求める(Rayはターゲットへの場所ではなく"方向"を指定するため)
                    Vector3 normal = tempV3.normalized;
                    // Rayの作成
                    Ray tmpRayRefPosObjToHandAreaRay = new Ray(AN_TargetNullRayRefObj.transform.position, normal);
                    RaycastHit tmpRayRefPosObjToHandAreaRayHit;

                    if (playerHandAreaSphereCollider.Raycast(tmpRayRefPosObjToHandAreaRay, out tmpRayRefPosObjToHandAreaRayHit, Mathf.Infinity))
                    { HandRootTrs.position = tmpRayRefPosObjToHandAreaRayHit.point; }

                    #endregion

                    //手首を肩にデフォルトで向ける
                    HandRootTrs.LookAt(playerHandAreaSphereTrs);

                    #region イベント用に、掴める物体の情報をnullに
                    if (HandRootTrs == AN_Hand_L_RootTrs)
                    {
                        if (AN_nowLSerchObj != null)
                        { AN_nowLSerchObj = AN_nowLSerchCollObj = null; }
                    }
                    else if (HandRootTrs == AN_Hand_R_RootTrs)
                    {
                        if (AN_nowRSerchObj != null)
                        { AN_nowRSerchObj = AN_nowRSerchCollObj = null; }
                    }
                    #endregion
                    #endregion
                }
                else
                {
                    #region サポートで掴める処理
                    //掴めるサインEnum■■■■■■■■■■■■■■■
                    if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴める)
                    { AN_LGrapSignEnum = AN_GrapSignEnum.掴める; }
                    else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴める)
                    { AN_RGrapSignEnum = AN_GrapSignEnum.掴める; }

                    //掴めるサイン
                    if (grapSignRenderer.material != GrapSignOkMat)
                    { grapSignRenderer.material = GrapSignOkMat; }

                    //手沿わし
                    HandRootTrs.position = tmpSuppotrRayHit.point;
                    //手首を肩に向け、コリジョンの面から正面を頭上とする
                    HandRootTrs.LookAt(playerHandAreaSphereTrs, tmpSuppotrRayHit.normal);

                    Debug.DrawRay(asinoboriRayHit.point, tmpV3Normal * 100, Color.red);

                    #region イベント用に、掴める物体の情報を更新
                    if (HandRootTrs == AN_Hand_L_RootTrs)
                    {
                        if (AN_nowLSerchObj != tmpSuppotrRayHit.transform.parent.parent.gameObject)
                        { AN_nowLSerchObj = tmpSuppotrRayHit.transform.parent.parent.gameObject; }
                        if (AN_nowLSerchCollObj != tmpSuppotrRayHit.transform.gameObject)
                        { AN_nowLSerchCollObj = tmpSuppotrRayHit.transform.gameObject; }
                    }
                    else if (HandRootTrs == AN_Hand_R_RootTrs)
                    {
                        if (AN_nowRSerchObj != tmpSuppotrRayHit.transform.parent.parent.gameObject)
                        { AN_nowRSerchObj = tmpSuppotrRayHit.transform.parent.parent.gameObject; }
                        if (AN_nowRSerchCollObj != tmpSuppotrRayHit.transform.gameObject)
                        { AN_nowRSerchCollObj = tmpSuppotrRayHit.transform.gameObject; }
                    }
                    #endregion

                    #endregion
                }
                #endregion
            }
            else //■コリダー内で掴める
            {
                #region 掴める処理
                //掴めるサインEnum■■■■■■■■■■■■■■■
                if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴める)
                { AN_LGrapSignEnum = AN_GrapSignEnum.掴める; }
                else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴める)
                { AN_RGrapSignEnum = AN_GrapSignEnum.掴める; }

                //掴めるサイン
                if (grapSignRenderer.material != GrapSignOkMat)
                { grapSignRenderer.material = GrapSignOkMat; }

                //手沿わし
                HandRootTrs.position = asinoboriRayHit.point;
                //手首を肩に向け、コリジョンの面から正面を頭上とする
                HandRootTrs.LookAt(playerHandAreaSphereTrs, asinoboriRayHit.normal);
                #endregion
            }
        }
    }
    void AsinoboriHandGrap(Transform HandRootTrs) //掴む場所直接指定しない用
    { AsinoboriHandGrap(HandRootTrs, null, Vector3.zero); }
    void AsinoboriHandGrap(Transform HandRootTrs, Transform directParentTrs, Vector3 directPosition)//本体
    {
        #region 右手か左手かで変数に代入 と それぞれの処理（アニメやレンダラーなど）
        ConfigurableJoint playerHandJoint = null;
        RaycastHit asinoboriRayHit = new RaycastHit();
        Transform playerHandAreaSphereTrs = null;
        Renderer GrapSignRenderer = null;
        Tweener limitTweener = null;


        Transform HandSkinGrapPointsTrs = null;
        Transform HandSkinGrapHitPointTrs = null;

        if (HandRootTrs == AN_Hand_R_RootTrs)
        {
            playerHandJoint = AN_playerRHandJoint;
            asinoboriRayHit = AN_RHandAreaRayHit;
            playerHandAreaSphereTrs = AN_PlayerRHandAreaTriggerSphereTrs;
            GrapSignRenderer = RGrapSignRenderer;
            limitTweener = AN_RLimitTweener;

            HandSkinGrapPointsTrs = RHandSkinGrapPoints.transform;
            HandSkinGrapHitPointTrs = RHandSkinGrapHitPoint.transform;
        }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        {
            playerHandJoint = AN_playerLHandJoint;
            asinoboriRayHit = AN_LHandAreaRayHit;
            playerHandAreaSphereTrs = AN_PlayerLHandAreaTriggerSphereTrs;
            GrapSignRenderer = LGrapSignRenderer;
            limitTweener = AN_LLimitTweener;

            HandSkinGrapPointsTrs = LHandSkinGrapPoints.transform;
            HandSkinGrapHitPointTrs = LHandSkinGrapHitPoint.transform;

        }


        #endregion


        #region 掴み処理

        #region ■智恵理スキンメッシュコリダーの場合、ペアレント先を対応するオブジェにする（directParentTrsを利用）
        if (asinoboriRayHit.collider)
        {

            if (asinoboriRayHit.collider.tag == "ReloadSkinMeshCollider")
            {
                #region //以前の
                //if (AN_nowLSerchCollObj.name == "L_Ashikubi_CollObj")
                //{
                //    directParentTrs = GirlLFootTrs;
                //    directPosition = asinoboriRayHit.point;
                //}
                //else if (AN_nowLSerchCollObj.name == "L_Knee_CollObj")
                //{
                //    directParentTrs = GirlLCalfTrs;
                //    directPosition = asinoboriRayHit.point;
                //}
                //else if (AN_nowLSerchCollObj.name == "R_Ashikubi_CollObj")
                //{
                //    directParentTrs = GirlRFootTrs;
                //    directPosition = asinoboriRayHit.point;
                //}
                //else if (AN_nowLSerchCollObj.name == "R_knee_CollObj")
                //{
                //    directParentTrs = GirlRCalfTrs;
                //    directPosition = asinoboriRayHit.point;
                //}
                //else if (AN_nowLSerchCollObj.name == "Pants_collObj")
                //{
                //    directParentTrs = GirlPelvisTrs;
                //    directPosition = asinoboriRayHit.point;
                //}
                #endregion

                #region ちょっと前のコリダーネームと処理（Spatsは生かすように注意）
                if (asinoboriRayHit.collider.name == "RightHand_CollObj")
                {
                    directParentTrs = GirlRHandTrs;//なかった時用にひとまず
                    directPosition = asinoboriRayHit.point;
                }
                else if (asinoboriRayHit.collider.name == "LeftHand_CollObj")
                {
                    directParentTrs = GirlLHandTrs;
                    directPosition = asinoboriRayHit.point;
                }
                else if (asinoboriRayHit.collider.name == "LeftLeg_CollObj")
                {
                    directParentTrs = GirlLFootTrs;
                    directPosition = asinoboriRayHit.point;
                }
                else if (asinoboriRayHit.collider.name == "RightLeg_CollObj")
                {
                    directParentTrs = GirlRFootTrs;
                    directPosition = asinoboriRayHit.point;
                }
                else if (asinoboriRayHit.collider.name == "SpatsObj")
                {
                    directParentTrs = GirlRFootTrs;
                    directPosition = asinoboriRayHit.point;
                }
                #endregion

                #region ペアレント
                //20190926追加
                else if (asinoboriRayHit.collider.name == "EYE_defObj")
                { HandSkinGrapPointsTrs.SetParent(GirlHeadTrs); }
                else if (asinoboriRayHit.collider.name == "Head_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlHeadTrs); }

                else if (asinoboriRayHit.collider.name == "L_Calf_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLCalfTrs); }
                else if (asinoboriRayHit.collider.name == "L_Foot_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLFootTrs); }
                else if (asinoboriRayHit.collider.name == "L_Forearm_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLForearmTrs); }
                else if (asinoboriRayHit.collider.name == "L_Hand_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLHandTrs); }
                else if (asinoboriRayHit.collider.name == "L_hitosashi00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLhitosashi00Trs); }
                else if (asinoboriRayHit.collider.name == "L_knee_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLCalfTrs); }//検知コリダーとはペアレント先が違うことに注意
                else if (asinoboriRayHit.collider.name == "L_ko00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLko00Trs); }
                else if (asinoboriRayHit.collider.name == "L_kusuri00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLkusuri00Trs); }
                else if (asinoboriRayHit.collider.name == "L_naka00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLnaka00Trs); }
                else if (asinoboriRayHit.collider.name == "L_oya00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLoya00Trs); }
                else if (asinoboriRayHit.collider.name == "L_Thigh_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLThighTrs); }
                else if (asinoboriRayHit.collider.name == "L_Toe0_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLToe0Trs); }
                else if (asinoboriRayHit.collider.name == "L_Toe1_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLToe1Trs); }
                else if (asinoboriRayHit.collider.name == "L_Toe2_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLToe2Trs); }
                else if (asinoboriRayHit.collider.name == "L_Toe3_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLToe3Trs); }
                else if (asinoboriRayHit.collider.name == "L_Toe4_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLToe4Trs); }
                else if (asinoboriRayHit.collider.name == "L_UpperArm_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlLUpperArmTrs); }

                else if (asinoboriRayHit.collider.name == "Mouth_defObj")
                { HandSkinGrapPointsTrs.SetParent(GirlHeadTrs); }
                else if (asinoboriRayHit.collider.name == "Pelvis_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlPelvisTrs); }

                else if (asinoboriRayHit.collider.name == "R_Calf_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRCalfTrs); }
                else if (asinoboriRayHit.collider.name == "R_Foot_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRFootTrs); }
                else if (asinoboriRayHit.collider.name == "R_Forearm_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRForearmTrs); }
                else if (asinoboriRayHit.collider.name == "R_Hand_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRHandTrs); }
                else if (asinoboriRayHit.collider.name == "R_hitosashi00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRhitosashi00Trs); }
                else if (asinoboriRayHit.collider.name == "R_knee_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRCalfTrs); }//検知コリダーとはペアレント先が違うことに注意
                else if (asinoboriRayHit.collider.name == "R_ko00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRko00Trs); }
                else if (asinoboriRayHit.collider.name == "R_kusuri00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRkusuri00Trs); }
                else if (asinoboriRayHit.collider.name == "R_naka00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRnaka00Trs); }
                else if (asinoboriRayHit.collider.name == "R_oya00_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRoya00Trs); }
                else if (asinoboriRayHit.collider.name == "R_Thigh_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRThighTrs); }
                else if (asinoboriRayHit.collider.name == "R_Toe0_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRToe0Trs); }
                else if (asinoboriRayHit.collider.name == "R_Toe1_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRToe1Trs); }
                else if (asinoboriRayHit.collider.name == "R_Toe2_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRToe2Trs); }
                else if (asinoboriRayHit.collider.name == "R_Toe3_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRToe3Trs); }
                else if (asinoboriRayHit.collider.name == "R_Toe4_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRToe4Trs); }
                else if (asinoboriRayHit.collider.name == "R_UpperArm_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlRUpperArmTrs); }

                else if (asinoboriRayHit.collider.name == "Spine_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlSpineTrs); }
                else if (asinoboriRayHit.collider.name == "Spine1_CBMObj")
                { HandSkinGrapPointsTrs.SetParent(GirlSpine1Trs); }
                else if (asinoboriRayHit.collider.name == "Tooth_defObj")
                { HandSkinGrapPointsTrs.SetParent(GirlTooth00Trs); }
                else if (asinoboriRayHit.collider.name == "Tang_defObj")
                { HandSkinGrapPointsTrs.SetParent(GirlTang0000Trs); }
                else if (asinoboriRayHit.collider.name == "Kounai_defObj")
                { HandSkinGrapPointsTrs.SetParent(GirlHeadTrs); }
                #endregion

                //ペアレントした時の大きさ位置修正
                HandSkinGrapPointsTrs.localScale = Vector3.one;//大きさ変えると崩れる（手（プレイヤー）の大きさのままペアレントされて、さらにそこに手が入ってしまう）ので1のままにする
                HandSkinGrapPointsTrs.position = asinoboriRayHit.point;

                //手の設置場所指定
                directParentTrs = HandSkinGrapHitPointTrs;
                //directPosition = asinoboriRayHit.point;
                directPosition = HandSkinGrapHitPointTrs.position;

                //Debug.Log("nts" + HandSkinGrapPointsTrs.position);
                //Debug.Log("asi" + asinoboriRayHit.point);
                //Debug.Log("Hit" + HandSkinGrapHitPointTrs.position);

                //■HitObj更新し続けループ開始Bool（左手か右手かでBoolとコリダー指定が別）
                if (HandRootTrs == AN_Hand_R_RootTrs)
                {
                    isAN_RSkinGrap = true;
                    RGrapSkinCollider = asinoboriRayHit.collider;

                    //Out（Ray出すObj）を掴んだ瞬間の"asinoboriRayの発射地点"と同じに
                    RHandSkinGrapOutPoint.transform.position = AN_RHandRayShooterObj.transform.position;
                    //RayのHit地点へ向かせる
                    RHandSkinGrapOutPoint.transform.LookAt(HandSkinGrapPointsTrs);
                }
                else
                {
                    isAN_LSkinGrap = true;
                    LGrapSkinCollider = asinoboriRayHit.collider;

                    //Out（Ray出すObj）を掴んだ瞬間のasinoboriRayの発射地点と同じに
                    LHandSkinGrapOutPoint.transform.position = AN_LHandRayShooterObj.transform.position;
                    //RayのHit地点へ向かせる
                    LHandSkinGrapOutPoint.transform.LookAt(HandSkinGrapPointsTrs);
                }


                #region //一番近いコリダー探してそれにペアレント
                ////■解説
                ////HandRootに専用コリダーがある。それにEnterしているコリダーを取り出す
                ////ポイントからコリダーRayを飛ばし、一番距離が近いコリダーにペアレント


                ////距離取得用
                //float tmpDistance = Mathf.Infinity;

                ////HandRootについているコリダースクリプト取得
                //SkinMeshGrapCollider skinMeshGrapCollider =
                //    HandRootTrs.Find("SkinMeshGrapSphereCollider").GetComponent<SkinMeshGrapCollider>();

                ////コリダーがなかったら即抜け
                //if (skinMeshGrapCollider.stayColliderList.Count == 0) { }
                ////1個しかなかったらそれをペアレント対象にして抜け
                //else if (skinMeshGrapCollider.stayColliderList.Count == 1)
                //{ directParentTrs = skinMeshGrapCollider.stayColliderList[0].transform; }
                ////2個以上あれば計測開始
                //else if (skinMeshGrapCollider.stayColliderList.Count >= 2)
                //{
                //    //EnterしているコリダーのRayで距離計り
                //    for (int i = 0; i < skinMeshGrapCollider.stayColliderList.Count; i++)
                //    {
                //        Vector3 tmpDir = asinoboriRayHit.point - skinMeshGrapCollider.stayColliderList[i].transform.position;
                //        Ray tmpRay = new Ray(asinoboriRayHit.point, tmpDir);
                //        RaycastHit tmpRayHit = new RaycastHit();

                //        //コリダーへRay飛ばし
                //        if (skinMeshGrapCollider.stayColliderList[i].Raycast(tmpRay, out tmpRayHit, Mathf.Infinity))
                //        {
                //            //前より近かったらペアレント対象に
                //            float tmpMag = (asinoboriRayHit.point - tmpRayHit.point).sqrMagnitude;
                //            if (tmpDistance > tmpMag)
                //            {
                //                tmpDistance = tmpMag;
                //                directParentTrs = skinMeshGrapCollider.stayColliderList[i].transform;
                //            }

                //            Debug.Log(skinMeshGrapCollider.stayColliderList[i].name + tmpMag);
                //        }
                //    }
                //}

                //Debug.Log("結果" + directParentTrs.name + tmpDistance);
                #endregion

            }
        }


        #endregion


        //■位置移動とペアレント
        //指定が無い場合(通常)
        if (directParentTrs == null)
        {
            //■さらにGrapSupportColliderだった場合 掴む場所は内包されているコリダー。
            if (asinoboriRayHit.collider.tag == "GrapSupportCollider")
            {
                #region ■ぶつかったポイントから高さは変えずに内包されているコリダーへRay
                //■激ややこしい
                //「当たったコリダーのルートObj」のLocalゼロ位置を、ワールド座標に変換して取得
                //ただし、x（ケーブルObjの高さ値）だけは当たった位置のまま
                Vector3 tmpLocalZeroWorldV3 =
                    asinoboriRayHit.collider.gameObject.transform.TransformPoint(
                        new Vector3(asinoboriRayHit.collider.gameObject.transform.InverseTransformPoint
                        (asinoboriRayHit.point).x, 0, 0));
                //↑これでローカル高さのみ当たった場所のままのローカルゼロ位置のワールド位置取得

                //方向作成
                Vector3
                    tmpV3Normal =
                    (tmpLocalZeroWorldV3 - asinoboriRayHit.point).normalized;

                //Ray作成
                Ray
                    tmpSupportRay =
                    new Ray(asinoboriRayHit.point, tmpV3Normal);
                RaycastHit
                    tmpSupportRayHit;

                //Ray　レイヤーマスクはAN_GrapLayerMaskからGrapSupportを抜いたもの
                Physics.Raycast(tmpSupportRay, out tmpSupportRayHit, Mathf.Infinity, AN_GrapSupportLayerMask);

                #endregion

                //Debug.Log(tmpSupportRayHit.collider.name);
                #region ぶっとぶバグ対応(サポートコリダー版（RayHitがtmpSupportRayHitにしてある）)
                //NGリスト確認（nowSerchではなくｔｍｐSupportRayHitから算出）
                if (AN_GrapNGObjList.Contains(tmpSupportRayHit.transform.parent.parent.gameObject))
                { return; }

                //■手目標先がコリダー外の場合 （掴めない）
                //(肩Sphereのコリダー半径に ワールドサイズ*プレイヤーサイズをかけて、ワールド座標でのコリダー距離を出している)
                #region 右手
                if (HandRootTrs == AN_Hand_R_RootTrs)
                {
                    if (Vector3.Distance(playerHandAreaSphereTrs.position, tmpSupportRayHit.point)
                    >
                    AN_PlayerRHandAreaTriggerSphereCollider.radius *
                    GameObjectsTrs.localScale.z *
                    nowPlayerLocalScale.z
                    || //Null（何にもヒットしてない)場合でも
                    tmpSupportRayHit.transform == null
                    )
                    {
                        //■掴めなかった時スカり演出 
                        SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_R_RootTrs.gameObject);
                        PlayerMotion("登りグーからパー", 0f, 3);
                        rHandRedFlashTweener.Restart();

                        //トグルモードの場合はキャンセル
                        if (AN_isInputToggleMode || AN_isInputMixMode) { isRInputUp = true; isRInput = false; }
                        return;
                    }
                }
                #endregion
                #region 左手
                else if (HandRootTrs == AN_Hand_L_RootTrs)
                {
                    if (Vector3.Distance(playerHandAreaSphereTrs.position, tmpSupportRayHit.point)
                    >
                    AN_PlayerLHandAreaTriggerSphereCollider.radius *
                    GameObjectsTrs.localScale.z *
                    nowPlayerLocalScale.z
                    || //Null（何にもヒットしてない)場合でも
                    tmpSupportRayHit.transform == null
                    )
                    {
                        //■掴めなかった時スカり演出 
                        SEPlay(UISEObj, "GrapMiss_interaction_whoosh_small_01", AN_Hand_L_RootTrs.gameObject);
                        PlayerMotion("登りグーからパー", 0f, 3);
                        lHandRedFlashTweener.Restart();

                        //トグルモードの場合はキャンセル
                        if (AN_isInputToggleMode || AN_isInputMixMode) { isLInputUp = true; isLInput = false; }
                        return;
                    }
                }
                #endregion

                #endregion

                HandRootTrs.position = tmpSupportRayHit.point;
                HandRootTrs.SetParent(tmpSupportRayHit.transform, true);


                //掴みSE(サポートのRayの場合は、なぜかparent.parenじゃなくてよかった)
                HandGrapSEPlay(HandRootTrs.gameObject, tmpSupportRayHit.transform.gameObject);
            }
            else//そうでなければ普通に掴む
            {
                HandRootTrs.position = asinoboriRayHit.point;
                HandRootTrs.SetParent(asinoboriRayHit.transform, true);
                //掴みSE
                HandGrapSEPlay(HandRootTrs.gameObject, asinoboriRayHit.transform.parent.parent.gameObject);
            }
        }
        //指定があればその指定位置に
        else if (directParentTrs != null)
        {
            HandRootTrs.position = directPosition;
            LateAction(() => { });
            HandRootTrs.SetParent(directParentTrs, true);
        }

        #endregion



        #region UIや表示、Enum判定の処理
        //■Grap判定Bool
        if (HandRootTrs == AN_Hand_R_RootTrs)
        { AN_isRGrap = AN_isRGrapDown = true; }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        { AN_isLGrap = AN_isLGrapDown = true; }

        if (AN_isRGrap && AN_isLGrap)
        { AN_isRLGrap = AN_isRLGrapDown = true; }

        //■手首を肩に向け、コリジョンの面から正面を頭上とする
        HandRootTrs.LookAt(playerHandAreaSphereTrs, asinoboriRayHit.normal);
        //掴みっぱなしでこちらに向けておくように、normalを取得する
        if (HandRootTrs == AN_Hand_R_RootTrs)
        { AN_RhandGrapNormalV3 = asinoboriRayHit.normal; }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        { AN_LhandGrapNormalV3 = asinoboriRayHit.normal; }

        //■掴みアニメ
        if (HandRootTrs == AN_Hand_R_RootTrs)
        { PlayerMotion("登りグー", 0.1f, 2); }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        { PlayerMotion("登りグー", 0.1f, 3); }

        //掴んでるサインEnum■■■■■■■■■■■■■■■
        if (HandRootTrs == AN_Hand_L_RootTrs && AN_LGrapSignEnum != AN_GrapSignEnum.掴んでいる)
        { AN_LGrapSignEnum = AN_GrapSignEnum.掴んでいる; }
        else if (HandRootTrs == AN_Hand_R_RootTrs && AN_RGrapSignEnum != AN_GrapSignEnum.掴んでいる)
        { AN_RGrapSignEnum = AN_GrapSignEnum.掴んでいる; }
        //■掴んでるサイン
        if (GrapSignRenderer.material != GrapSignEnterMat)
        { GrapSignRenderer.material = GrapSignEnterMat; }

        #endregion

        #region ジョイントリミットのTweener処理
        //両手で掴んだら 現在の距離間で固定
        if (AN_isRLGrap)
        {
            AN_RLimitTweener.Pause();
            AN_LLimitTweener.Pause();

            //CameraObjectsの中心までの距離で計算（アンカーが0なので同じ位置）
            if (AN_tmpRLimit.limit != Vector3.Distance(CameraObjectsTrs.position, PlayerIKRHandTargetTrs.position))
            { AN_tmpRLimit.limit = Vector3.Distance(CameraObjectsTrs.position, PlayerIKRHandTargetTrs.position); }
            if (AN_tmpLLimit.limit != Vector3.Distance(CameraObjectsTrs.position, PlayerIKLHandTargetTrs.position))
            { AN_tmpLLimit.limit = Vector3.Distance(CameraObjectsTrs.position, PlayerIKLHandTargetTrs.position); }

            ////Jointのアンカー位置をプラスする仕様（結局サイズがかわって角度が変わると変になる）
            //if (AN_tmpRLimit.limit != Vector3.Distance(
            //    CameraObjectsTrs.TransformPoint(AN_playerRHandJoint.anchor)
            //    , PlayerIKRHandTargetTrs.position))
            //{
            //    AN_tmpRLimit.limit = Vector3.Distance(
            //    CameraObjectsTrs.TransformPoint(AN_playerRHandJoint.anchor)
            //    , PlayerIKRHandTargetTrs.position);
            //}

            //if (AN_tmpLLimit.limit != Vector3.Distance(
            //    CameraObjectsTrs.TransformPoint(AN_playerLHandJoint.anchor)
            //    , PlayerIKLHandTargetTrs.position))
            //{
            //    AN_tmpLLimit.limit = Vector3.Distance(
            //    CameraObjectsTrs.TransformPoint(AN_playerLHandJoint.anchor)
            //    , PlayerIKLHandTargetTrs.position);
            //}
        }
        else//片手(両手離しから掴んだ)の場合
        {
            limitTweener.Pause();
            AN_tmpRLimit.limit =
            AN_tmpLLimit.limit = AN_nowGrapLimitlength;
            AN_GrapPowFloat = AN_GrapPowMin;
        }
        #endregion
        #region ジョイントばね
        JointDrive tempJoint;
        //両手の場合
        if (AN_isRLGrap)
        {
            //揺れ値
            playerHandJoint.xMotion = AN_handRyouteJoint.xMotion;
            playerHandJoint.yMotion = AN_handRyouteJoint.yMotion;
            playerHandJoint.zMotion = AN_handRyouteJoint.zMotion;

            tempJoint = AN_handRyouteJoint.xDrive;
            tempJoint.positionSpring = AN_handRyouteJoint.xDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handRyouteJoint.xDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.xDrive = tempJoint;

            tempJoint = AN_handRyouteJoint.yDrive;
            tempJoint.positionSpring = AN_handRyouteJoint.yDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handRyouteJoint.yDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.yDrive = tempJoint;

            tempJoint = AN_handRyouteJoint.zDrive;
            tempJoint.positionSpring = AN_handRyouteJoint.zDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handRyouteJoint.zDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.zDrive = tempJoint;
        }
        else //片手の場合
        {
            //揺れ値
            playerHandJoint.xMotion = AN_handKatateJoint.xMotion;
            playerHandJoint.yMotion = AN_handKatateJoint.yMotion;
            playerHandJoint.zMotion = AN_handKatateJoint.zMotion;

            tempJoint = AN_handKatateJoint.xDrive;
            tempJoint.positionSpring = AN_handKatateJoint.xDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handKatateJoint.xDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.xDrive = tempJoint;

            tempJoint = AN_handKatateJoint.yDrive;
            tempJoint.positionSpring = AN_handKatateJoint.yDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handKatateJoint.yDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.yDrive = tempJoint;

            tempJoint = AN_handKatateJoint.zDrive;
            tempJoint.positionSpring = AN_handKatateJoint.zDrive.positionSpring * nowPlayerLocalScale.x;
            tempJoint.positionDamper = AN_handKatateJoint.zDrive.positionDamper * nowPlayerLocalScale.x;
            playerHandJoint.zDrive = tempJoint;
        }

        #endregion


        return;
    }
    void AsinoboriHandLeave(Transform HandRootTrs, ConfigurableJoint playerHandJoint)
    {
        if (HandRootTrs == AN_Hand_R_RootTrs)
        {
            //GrapBoolはずし（SkinGrapも一緒に）
            AN_isRGrap = isAN_RSkinGrap = false;
            //SkinGrap用のRayオブジェを手にペアレント戻す(Lateじゃないとできなかった)
            LateAction(() =>
            {
                RHandSkinGrapPoints.transform.SetParent(AN_Hand_R_RootTrs);
                RHandSkinGrapPoints.transform.localPosition = Vector3.zero;
                RHandSkinGrapPoints.transform.localEulerAngles = Vector3.zero;
                RHandSkinGrapPoints.transform.localScale = Vector3.one;
                RHandSkinGrapHitPoint.transform.localPosition = Vector3.zero;
            });

            Debug.Log("RLaeave");
        }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        {
            AN_isLGrap = isAN_LSkinGrap = false;
            LateAction(() =>
            {
                LHandSkinGrapPoints.transform.SetParent(AN_Hand_L_RootTrs);
                LHandSkinGrapPoints.transform.localPosition = Vector3.zero;
                LHandSkinGrapPoints.transform.localEulerAngles = Vector3.zero;
                LHandSkinGrapPoints.transform.localScale = Vector3.one;
                LHandSkinGrapHitPoint.transform.localPosition = Vector3.zero;
            });
            Debug.Log("LLaeave");
        }

        //ペアレント戻し
        HandRootTrs.SetParent(GameObjectsTrs, true);
        //ローカル 少し浮かし位置（押した時にプレオブジェに入れておいた値）
        //HandRootTrs.position = PreMoveCubeRTrs.transform.position;

        //離しアニメ
        //掴みアニメ
        if (HandRootTrs == AN_Hand_R_RootTrs)
        { PlayerMotion("登りパー", 0.1f, 2); }
        else if (HandRootTrs == AN_Hand_L_RootTrs)
        { PlayerMotion("登りパー", 0.1f, 3); }

        //離しジョイント(limitの影響が出ない)（両手離し、Free）
        playerHandJoint.linearLimit = AN_handJoint.linearLimit;
        playerHandJoint.xMotion = AN_handJoint.xMotion;
        playerHandJoint.yMotion = AN_handJoint.yMotion;
        playerHandJoint.zMotion = AN_handJoint.zMotion;
        playerHandJoint.xDrive = AN_handJoint.xDrive;
        playerHandJoint.yDrive = AN_handJoint.yDrive;
        playerHandJoint.zDrive = AN_handJoint.zDrive;

        //■Tween両手掴み状態から離した場合、もう片方の手で踏ん張り登り
        if (AN_isRLGrap)
        {
            //パワーがボーダーまである場合は踏ん張る　登りモードなら無条件で踏ん張る
            if (AN_GrapPowFloat > AN_GrapPowBorder)
            {
                if (!AN_isRGrap)//右手を離した
                {
                    //左手へのリミットをふんばり値に
                    AN_LLimitTweener
                        .ChangeEndValue(AN_GrapHoldOutLimitlength * (nowPlayerLocalScale.x * GameObjectsTrs.localScale.x)
                        , AN_GrapHoldOutSpeed, true)
                        .SetEase(Ease.InSine)
                        .Restart();

                    //片手のジョイントばねに戻す
                    AN_playerLHandJoint.xDrive = AN_handKatateJoint.xDrive;
                    AN_playerLHandJoint.yDrive = AN_handKatateJoint.yDrive;
                    AN_playerLHandJoint.zDrive = AN_handKatateJoint.zDrive;
                }
                else if (!AN_isLGrap)
                {
                    AN_RLimitTweener
                        .ChangeEndValue(AN_GrapHoldOutLimitlength * (nowPlayerLocalScale.x * GameObjectsTrs.localScale.x)
                        , AN_GrapHoldOutSpeed, true)
                        .SetEase(Ease.InSine)
                        .Restart();

                    AN_playerRHandJoint.xDrive = AN_handKatateJoint.xDrive;
                    AN_playerRHandJoint.yDrive = AN_handKatateJoint.yDrive;
                    AN_playerRHandJoint.zDrive = AN_handKatateJoint.zDrive;
                }
            }

            //パワーがボーダーまでなければぶらりん　登りモードならなし
            if (AN_GrapPowFloat < AN_GrapPowBorder)
            {
                if (!AN_isRGrap)
                {
                    AN_LLimitTweener.Pause();
                    AN_tmpRLimit.limit =
                    AN_tmpLLimit.limit = AN_nowGrapLimitlength;

                    //片手のジョイントばねに戻す
                    AN_playerLHandJoint.xDrive = AN_handKatateJoint.xDrive;
                    AN_playerLHandJoint.yDrive = AN_handKatateJoint.yDrive;
                    AN_playerLHandJoint.zDrive = AN_handKatateJoint.zDrive;
                }
                else if (!AN_isLGrap)
                {
                    AN_RLimitTweener.Pause();
                    AN_tmpRLimit.limit =
                    AN_tmpLLimit.limit = AN_nowGrapLimitlength;

                    AN_playerRHandJoint.xDrive = AN_handKatateJoint.xDrive;
                    AN_playerRHandJoint.yDrive = AN_handKatateJoint.yDrive;
                    AN_playerRHandJoint.zDrive = AN_handKatateJoint.zDrive;
                }
            }
        }


        AN_isRLGrap = false;
    }

    #region 首根っこ（受動的で、直接このメソッドで起動）
    void AN_KubinekkoGrap(Transform parentTrs, Vector3 setPosition = new Vector3(), float limit = 0)
    {
        //■RootTrsの設置
        FixedAction(() =>
        {
            AN_Kubinekko_RootTrs.SetParent(parentTrs);
        });

        AN_isKubinekkoGrapDown = AN_isKubinekkoGrap = true;

        //■limit引数指定あればそれに
        if (limit != 0)
        { AN_tmpKubinekkoLimit.limit = limit; }
        else//なければデフォルトの腕ぶらりんぐらい（今までどおり
        { AN_tmpKubinekkoLimit.limit = AN_nowGrapLimitlength; }
        //代入
        AN_playerKubinekkoJoint.linearLimit = AN_tmpKubinekkoLimit;

        //■ジョイントばね設定
        JointDrive tempJoint;
        //揺れ値
        AN_playerKubinekkoJoint.xMotion = AN_handKatateJoint.xMotion;
        AN_playerKubinekkoJoint.yMotion = AN_handKatateJoint.yMotion;
        AN_playerKubinekkoJoint.zMotion = AN_handKatateJoint.zMotion;

        tempJoint = AN_handKatateJoint.xDrive;
        tempJoint.positionSpring = AN_handKatateJoint.xDrive.positionSpring * nowPlayerLocalScale.x;
        tempJoint.positionDamper = AN_handKatateJoint.xDrive.positionDamper * nowPlayerLocalScale.x;
        AN_playerKubinekkoJoint.xDrive = tempJoint;

        tempJoint = AN_handKatateJoint.yDrive;
        tempJoint.positionSpring = AN_handKatateJoint.yDrive.positionSpring * nowPlayerLocalScale.x;
        tempJoint.positionDamper = AN_handKatateJoint.yDrive.positionDamper * nowPlayerLocalScale.x;
        AN_playerKubinekkoJoint.yDrive = tempJoint;

        tempJoint = AN_handKatateJoint.zDrive;
        tempJoint.positionSpring = AN_handKatateJoint.zDrive.positionSpring * nowPlayerLocalScale.x;
        tempJoint.positionDamper = AN_handKatateJoint.zDrive.positionDamper * nowPlayerLocalScale.x;
        AN_playerKubinekkoJoint.zDrive = tempJoint;
    }
    void AN_KubinekkoLeave()
    {
        AN_isKubinekkoGrap = false;
        //ペアレント戻し(首根っこは首根っこへ)
        AN_Kubinekko_RootTrs.SetParent(PlayerKubiNekkoPosObjTrs, true);
        AN_Kubinekko_RootTrs.localPosition = Vector3.zero;

        //離しジョイント(limitの影響が出ない)
        AN_playerKubinekkoJoint.linearLimit = AN_handJoint.linearLimit;
        AN_playerKubinekkoJoint.xMotion = AN_handJoint.xMotion;
        AN_playerKubinekkoJoint.yMotion = AN_handJoint.yMotion;
        AN_playerKubinekkoJoint.zMotion = AN_handJoint.zMotion;
        AN_playerKubinekkoJoint.xDrive = AN_handJoint.xDrive;
        AN_playerKubinekkoJoint.yDrive = AN_handJoint.yDrive;
        AN_playerKubinekkoJoint.zDrive = AN_handJoint.zDrive;
    }
    #endregion


    #region インプット設定
    public bool
        isRInput,
        isRInputDown,
        isRInputUp,
        isLInput,
        isLInputDown,
        isLInputUp;

    void PlayerRLInput()
    {
        #region 右手
        //DownUp解除
        isRInputDown = isRInputUp = false;
        //どれかボタンが押されてるとき
        if (Input.GetButton(DB.inputDict["右手"]))
        {
            //ボタンがまだどれも押されてなかった時だけ
            if (!isRInput)
            {
                //Downが効く
                if (!isRInputDown) { isRInputDown = true; }
                isRInput = true;
            }
        }
        //"どれも"ボタンが押されてない時
        else if (Input.GetButton(DB.inputDict["右手"]) == false)
        {
            //ボタンが押されていた時だけ
            if (isRInput)
            {
                //Upが効く
                if (!isRInputUp) { isRInputUp = true; }
                isRInput = false;
            }
        }
        #endregion 右手

        #region 左手
        isLInputDown = isLInputUp = false;
        //どれかボタンが押されてるとき
        if (Input.GetButton(DB.inputDict["左手"]))
        {
            //ボタンがまだどれも押されてなかった時だけ
            if (!isLInput)
            {
                //Downが効く
                if (!isLInputDown) { isLInputDown = true; }
                isLInput = true;
            }
        }

        //"どれも"ボタンが押されてない時
        if (!Input.GetButton(DB.inputDict["左手"]))
        {
            //ボタンが押されていた時だけ
            if (isLInput)
            {
                //Upが効く
                if (!isLInputUp) { isLInputUp = true; }
                isLInput = false;
            }
        }
        #endregion 左手
    }
    void PlayerRLInputToggle()
    {
        isRInputDown =
        isLInputDown =
        isRInputUp =
        isLInputUp = false;

        #region 右手
        //どれかボタンが押されたとき
        if (Input.GetButtonDown(DB.inputDict["右手"]))
        {
            //OFFだったらON
            if (!isRInput)
            {
                isRInputDown = true;
                isRInput = true;
            }
            else //ONだったらOFF
            {
                isRInputUp = true;
                isRInput = false;
            }
        }
        #endregion 右手

        #region 左手
        //どれかボタンが押されてるとき
        if (Input.GetButtonDown(DB.inputDict["左手"]))
        {
            //OFFだったらON
            if (!isLInput)
            {
                isLInputDown = true;
                isLInput = true;
            }
            else //ONだったらOFF
            {
                isLInputUp = true;
                isLInput = false;
            }
        }
        #endregion 左手
    }
    #region スイッチハード版（手外れる）
    int inputSwitchHardInt = 0;
    void PlayerRLInputSwitchHard()
    {
        isRInputDown =
        isLInputDown =
        isRInputUp =
        isLInputUp = false;

        #region どのボタンでもで右手左手交互操作
        //押されている
        if (Input.GetButtonDown(DB.inputDict["左手"])
            || Input.GetButtonDown(DB.inputDict["右手"])
            || isKetteiDown)
        {

            //両手掴めるなら両手掴み
            if (AN_RGrapSignEnum == AN_GrapSignEnum.掴める
                && AN_LGrapSignEnum == AN_GrapSignEnum.掴める)
            {
                isRInputDown = true;
                isRInput = true;
                isLInputDown = true;
                isLInput = true;
            }
            //右手だけ掴めるなら右手掴み
            else if (AN_RGrapSignEnum == AN_GrapSignEnum.掴める
                && AN_LGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isRInputDown = true;
                isRInput = true;
                inputSwitchHardInt = 0;//次左手離すように0
            }
            //左手だけ掴めるなら左手掴み
            else if (AN_LGrapSignEnum == AN_GrapSignEnum.掴める
                && AN_RGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isLInputDown = true;
                isLInput = true;
                inputSwitchHardInt = 1;//次右手離すように1
            }


            //右手掴んでいて、左手掴んでいなかったら左手掴みチャレンジ
            else if (AN_RGrapSignEnum == AN_GrapSignEnum.掴んでいる
                && AN_LGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                //左手つかめなかったら右手離れる
                if (AN_LGrapSignEnum == AN_GrapSignEnum.掴めない)
                {
                    isRInput = false;
                    isRInputUp = true;
                }
                //左手つかめるなら掴む
                else if (AN_LGrapSignEnum == AN_GrapSignEnum.掴める)
                {
                    isLInputDown = true;
                    isLInput = true;
                    inputSwitchHardInt = 1;
                }
            }

            //左手掴んでいて、右手掴んでいなかったら右手掴みチャレンジ
            else if (AN_LGrapSignEnum == AN_GrapSignEnum.掴んでいる
                && AN_RGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                //右手つかめなかったら左手離れる
                if (AN_RGrapSignEnum == AN_GrapSignEnum.掴めない)
                {
                    isLInput = false;
                    isLInputUp = true;
                }
                //右手つかめるなら掴む
                else if (AN_RGrapSignEnum == AN_GrapSignEnum.掴める)
                {
                    isRInputDown = true;
                    isRInput = true;
                    inputSwitchHardInt = 0;
                }
            }


        }
        //離した
        else if (Input.GetButtonUp(DB.inputDict["左手"])
            || Input.GetButtonUp(DB.inputDict["右手"])
            || isKetteiUp)
        {
            //両手掴んでいるなら片手離す
            if (AN_RGrapSignEnum == AN_GrapSignEnum.掴んでいる
                && AN_LGrapSignEnum == AN_GrapSignEnum.掴んでいる)
            {
                //0なら左手
                if (inputSwitchHardInt == 0)
                {
                    isLInput = false;
                    isLInputUp = true;
                }
                //1なら右手
                else if (inputSwitchHardInt == 1)
                {
                    isRInput = false;
                    isRInputUp = true;
                }
            }

        }
        #endregion

        #region //右クリック押すとコントロール切り替え
        //if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll)
        //{ AN_isWASDControll = false; }

        //else if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll == false)
        //{ AN_isWASDControll = true; }
        #endregion
        //Debug.Log(inputSwitchInt);
    }
    #endregion
    #region スイッチノーマル版（手外れるけど離すまで待つ(連打が解決できずほぼボツ)）
    int inputSwitchInt = 0;
    void PlayerRLInputSwitchNormal()
    {
        isRInputDown =
        isLInputDown =
        isRInputUp =
        isLInputUp = false;

        #region 左クリックのみで右手左手交互操作
        //押されている
        if (Input.GetButton(DB.inputDict["左手"]))
        {
            //■inputSwitchIntが
            //0なら両手掴み
            if (inputSwitchInt == 0)
            {
                isRInputDown = true;
                isRInput = true;
                isLInputDown = true;
                isLInput = true;
                inputSwitchInt++;
            }
            //2なら右手掴み
            else if (inputSwitchInt == 2)
            {
                isRInputDown = true;
                isRInput = true;
                inputSwitchInt++;
            }
            //4なら左手掴み
            if (inputSwitchInt == 4)
            {
                isLInputDown = true;
                isLInput = true;
                inputSwitchInt++;
            }
        }
        //離した
        else if (Input.GetButtonUp(DB.inputDict["左手"]))
        {
            //1か5なら右手離し　左手握れてなかったら同時に左手掴み 5だったら2に戻す
            if (inputSwitchInt == 1 || inputSwitchInt == 5)
            {
                isRInput = false;
                isRInputUp = true;
                if (!AN_isLGrap)
                {
                    isLInputDown = true;
                    isLInput = true;
                }
                inputSwitchInt++;
                if (inputSwitchInt == 6) { inputSwitchInt = 2; }
            }
            //3なら左手離し　右手握れてなかったら同時に右手掴み
            else if (inputSwitchInt == 3)
            {
                isLInput = false;
                isLInputUp = true;
                inputSwitchInt++;
                if (!AN_isRGrap)
                {
                    isRInputDown = true;
                    isRInput = true;
                }
            }

        }

        //左手も右手も握っておらず、0じゃなければ0に
        else if (!AN_isRGrap && !AN_isLGrap && inputSwitchInt != 0)
        { inputSwitchInt = 0; }
        #endregion

        #region //右クリック押すとコントロール切り替え
        //if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll)
        //{ AN_isWASDControll = false; }

        //else if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll == false)
        //{ AN_isWASDControll = true; }
        #endregion
        //Debug.Log(inputSwitchInt);
    }
    #endregion
    #region スイッチイージー版（手離さない）
    int inputSwitchEasyInt = 0;
    void PlayerRLInputSwitchEasy()
    {
        isRInputDown =
        isLInputDown =
        isRInputUp =
        isLInputUp = false;

        #region どのボタンでも右手左手交互操作
        //押された
        if (Input.GetButtonDown(DB.inputDict["左手"])
            || Input.GetButtonDown(DB.inputDict["右手"])
            || isKetteiDown)
        {
            if (AN_LGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isLInputDown = true;
                isLInput = true;
                inputSwitchEasyInt = 1;//右手離すように
            }
            if (AN_RGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isRInputDown = true;
                isRInput = true;
                inputSwitchEasyInt = 0;//左手離すように
            }

        }
        //離した
        else if (Input.GetButtonUp(DB.inputDict["左手"])
            || Input.GetButtonUp(DB.inputDict["右手"])
            || isKetteiUp)
        {
            //両手掴んでいるなら片手離す
            if (AN_RGrapSignEnum == AN_GrapSignEnum.掴んでいる
                && AN_LGrapSignEnum == AN_GrapSignEnum.掴んでいる)
            {
                //0なら左手
                if (inputSwitchEasyInt == 0)
                {
                    isLInput = false;
                    isLInputUp = true;
                }
                //1なら右手
                else if (inputSwitchEasyInt == 1)
                {
                    isRInput = false;
                    isRInputUp = true;
                }
            }
        }
        #endregion

        #region //右クリック押すとコントロール切り替え
        //if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll)
        //{ AN_isWASDControll = false; }

        //else if (Input.GetButtonDown(DB.inputDict["右手"])
        //    && AN_isWASDControll == false)
        //{ AN_isWASDControll = true; }
        #endregion
        //Debug.Log(inputSwitchInt);
    }
    #endregion
    #region //トグルとEASYスイッチ両方（の予定が要らない気がしてきた）
    void PlayerRLInputSwitchMix()
    {
        isRInputDown =
        isLInputDown =
        isRInputUp =
        isLInputUp = false;

        #region 交互（EASY仕様）

        //押された
        if (isKetteiDown)//連打にならないよう
        {
            if (AN_LGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isLInputDown = true;
                isLInput = true;
                inputSwitchEasyInt = 1;//右手離すように
            }
            if (AN_RGrapSignEnum != AN_GrapSignEnum.掴んでいる)
            {
                isRInputDown = true;
                isRInput = true;
                inputSwitchEasyInt = 0;//左手離すように
            }
            return;
        }
        //離した
        else if (isKetteiUp)
        {
            //両手掴んでいるなら片手離す
            if (AN_RGrapSignEnum == AN_GrapSignEnum.掴んでいる
                && AN_LGrapSignEnum == AN_GrapSignEnum.掴んでいる)
            {
                //0なら左手
                if (inputSwitchEasyInt == 0)
                {
                    isLInput = false;
                    isLInputUp = true;
                }
                //1なら右手
                else if (inputSwitchEasyInt == 1)
                {
                    isRInput = false;
                    isRInputUp = true;
                }
            }
            return;
        }
        #endregion

        #region 右手
        //右手orRShiftor右クリック
        if (Input.GetButtonDown(DB.inputDict["右手"])
            || Input.GetKeyDown(KeyCode.RightShift))
        {
            //OFFだったらON
            if (!isRInput)
            {
                isRInputDown = true;
                isRInput = true;
            }
            else //ONだったらOFF
            {
                isRInputUp = true;
                isRInput = false;
            }
        }
        #endregion □右手

        #region 左手
        //どれかボタンが押されてるとき
        if (Input.GetButtonDown(DB.inputDict["左手"])
            || Input.GetKeyDown(KeyCode.LeftShift))
        {
            //OFFだったらON
            if (!isLInput)
            {
                isLInputDown = true;
                isLInput = true;
            }
            else //ONだったらOFF
            {
                isLInputUp = true;
                isLInput = false;
            }

        }
        #endregion □左手
    }
    #endregion



    #endregion □同意義ボタンが押されてるときはDownを効かないようにするためインプット判定

    //掴んだものにあわせて掴み音
    void HandGrapSEPlay(GameObject HandObj, GameObject GrapObj)
    {
        string
            playSEStr = "UI_po";
        float
            tmpVolume = 1;

        if (GrapObj != null)//エラー回避
        {
            #region エッフェルと名前にあったら
            if (GrapObj.name.IndexOf("Eiffel") >= 0)
            {
                playSEStr = grapMetalStrList[UnityEngine.Random.Range(0, grapMetalStrList.Count)];
                tmpVolume = 0.25f;
            }
            #endregion
            #region 名前に"Chieri"とあったら
            else if (GrapObj.name.IndexOf("Chieri") >= 0)
            {
                playSEStr = grapHadaStrList[UnityEngine.Random.Range(0, grapHadaStrList.Count)];
                tmpVolume = 0.25f;
            }
            #endregion
            #region 名前に"Cord"とあったら(Chieriと同じ肌音)
            else if (GrapObj.name.IndexOf("Cord") >= 0)
            {
                playSEStr = grapHadaStrList[UnityEngine.Random.Range(0, grapHadaStrList.Count)];
                tmpVolume = 0.25f;
            }
            #endregion
            #region 名前に"Cable"とあったら(Chieriと同じ肌音)
            else if (GrapObj.name.IndexOf("Cable") >= 0)
            {
                playSEStr = grapHadaStrList[UnityEngine.Random.Range(0, grapHadaStrList.Count)];
                tmpVolume = 0.25f;
            }
            #endregion
        }
        SEPlay(UISEObj, playSEStr, HandObj, tmpVolume);

        //Debug.Log(GrapObj.name);
    }

    #endregion 脚のぼりシステム
    #region ■怪獣バトルシステム

    #region ■■変数
    [HeaderAttribute("・怪獣バトル")]
    public GameObject //開始時にリソースから読み、終了時に消す用
        EV_C_KaijuBattle;
    IEnumerator //コルーチン一時停止・終了用
        KBSystemLoadIEnum;
    bool //全終了用Bool
        isKBSystem;

    GameObject //智恵理右足コリダーobj
        KB_Tsumasaki_R_collObj;
    Collider
        KB_Tsumasaki_R_Collider;

    Vector3 //プレイヤーバトル開始前サイズ
        KBstartPrevPlayerSize = new Vector3();
    List<Transform> //プレイヤー場所 智恵理場所 隠れ場所オブジェ
        KB_PlayerPosTrssList = new List<Transform>(),
        KB_ChieriStartPosTrssList = new List<Transform>();

    //■パンチ
    bool KB_punchEnabled = true;
    Transform //プレイヤーIKパスの親
        KB_PlayerPunchPathsTrs,
        //パンチ動作用特殊オブジェTrs群
        KB_PlayerPunchPaths00_StartHand_R_RootTrs,
        KB_PlayerPunchPaths01_HitHand_R_RootTrs,
        KB_PlayerPunchPaths0101_PunchHitPosTrs,
        KB_PlayerPunchPaths010100_BoxCastScaleTrs,
        KB_PlayerPunchPaths04_HandHitPosPivotTrs,
        KB_PlayerPunchPaths0400_Hand_R_RootTrs;

    //■押し合い
    public Transform
        KB_PlayerHeadAreaCollisionSphereTrs,
        KB_PlayerRHandAreaCollisionSphereTrs,
        KB_PlayerLHandAreaCollisionSphereTrs;
    bool
        KB_BattleOshiaiBool = false;
    GameObject
        KB_OshiHand_R_RootObj,
        KB_OshiHand_L_RootObj,
        KB_OshiaiSliderObj;
    Slider
        KB_OshiaiSlider;


    #region 智恵理握るおもちゃ等の動作IKパスの親
    Transform
        KB_ChieriBattlePathsTrs,

        KB_PonyPathsTrs,
        KB_PonyPlayerFrontPivotTrs,
        KB_PonyOshiaiObjsTrs,
        KB_PonyOshiaiPivotTrs,

        KB_KaijuPathsTrs,
        KB_KaijuPlayerFrontPivotTrs,
        KB_KaijuOshiaiObjsTrs,
        KB_KaijuOshiaiPivotTrs,

        KB_ChieriRFootOshiaiPivotTrs;

    #endregion

    Transform //■ポインター
        KB_SeePointTrs;
    bool //LateUpdateでRayを飛ばす用
        KB_seeRayBool,
        KB_punchRayBool;
    RaycastHit
        KB_seeRayHit;
    LayerMask
        seeRayOshiaiLayerMask;

    //■パンチ用Ray変数
    Vector3
        KB_punchDir;
    Ray
        KB_punchRay;
    RaycastHit
        KB_punchRayHit = new RaycastHit();

    //パンチディレイタイム
    bool punchDelayBool;
    float punchDelayTimeCountFloat;
    public float punchDelayTimeFloat = 0.2f;

    public bool //オプションBool群
        KB_InputToggleModeBool;

    #endregion//■変数
    #region ■怪獣ぬいぐるみ小物変数
    //小物（箱オブジェ）
    GameObject KB_KomonoObjs;

    //■ポニー
    GameObject KB_PonyObj;
    Renderer KB_ponyRenderer;
    Material KB_ponyDefMaterial;
    Slider KB_ponyHPSlider;

    //■怪獣
    GameObject KB_KaijuObj;
    Renderer KB_kaijuRenderer;
    Material KB_kaijuDefMaterial;
    Slider KB_kaijuHPSlider;
    #endregion

    public GameObject tmpCopyObj, tmpPasteObj;
    bool tmpFixedObjPosCopy;
    //■メインシステムコルーチン
    IEnumerator KaijuBattleSystemLoad()
    {
        yield return null;
        #region 初期化
        //■怪獣バトルPrefabなければ生成
        if (GameObject.Find("EV_C_KaijuBattle") == null)
        {
            EV_C_KaijuBattle = Instantiate(Resources.Load("EventSystem/KaijuBattle/Prefab/EV_C_KaijuBattle") as GameObject);
            EV_C_KaijuBattle.transform.SetParent(EventObjectsTrs, false);
        }
        //編集用にすでに配置してある場合
        else { EV_C_KaijuBattle = GameObject.Find("EV_C_KaijuBattle"); }

        //■プレイヤーと智恵理 場所
        //なぜかforだとエラーが起きるのでforeach
        foreach (Transform x in EV_C_KaijuBattle.transform.Find("PlayerPosTrss").transform)
        { KB_PlayerPosTrssList.Add(x.transform); }
        foreach (Transform x in EV_C_KaijuBattle.transform.Find("ChieriStartPosTrss").transform)
        { KB_ChieriStartPosTrssList.Add(x.transform); }

        //■■プレイヤーパンチのIK用Pathオブジェを取得　VRカメラにペアレント
        KB_PlayerPunchPathsTrs = EV_C_KaijuBattle.transform.Find("PlayerPunchPaths").transform;
        KB_PlayerPunchPathsTrs.SetParent(VRCameraTrs, false);
        KB_PlayerPunchPathsTrs.localPosition =
        KB_PlayerPunchPathsTrs.localEulerAngles = Vector3.zero;
        //■特殊階層Trs群取得
        KB_PlayerPunchPaths00_StartHand_R_RootTrs = KB_PlayerPunchPathsTrs.GetChild(0).transform;
        KB_PlayerPunchPaths01_HitHand_R_RootTrs = KB_PlayerPunchPathsTrs.GetChild(1).transform;
        KB_PlayerPunchPaths0101_PunchHitPosTrs = KB_PlayerPunchPathsTrs.GetChild(1).GetChild(1).transform;
        KB_PlayerPunchPaths010100_BoxCastScaleTrs = KB_PlayerPunchPathsTrs.GetChild(1).GetChild(1).GetChild(0).transform;
        KB_PlayerPunchPaths04_HandHitPosPivotTrs = KB_PlayerPunchPathsTrs.GetChild(4).transform;
        KB_PlayerPunchPaths0400_Hand_R_RootTrs = KB_PlayerPunchPathsTrs.GetChild(4).GetChild(0).transform;
        //デフォルトのパンチ終着点を読み取っておく
        defPunchHitLocalPos = KB_PlayerPunchPaths01_HitHand_R_RootTrs.localPosition;
        //■パンチ可能Bool
        KB_punchEnabled = true;

        //■押し合い用オブジェ取得
        //■プレイヤー肩から手の範囲コリダー
        GameObject tmpRObj = Instantiate(Resources.Load("EventSystem/KaijuBattle/Prefab/KB_PlayerRHandAreaCollisionSphere") as GameObject, VRCameraTrs, false);
        KB_PlayerRHandAreaCollisionSphereTrs = tmpRObj.transform;
        GameObject tmpLObj = Instantiate(Resources.Load("EventSystem/KaijuBattle/Prefab/KB_PlayerLHandAreaCollisionSphere") as GameObject, VRCameraTrs, false);
        KB_PlayerLHandAreaCollisionSphereTrs = tmpLObj.transform;
        GameObject tmpHeadObj = Instantiate(Resources.Load("EventSystem/KaijuBattle/Prefab/KB_PlayerHeadAreaCollisionSphere") as GameObject, VRCameraTrs, false);
        KB_PlayerHeadAreaCollisionSphereTrs = tmpHeadObj.transform;

        KB_OshiHand_R_RootObj = EV_C_KaijuBattle.transform.Find("OshiaiHand_R_Root").gameObject;
        KB_OshiHand_L_RootObj = EV_C_KaijuBattle.transform.Find("OshiaiHand_L_Root").gameObject;
        KB_OshiaiSliderObj = Instantiate(Resources.Load("EventSystem/KaijuBattle/Prefab/OshiaiSlider") as GameObject, VRCameraTrs, false);
        KB_OshiaiSlider = KB_OshiaiSliderObj.GetComponent<Slider>();

        //一旦オフ
        KB_OshiaiSliderObj.SetActive(false);

        //■智恵理IKのPathオブジェ親を取得(階層が深いので注意)
        KB_ChieriBattlePathsTrs = EV_C_KaijuBattle.transform.Find("ChieriBattlePaths").transform;

        KB_PonyPathsTrs = KB_ChieriBattlePathsTrs.Find("PonyPaths").transform;
        KB_PonyOshiaiObjsTrs = KB_PonyPathsTrs.Find("PonyOshiaiObjs").transform;
        KB_PonyOshiaiPivotTrs = KB_PonyOshiaiObjsTrs.Find("PonyOshiaiPivot").transform;
        KB_PonyPlayerFrontPivotTrs = KB_PonyPathsTrs.Find("PonyPlayerFrontPivot").transform;


        KB_KaijuPathsTrs = KB_ChieriBattlePathsTrs.Find("KaijuPaths").transform;
        KB_KaijuOshiaiObjsTrs = KB_KaijuPathsTrs.Find("KaijuOshiaiObjs").transform;
        KB_KaijuOshiaiPivotTrs = KB_KaijuOshiaiObjsTrs.Find("KaijuOshiaiPivot").transform;
        KB_KaijuPlayerFrontPivotTrs = KB_KaijuPathsTrs.Find("KaijuPlayerFrontPivot").transform;

        KB_ChieriRFootOshiaiPivotTrs = GameObject.Find("ChieriRFootOshiaiPivot").transform;

        //■ポインター
        KB_SeePointTrs = EV_C_KaijuBattle.transform.Find("SeePoint").transform;
        KB_SeePointTrs.gameObject.SetActive(true);
        seeRayOshiaiLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            //(1 << LayerMask.NameToLayer("OshiaiColl")) +//OshiaiColl廃止（怪獣バトルはもうやってない　+　咥内用ライト設定用レイヤーに変えた）
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));


        //ダミーボディの表示非表示
        Dummy_Body.SetActive(false);
        Dummy_Hand.SetActive(true);

        //RayをLateで飛ばす用Bool
        KB_seeRayBool =
        KB_punchRayBool = true;

        //■終了処理用コルーチン起動(Boolをfalseで終了する)
        StartCoroutine(KaijuBattleSystemUnLoad());

        #endregion 初期化
        Debug.Log("怪獣バトルシステム初期化");
        #region ループ

        while (isKBSystem == true)
        {
            //■ポインタ(LateでRayが飛んでる)
            KB_SeePointTrs.position = KB_seeRayHit.point;
            KB_SeePointTrs.LookAt(PlayerTargetTrs, Vector3.forward);
            nearSizeAjust(KB_SeePointTrs, 8000);

            //■入力 トグルかホールドか
            if (AN_isInputToggleMode) { PlayerRLInputToggle(); }
            else { PlayerRLInput(); }

            #region//デバッグ
            ////位置読み取り
            //if (Input.GetKeyDown(KeyCode.P))
            //{ tmpFixedObjPosCopy = true; }

            #endregion//デバッグ

            #region パンチ操作
            if (KB_punchEnabled)
            {
                if (isRInputDown)
                {
                    #region //プレイヤーBipedアニメーション再生
                    //PlayerBipedAnimation
                    //    (
                    //    "player_座り指差し", 1f, 1,
                    //    new Vector3(-0.044f, -1.689f, -0.089f),
                    //    new Vector3(-0.694f, -3.584f, -1.117f)
                    //    );
                    #endregion
                    //パンチ
                    BattlePunch();
                }
            }
            #endregion

            //■パンチディレイカウント
            if (punchDelayBool)
            {
                punchDelayTimeCountFloat -= 1 * Time.deltaTime;
                if (punchDelayTimeCountFloat <= 0)
                {
                    punchDelayTimeCountFloat = punchDelayTimeFloat;
                    punchDelayBool = false;
                }
            }

            yield return null;
        }

        #endregion
    }
    IEnumerator KaijuBattleSystemUnLoad()
    {
        //初期化・終了処理用bool判定true さらにそれを利用して重複阻止
        if (isKBSystem == true) { yield break; }
        isKBSystem = true;
        //false（終了）になるまで待機
        while (isKBSystem) { yield return null; }

        //終了処理
        StopCoroutine(KBSystemLoadIEnum);
        KBSystemLoadIEnum = null;

        KB_BattleOshiaiBool = false;

        //■Tween系
        //パンチ再生中なら
        if (tmpBattlePunchIEnum != null)
        {
            //ディレイ終了後に来たら現在の動きキャンセル
            StopCoroutine(tmpBattlePunchIEnum); tmpBattlePunchIEnum = null;
            if (punchPosTweener != null) { punchPosTweener.Kill(); }
            if (punchRotTweener != null) { punchRotTweener.Kill(); }
        }
        ponyDamageBool =
        kaijuDamageBool = false;
        punchDelayTimeFloat = 0.2f;

        //押し合い再生中なら
        if (tmpBattleOshiaiIEnum != null)
        {
            KB_ROshiCollEnterBool =
            KB_LOshiCollEnterBool =
            KB_OshiHandAreaRayBool = false;
            KB_ROshiEnterCollision =
            KB_LOshiEnterCollision = null;
            KB_OshiRHandAreaRay =
            KB_OshiLHandAreaRay = new Ray();
            KB_OshiRHandAreaRayHit =
            KB_OshiLHandAreaRayHit = new RaycastHit();
        }

        KB_HeadEnterBool = false;

        //プレイヤーIKHandTarget取り出し
        PlayerIKRHandTargetTrs.SetParent(TargetsTrs, false);
        PlayerIKLHandTargetTrs.SetParent(TargetsTrs, false);
        PlayerIKRHandTargetTrs.position =
        PlayerIKLHandTargetTrs.position =
        PlayerIKRHandTargetTrs.localEulerAngles =
        PlayerIKLHandTargetTrs.localEulerAngles = Vector3.zero;
        PlayerIKRHandTargetTrs.localScale =
        PlayerIKLHandTargetTrs.localScale = Vector3.one;

        //プレイヤーIK手設定
        PlayerIKRHandEf.positionWeight = 0;
        PlayerIKLHandEf.positionWeight = 0;
        PlayerIKRHandEf.rotationWeight = 0;
        PlayerIKLHandEf.rotationWeight = 0;

        //ダミーボディの表示非表示
        if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }
        if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); }

        //■オブジェ群
        Destroy(KB_PlayerHeadAreaCollisionSphereTrs.gameObject);
        Destroy(KB_PlayerRHandAreaCollisionSphereTrs.gameObject);
        Destroy(KB_PlayerLHandAreaCollisionSphereTrs.gameObject);
        Destroy(KB_OshiHand_R_RootObj);
        Destroy(KB_OshiHand_L_RootObj);
        Destroy(KB_OshiaiSliderObj);
        Destroy(KB_PlayerPunchPathsTrs.gameObject);

        Destroy(EV_C_KaijuBattle);

        Debug.Log("怪獣バトルシステム終了処理完了");

        yield break;
    }

    #region プレイヤーバトル用パンチ
    //キャンセル用変数
    IEnumerator tmpBattlePunchIEnum;
    Tweener punchPosTweener, punchRotTweener;
    Vector3 defPunchHitLocalPos;

    void BattlePunch()
    {
        //再生中に来たら
        if (tmpBattlePunchIEnum != null)
        {
            //ディレイ終了前に来たら何もせず終了
            if (punchDelayBool) { return; }

            //ディレイ終了後に来たら現在の動きキャンセル
            StopCoroutine(tmpBattlePunchIEnum); tmpBattlePunchIEnum = null;
            if (punchPosTweener != null) { punchPosTweener.Kill(); }
            if (punchRotTweener != null) { punchRotTweener.Kill(); }
        }
        //パンチディレイ開始
        punchDelayBool = true;

        //コルーチンに変数入れて再生
        StartCoroutine(tmpBattlePunchIEnum = BattlePunchCor());
    }
    IEnumerator BattlePunchCor()
    {
        #region パンチ動作準備

        //IKオン
        PlayerIKRHandEf.positionWeight = 1;
        PlayerIKRHandEf.rotationWeight = 1;

        //TrsからV3リスト作成
        List<Vector3> pathLclPosList = new List<Vector3>();
        List<Quaternion> pathLclRotList = new List<Quaternion>();
        //■一個目は開始位置なので当てはめたら消す
        foreach (Transform x in KB_PlayerPunchPathsTrs)
        {
            pathLclPosList.Add(x.transform.localPosition);
            pathLclRotList.Add(x.transform.localRotation);
        }
        //プレイヤー右手のIKターゲットをVRカメラにペアレント ↑リスト0位置へ
        PlayerIKRHandTargetTrs.SetParent(VRCameraTrs);
        PlayerIKRHandTargetTrs.localPosition = pathLclPosList[0];
        PlayerIKRHandTargetTrs.localRotation = pathLclRotList[0];
        //一個目削除
        pathLclPosList.RemoveAt(0);
        pathLclRotList.RemoveAt(0);

        #endregion

        #region パンチ動作
        SEPlay("punch-swing1", PlayerIKRHandTargetTrs.gameObject);

        punchPosTweener
            = PlayerIKRHandTargetTrs.DOLocalMove(pathLclPosList[0], 0.2f).SetEase(Ease.OutBack);
        punchRotTweener
            = PlayerIKRHandTargetTrs.DOLocalRotateQuaternion(pathLclRotList[0], 0.2f).SetEase(Ease.OutBack);

        #region ■パンチ中に当たることになったら当てる
        float tmpTimeCount = 0;
        KB_punchRayHit = new RaycastHit();
        while (tmpTimeCount < 0.2f)
        {
            tmpTimeCount += 1 * Time.deltaTime;
            //まだ当たってなかったら Ray打つ
            if (KB_punchRayHit.collider == false)
            {
                //当たるかどうかRay（RayはFixedにある）(パンチスタート地点からパンチ終着点の"子の"手先オブジェに向けてのRay)
                KB_punchDir =
                    (KB_PlayerPunchPaths0101_PunchHitPosTrs.position
                    - KB_PlayerPunchPaths00_StartHand_R_RootTrs.position)
                    .normalized;
                KB_punchRay = new Ray(KB_PlayerPunchPaths00_StartHand_R_RootTrs.position, KB_punchDir);

                //Fixedで発射
                KB_punchRayBool = true;
            }
            //当たり距離にコリダー入ったら
            else if (KB_punchRayHit.collider == true)
            {
                //なにかしら当たったならパンチの着地点をその位置に移動
                //ヒット用ピボットオブジェを着地点に置いて
                KB_PlayerPunchPaths04_HandHitPosPivotTrs.position = KB_punchRayHit.point;

                //■その"子"の位置をパスの着地点にして、残り時間でTween
                punchPosTweener.Kill();
                punchPosTweener
                    = PlayerIKRHandTargetTrs.DOMove(KB_PlayerPunchPaths0400_Hand_R_RootTrs.position, 0.2f - tmpTimeCount).SetEase(Ease.OutBack);
                //ダメージ判定送信
                Debug.Log("パンチ当たった" + KB_punchRayHit.collider.name);
                BattlePunchHit(KB_punchRayHit.collider);
                //Tweener待ち
                yield return new WaitForSeconds(0.2f - tmpTimeCount);
                tmpTimeCount = 0.2f;
            }
            yield return null;
        }
        #endregion
        if (KB_punchRayHit.collider == false) { Debug.Log("パンチはずれ"); }

        #region ■パンチ後 手押されたら移動（パンチ距離に物体入ったら）
        tmpTimeCount = 0;
        KB_punchRayHit = new RaycastHit();
        while (tmpTimeCount < 0.1f)
        {
            tmpTimeCount += 1 * Time.deltaTime;

            //当たるかどうかRayと一緒（RayはFixedにある）(パンチスタート地点からパンチ終着点の"子の"手先オブジェに向けてのRay)
            KB_punchDir =
                (KB_PlayerPunchPaths0101_PunchHitPosTrs.position
                - KB_PlayerPunchPaths00_StartHand_R_RootTrs.position)
                .normalized;
            KB_punchRay = new Ray(KB_PlayerPunchPaths00_StartHand_R_RootTrs.position, KB_punchDir);

            //Fixedで発射
            KB_punchRayBool = true;
            //当たり距離にコリダー入ってたら
            if (KB_punchRayHit.collider == true)
            {
                //ヒット用ピボットオブジェを着地点に置いて
                KB_PlayerPunchPaths04_HandHitPosPivotTrs.position = KB_punchRayHit.point;

                //■その"子"（ピボット）の位置に
                PlayerIKRHandTargetTrs.position = KB_PlayerPunchPaths0400_Hand_R_RootTrs.position;

                //ヒット情報消し
                KB_punchRayHit = new RaycastHit();
            }
            yield return null;
        }
        #endregion

        //手戻し
        punchPosTweener
            = PlayerIKRHandTargetTrs.DOLocalMove(pathLclPosList[1], 0.5f).SetEase(Ease.InSine);
        punchRotTweener
            = PlayerIKRHandTargetTrs.DOLocalRotateQuaternion(pathLclRotList[1], 0.5f).SetEase(Ease.InSine);
        yield return new WaitForSeconds(0.5f);

        punchPosTweener
            = PlayerIKRHandTargetTrs.DOLocalMove(pathLclPosList[2], 0.5f).SetEase(Ease.OutSine);
        punchRotTweener
            = PlayerIKRHandTargetTrs.DOLocalRotateQuaternion(pathLclRotList[2], 0.5f).SetEase(Ease.OutSine);
        yield return new WaitForSeconds(0.5f);

        #endregion

        //終了
        PlayerIKRHandTargetTrs.SetParent(GirlIKTargetsTrs);
        PlayerIKRHandEf.positionWeight = 0;
        PlayerIKRHandEf.rotationWeight = 0;

        yield break;
    }
    public void BattlePunchHit(Collider coll)
    {
        //ポニー
        if (coll.gameObject.name == "BattlePony_Collider")
        { StartCoroutine(PonyDamage()); }
        //怪獣バジラ
        else if (coll.gameObject.name == "Kaiju_Collider")
        { StartCoroutine(KaijuDamage()); }
        //それ以外
        else { SEPlay("soccer-ball1", PlayerIKRHandTargetTrs.gameObject); }
    }
    #endregion

    #region ダメージ群
    IEnumerator KB_PlayerDamage()
    {
        KB_punchEnabled = false;
        SEPlay("punch-high2");

        Vector3
            tmpDefCameraPos = CameraAnchorTrs.localPosition,
            tmpDefCameraEul = CameraAnchorTrs.localEulerAngles,
            tmpFlowCameraPos = new Vector3(0, 1.2f, 0),
            tmpSlipCameraPos = new Vector3(0, 0.3f, 0),
            tmpSlipCameraEul = new Vector3(-45, 0, 0);

        CameraAnchorTrs.DOLocalMove(tmpFlowCameraPos, 0.05f);
        yield return new WaitForSeconds(0.05f);
        CameraAnchorTrs.DOLocalMove(tmpSlipCameraPos, 0.5f).SetEase(Ease.OutBounce);
        yield return new WaitForSeconds(0.05f);
        CameraAnchorTrs.DOLocalMove(tmpDefCameraPos, 0.05f);
        yield return new WaitForSeconds(0.05f);
        SEPlay("足音1_footsteps_shoe_grass_walk_03");

        CameraAnchorTrs.DOLocalMove(tmpSlipCameraPos, 0.5f).SetEase(Ease.OutBounce);
        CameraAnchorTrs.DOLocalRotate(tmpSlipCameraEul, 0.2f).SetEase(Ease.InSine);

        yield return new WaitForSeconds(3f);
        CameraAnchorTrs.DOLocalMove(tmpDefCameraPos, 0.3f);
        CameraAnchorTrs.DOLocalRotate(tmpDefCameraEul, 0.1f);

        KB_punchEnabled = true;
        KB_HeadEnterBool = false;

    }

    bool ponyDamageBool;
    IEnumerator PonyDamage()
    {
        if (ponyDamageBool) { yield break; }
        ponyDamageBool = true;
        SEPlay(UISEObj, "punch-middle2", KB_PonyObj, 0.5f);
        Material damageMat = Instantiate(Resources.Load("EventSystem/KaijuBattle/Mat/damageRed") as Material);

        KB_ponyRenderer.material = damageMat;
        KB_ponyHPSlider.value--;
        yield return new WaitForSeconds(0.05f);
        KB_ponyRenderer.material = KB_ponyDefMaterial;

        if (KB_ponyHPSlider.value <= 0)
        {
            //ポニー倒し 
        }

        ponyDamageBool = false;
        yield break;
    }
    bool kaijuDamageBool;
    IEnumerator KaijuDamage()
    {
        if (kaijuDamageBool) { yield break; }
        kaijuDamageBool = true;
        SEPlay(UISEObj, "punch-middle2", KB_KaijuObj, 0.5f);
        Material damageMat = Instantiate(Resources.Load("EventSystem/KaijuBattle/Mat/damageRed") as Material);

        KB_kaijuRenderer.material = damageMat;
        KB_kaijuHPSlider.value--;
        yield return new WaitForSeconds(0.05f);
        KB_kaijuRenderer.material = KB_kaijuDefMaterial;

        if (KB_kaijuHPSlider.value <= 0)
        {
            //怪獣倒し 
        }

        kaijuDamageBool = false;
        yield break;
    }
    #endregion

    #region プレイヤーバトル用押し合い
    //キャンセル用変数
    IEnumerator tmpBattleOshiaiIEnum;
    void BattleOshiai(Transform OshiaiPivotTrs, Transform IKTargetTrs)
    {
        //再生中に来たらキャンセル
        if (tmpBattleOshiaiIEnum != null)
        { StopCoroutine(tmpBattleOshiaiIEnum); tmpBattleOshiaiIEnum = null; }
        KB_BattleOshiaiBool = true;

        //コルーチンに変数入れて再生
        StartCoroutine(tmpBattleOshiaiIEnum = BattleOshiaiCor(OshiaiPivotTrs, IKTargetTrs));
        Debug.Log("押し合い開始");
    }
    void BattleAshiuraOshiai()
    {
        //再生中に来たらキャンセル
        if (tmpBattleOshiaiIEnum != null)
        { StopCoroutine(tmpBattleOshiaiIEnum); tmpBattleOshiaiIEnum = null; }
        KB_BattleOshiaiBool = true;

        //コルーチンに変数入れて再生
        StartCoroutine(tmpBattleOshiaiIEnum = BattleAshiuraOshiaiCor());
        Debug.Log("足裏押し合い開始");
    }

    bool
        KB_ROshiCollEnterBool,
        KB_LOshiCollEnterBool;
    Collision
        KB_ROshiEnterCollision,
        KB_LOshiEnterCollision;
    Ray
        KB_OshiRHandAreaRay,
        KB_OshiLHandAreaRay;
    RaycastHit
        KB_OshiRHandAreaRayHit,
        KB_OshiLHandAreaRayHit;
    bool
        KB_OshiHandAreaRayBool;

    IEnumerator BattleOshiaiCor(Transform OshiaiPivotTrs, Transform GirlIKTargetTrs)
    {
        #region 引数解説
        //押し合いの基準点 これがプレイヤー位置へ移動することで全てを動かす
        //Transform OshiaiPivotTrs

        //智恵理のIKターゲット
        //Transform IKTargetTrs

        //■動作解説
        //OshiaiPivotTrsが動く。
        //追従してIKRootObj（と、押し合うオブジェの位置確認用サンプルObj）が動く。
        //IKRootObjに追従してIKターゲットObjが動く。
        //IKで動く手や足に押し合うコリダーのObj本体がある。
        //ので
        //OshiaiPivotTrsが動くことで全部がまとめて動く
        #endregion

        #region 初期化

        GameObject //IKターゲットを追従させるRootObj（消えるとまずいのでペアレントしない）
            IKRootObj = OshiaiPivotTrs.GetChild(0).gameObject;

        Vector3 //後で元の位置に戻す用
            tmpOshiaiPivotTrsDefPosition = OshiaiPivotTrs.position;

        //始まる前に触れてた場合用に
        KB_ROshiCollEnterBool = false;
        KB_LOshiCollEnterBool = false;

        bool //押し合い開始までの判定
            tmpROshiEnterRunBool = false,
            tmpLOshiEnterRunBool = false,
            tmpAllOshiEnterWhileBool = false;

        Vector3 //押し合うコリダーと手のエリア接触点と方向
            tmpRContactPoint = new Vector3(),
            tmpLContactPoint = new Vector3(),
            tmpRContactNormal = new Vector3(),
            tmpLContactNormal = new Vector3();

        //スライダー表示ON
        KB_OshiaiSlider.value = KB_OshiaiSlider.maxValue;
        KB_OshiaiSliderObj.SetActive(true);
        #endregion

        //■IKターゲット初期位置へ移動
        GirlIKTargetTrs.position = IKRootObj.transform.position;
        GirlIKTargetTrs.rotation = IKRootObj.transform.rotation;

        //●FinalIK ON（IK大元のウェイト量なので個別になる）
        if (GirlIKTargetTrs == IKLHandTargetTrs)
        {
            DOTweenToIKEfPos(IKLHandEf, 1, 1);
            DOTweenToIKEfRot(IKLHandEf, 1, 1);

            yield return new WaitForSeconds(1f);
        }


        #region 押し合い範囲まで移動ループし、侵入したら取得
        while (tmpAllOshiEnterWhileBool == false)
        {
            //■OshiaiPivotTrs、プレイヤーへ移動
            Vector3 direction = VRCameraTrs.position - OshiaiPivotTrs.position;
            direction = direction.normalized;
            OshiaiPivotTrs.Translate(
                direction
                * 0.4f
                * Time.deltaTime * GameObjectsTrs.localScale.z,
                Space.World);
            //↑に合わせてIK追従
            GirlIKTargetTrs.position = IKRootObj.transform.position;
            GirlIKTargetTrs.rotation = IKRootObj.transform.rotation;

            //■コリジョン範囲侵入位置と方向取得
            if (KB_ROshiCollEnterBool)
            {
                if (tmpROshiEnterRunBool == false)
                {
                    //（複数ひっかかって思わぬところに手がいくかもなので、その場合は視点に一番近い場所を抽出する形にする予定
                    foreach (ContactPoint contact in KB_ROshiEnterCollision.contacts)
                    {
                        Debug.Log(KB_ROshiEnterCollision.collider.name + "R ぶつかった箇所数" + KB_ROshiEnterCollision.contacts.Length);

                        tmpRContactPoint = contact.point;
                        tmpRContactNormal = contact.normal;
                    }

                    tmpROshiEnterRunBool = true;
                }
            }

            if (KB_LOshiCollEnterBool)
            {
                if (tmpLOshiEnterRunBool == false)
                {
                    foreach (ContactPoint contact in KB_LOshiEnterCollision.contacts)
                    {
                        Debug.Log(KB_LOshiEnterCollision.collider.name + "L ぶつかった箇所数" + KB_LOshiEnterCollision.contacts.Length);

                        tmpLContactPoint = contact.point;
                        tmpLContactNormal = contact.normal;
                    }
                    tmpLOshiEnterRunBool = true;
                }
            }

            //■両方範囲に入ったらループ終了
            if (KB_ROshiCollEnterBool && KB_LOshiCollEnterBool) { tmpAllOshiEnterWhileBool = true; }

            yield return null;
        }
        #endregion

        #region 範囲中心から侵入点へRay（プレイヤー手RootObjにプレイヤーIKをペアレントしRay衝突点へ配置）

        KB_OshiRHandAreaRay = new Ray(KB_PlayerRHandAreaCollisionSphereTrs.position, tmpRContactNormal * -1);
        KB_OshiLHandAreaRay = new Ray(KB_PlayerLHandAreaCollisionSphereTrs.position, tmpLContactNormal * -1);

        //手rootセット
        KB_OshiHand_R_RootObj.transform.SetParent(KB_ROshiEnterCollision.collider.transform);
        KB_OshiHand_L_RootObj.transform.SetParent(KB_ROshiEnterCollision.collider.transform);

        //Ray発射用Bool（FixedUpdateにある）
        KB_OshiHandAreaRayBool = true;
        //Ray待ち
        while (KB_OshiHandAreaRayBool) { yield return null; }
        #endregion

        #region 押し合い位置が決定されたのでプレイヤー手IKONし、組み合うまでループ
        PlayerIKRHandTargetTrs.SetParent(KB_OshiHand_R_RootObj.transform.GetChild(0));
        PlayerIKLHandTargetTrs.SetParent(KB_OshiHand_L_RootObj.transform.GetChild(0));
        DOTweenToIKEfPos(PlayerIKRHandEf, 1, 0.1f);
        DOTweenToIKEfRot(PlayerIKRHandEf, 1, 0.1f);
        DOTweenToIKEfPos(PlayerIKLHandEf, 1, 0.1f);
        DOTweenToIKEfRot(PlayerIKLHandEf, 1, 0.1f);
        PlayerIKRHandTargetTrs.localPosition = PlayerIKRHandTargetTrs.localEulerAngles =
        PlayerIKLHandTargetTrs.localPosition = PlayerIKLHandTargetTrs.localEulerAngles = Vector3.zero;
        PlayerMotion("登りパー", 0.1f, 2);
        PlayerMotion("登りパー", 0.1f, 3);

        Vector3
            oshiaiStartPoint = OshiaiPivotTrs.position,
            oshiaiEndPoint = VRCameraTrs.position;

        while (PlayerIKRHandEf.positionWeight != 1)
        {
            //方向取り
            Vector3 direction = VRCameraTrs.position - OshiaiPivotTrs.position;
            //ノーマライズ
            direction = direction.normalized;
            //移動
            OshiaiPivotTrs.Translate(
                direction
                * 0.4f
                * Time.deltaTime * GameObjectsTrs.localScale.z,
                Space.World);
            //智恵理IK追従
            GirlIKTargetTrs.position = IKRootObj.transform.position;
            GirlIKTargetTrs.rotation = IKRootObj.transform.rotation;

            yield return null;
        }
        #endregion

        SEPlay(UISEObj, "punch-high1");

        //ゲージ現在位置で反映（現在距離÷最長距離で割合出る）
        KB_OshiaiSlider.value =
            Vector3.Distance(OshiaiPivotTrs.position, oshiaiEndPoint)
            /
            Vector3.Distance(oshiaiStartPoint, oshiaiEndPoint);

        #region 押し合いループ
        while (KB_BattleOshiaiBool)
        {
            //0~1（スライダーのValue）で動く
            OshiaiPivotTrs.position = Vector3.Lerp(oshiaiEndPoint, oshiaiStartPoint, KB_OshiaiSlider.value);
            //それに智恵理IK追従する
            GirlIKTargetTrs.position = IKRootObj.transform.position;
            GirlIKTargetTrs.rotation = IKRootObj.transform.rotation;

            //押され力調整
            KB_OshiaiSlider.value -= UnityEngine.Random.Range(-0.4f, 1f) * Time.deltaTime;

            if (isRInputDown)
            {
                //押し力
                KB_OshiaiSlider.value += 0.07f;
            }


            yield return null;
        }
        #endregion

        #region ■終了処理
        //FinalIKの動作自体の終了なので、個別
        if (GirlIKTargetTrs == IKLHandTargetTrs)
        {
            DOTweenToIKEfPos(IKLHandEf, 0, 1);
            DOTweenToIKEfRot(IKLHandEf, 0, 1);
        }

        //ピボット元位置へ
        OshiaiPivotTrs.position = tmpOshiaiPivotTrsDefPosition;

        //Bool
        KB_ROshiCollEnterBool = KB_LOshiCollEnterBool = false;
        //スライダー
        KB_OshiaiSliderObj.SetActive(false);

        //プレイヤー手戻し
        DOTweenToIKEfPos(PlayerIKRHandEf, 0, 0.5f);
        DOTweenToIKEfRot(PlayerIKRHandEf, 0, 0.5f);
        DOTweenToIKEfPos(PlayerIKLHandEf, 0, 0.5f);
        DOTweenToIKEfRot(PlayerIKLHandEf, 0, 0.5f);
        yield return new WaitForSeconds(0.5f);
        PlayerIKRHandTargetTrs.SetParent(TargetsTrs, true);
        PlayerIKLHandTargetTrs.SetParent(TargetsTrs, true);
        PlayerMotion("登りグー", 0.1f, 2);
        PlayerMotion("登りグー", 0.1f, 3);

        //プレイヤー手のRootObj戻し
        KB_OshiHand_R_RootObj.transform.SetParent(EV_C_KaijuBattle.transform);
        KB_OshiHand_L_RootObj.transform.SetParent(EV_C_KaijuBattle.transform);
        KB_OshiHand_R_RootObj.transform.localPosition =
        KB_OshiHand_R_RootObj.transform.localEulerAngles =
        KB_OshiHand_L_RootObj.transform.localPosition =
        KB_OshiHand_L_RootObj.transform.localEulerAngles = Vector3.zero;
        KB_OshiHand_R_RootObj.transform.localScale =
        KB_OshiHand_L_RootObj.transform.localScale = Vector3.one;

        #endregion

        Debug.Log("押し合いおわり");
    }
    IEnumerator BattleAshiuraOshiaiCor()
    {
        #region 初期化
        //始まる前に触れてた場合用に
        KB_ROshiCollEnterBool = false;
        KB_LOshiCollEnterBool = false;

        bool //押し合い開始までの判定
            tmpROshiEnterRunBool = false,
            tmpLOshiEnterRunBool = false,
            tmpAllOshiEnterWhileBool = false;

        Vector3 //押し合うコリダーと手のエリア接触点と方向
            tmpRContactPoint = new Vector3(),
            tmpLContactPoint = new Vector3(),
            tmpRContactNormal = new Vector3(),
            tmpLContactNormal = new Vector3();

        //スライダー表示ON
        KB_OshiaiSlider.value = KB_OshiaiSlider.maxValue;
        KB_OshiaiSliderObj.SetActive(true);
        #endregion


        #region 足裏が押し合い範囲まで侵入したら取得
        while (tmpAllOshiEnterWhileBool == false)
        {
            //■コリジョン範囲侵入位置と方向取得
            if (KB_ROshiCollEnterBool)
            {
                if (tmpROshiEnterRunBool == false)
                {
                    //（複数ひっかかって思わぬところに手がいくかもなので、その場合は視点に一番近い場所を抽出する形にする予定
                    foreach (ContactPoint contact in KB_ROshiEnterCollision.contacts)
                    {
                        Debug.Log(KB_ROshiEnterCollision.collider.name + "R ぶつかった箇所数" + KB_ROshiEnterCollision.contacts.Length);

                        tmpRContactPoint = contact.point;
                        tmpRContactNormal = contact.normal;
                    }
                    tmpROshiEnterRunBool = true;
                }
            }

            if (KB_LOshiCollEnterBool)
            {
                if (tmpLOshiEnterRunBool == false)
                {
                    foreach (ContactPoint contact in KB_LOshiEnterCollision.contacts)
                    {
                        Debug.Log(KB_LOshiEnterCollision.collider.name + "L ぶつかった箇所数" + KB_LOshiEnterCollision.contacts.Length);

                        tmpLContactPoint = contact.point;
                        tmpLContactNormal = contact.normal;
                    }
                    tmpLOshiEnterRunBool = true;
                }
            }

            //■両方範囲に入ったらループ終了
            if (KB_ROshiCollEnterBool && KB_LOshiCollEnterBool) { tmpAllOshiEnterWhileBool = true; }

            yield return null;
        }
        #endregion

        #region 範囲中心から侵入点へRay（プレイヤー手RootObjにプレイヤーIKをペアレントしRay衝突点へ配置）

        KB_OshiRHandAreaRay = new Ray(KB_PlayerRHandAreaCollisionSphereTrs.position, tmpRContactNormal * -1);
        KB_OshiLHandAreaRay = new Ray(KB_PlayerLHandAreaCollisionSphereTrs.position, tmpLContactNormal * -1);

        //手rootセット
        KB_OshiHand_R_RootObj.transform.SetParent(KB_ROshiEnterCollision.collider.transform);
        KB_OshiHand_L_RootObj.transform.SetParent(KB_ROshiEnterCollision.collider.transform);

        //Ray発射用Bool（FixedUpdateにある）
        KB_OshiHandAreaRayBool = true;
        //Ray待ち
        while (KB_OshiHandAreaRayBool) { yield return null; }
        #endregion

        #region 押し合い位置が決定されたのでプレイヤー手IKONし、組み合うまで待つ
        PlayerIKRHandTargetTrs.SetParent(KB_OshiHand_R_RootObj.transform.GetChild(0));
        PlayerIKLHandTargetTrs.SetParent(KB_OshiHand_L_RootObj.transform.GetChild(0));
        DOTweenToIKEfPos(PlayerIKRHandEf, 1, 0.1f);
        DOTweenToIKEfRot(PlayerIKRHandEf, 1, 0.1f);
        DOTweenToIKEfPos(PlayerIKLHandEf, 1, 0.1f);
        DOTweenToIKEfRot(PlayerIKLHandEf, 1, 0.1f);
        PlayerIKRHandTargetTrs.localPosition = PlayerIKRHandTargetTrs.localEulerAngles =
        PlayerIKLHandTargetTrs.localPosition = PlayerIKLHandTargetTrs.localEulerAngles = Vector3.zero;
        PlayerMotion("登りパー", 0.1f, 2);
        PlayerMotion("登りパー", 0.1f, 3);

        AnimatorStateInfo
            tmpAnimInfo = girlAnim.GetCurrentAnimatorStateInfo(0);
        float
            oshiaiStartTime = tmpAnimInfo.normalizedTime,
            oshiaiEndTime = 1;

        while (PlayerIKRHandEf.positionWeight != 1)
        {
            yield return null;
        }
        #endregion

        SEPlay(UISEObj, "punch-high1");

        //ゲージ現在位置で反映（現在距離÷最長距離で割合出る）
        KB_OshiaiSlider.value =
            (oshiaiEndTime - tmpAnimInfo.normalizedTime)
            /
            (oshiaiEndTime - oshiaiStartTime);

        #region 押し合いループ

        float tmpPower = 0.1f;
        while (KB_BattleOshiaiBool)
        {
            if (Input.GetKeyDown(KeyCode.J)) { Debug.Log(girlAnim.GetCurrentAnimatorStateInfo(0).normalizedTime); }
            //■アニメ押し合い開始位置を0、最後を1とする計算をして 0~1のValueをノーマライズドTimeに当てはめる
            girlAnim.Play(tmpAnimInfo.shortNameHash, 0,
                //1=Start 0=endの式
                1 - ((1 - oshiaiStartTime) * KB_OshiaiSlider.value));
            //1=End 0=Startの式
            //(1 - oshiaiStartTime) * KB_OshiaiSlider.value + oshiaiStartTime);

            //■押すと弱まるのみ
            if (isRInputDown)
            {
                if (tmpPower >= 0f)
                {
                    tmpPower -= 0.1f;
                    //少しでも+にならないようにする
                    if (tmpPower <= 0f)
                    {
                        tmpPower = 0;
                    }
                }
            }
            //押さないと戻る
            else
            {
                if (tmpPower < 0.1f)
                { tmpPower += 0.01f; }
            }

            KB_OshiaiSlider.value -= tmpPower * Time.deltaTime;

            yield return null;
        }
        #endregion

        #region ■終了処理

        //Bool
        KB_ROshiCollEnterBool = KB_LOshiCollEnterBool = false;
        //スライダー
        KB_OshiaiSliderObj.SetActive(false);

        //プレイヤー手戻し
        DOTweenToIKEfPos(PlayerIKRHandEf, 0, 0.5f);
        DOTweenToIKEfRot(PlayerIKRHandEf, 0, 0.5f);
        DOTweenToIKEfPos(PlayerIKLHandEf, 0, 0.5f);
        DOTweenToIKEfRot(PlayerIKLHandEf, 0, 0.5f);
        yield return new WaitForSeconds(0.5f);
        PlayerIKRHandTargetTrs.SetParent(TargetsTrs, true);
        PlayerIKLHandTargetTrs.SetParent(TargetsTrs, true);
        PlayerMotion("登りグー", 0.1f, 2);
        PlayerMotion("登りグー", 0.1f, 3);

        //プレイヤー手のRootObj戻し
        KB_OshiHand_R_RootObj.transform.SetParent(EV_C_KaijuBattle.transform);
        KB_OshiHand_L_RootObj.transform.SetParent(EV_C_KaijuBattle.transform);
        KB_OshiHand_R_RootObj.transform.localPosition =
        KB_OshiHand_R_RootObj.transform.localEulerAngles =
        KB_OshiHand_L_RootObj.transform.localPosition =
        KB_OshiHand_L_RootObj.transform.localEulerAngles = Vector3.zero;
        KB_OshiHand_R_RootObj.transform.localScale =
        KB_OshiHand_L_RootObj.transform.localScale = Vector3.one;

        #endregion

        Debug.Log("足裏押し合いおわり");
    }
    public void KB_RHandAreaCollisionEnter(Collision collision)
    {
        if (KB_ROshiCollEnterBool == false && collision.gameObject.name == "BattlePony_Collider")
        {
            KB_ROshiEnterCollision = collision;
            KB_ROshiCollEnterBool = true;
        }
        if (KB_ROshiCollEnterBool == false && collision.gameObject.name == "Kaiju_Collider")
        {
            KB_ROshiEnterCollision = collision;
            KB_ROshiCollEnterBool = true;
        }

        if (KB_ROshiCollEnterBool == false && collision.collider == KB_Tsumasaki_R_Collider)
        {
            KB_ROshiEnterCollision = collision;
            KB_ROshiCollEnterBool = true;
        }

        if (collision.collider == KB_Tsumasaki_R_Collider)
        {
            Debug.Log("Ratari");
        }

    }
    public void KB_LHandAreaCollisionEnter(Collision collision)
    {
        if (KB_LOshiCollEnterBool == false && collision.gameObject.name == "BattlePony_Collider")
        {
            KB_LOshiEnterCollision = collision;
            KB_LOshiCollEnterBool = true;
        }
        if (KB_LOshiCollEnterBool == false && collision.gameObject.name == "Kaiju_Collider")
        {
            KB_LOshiEnterCollision = collision;
            KB_LOshiCollEnterBool = true;
        }

        if (KB_LOshiCollEnterBool == false && collision.collider == KB_Tsumasaki_R_Collider)
        {
            KB_LOshiEnterCollision = collision;
            KB_LOshiCollEnterBool = true;
        }

        if (collision.collider == KB_Tsumasaki_R_Collider)
        {
            Debug.Log("Latari");
        }

    }
    #endregion

    #region 智恵理バトル用Path再生メソッド
    //キャンセル用変数
    IEnumerator KB_nowChieriPathMotionIEnum;
    Tweener KB_nowChieriPosTweener, KB_nowChieriRotTweener;
    //Pathのリスト
    List<Vector3> KB_nowChieriPathPosList = new List<Vector3>();
    List<Quaternion> KB_nowChieriPathRotList = new List<Quaternion>();

    //■Pathリスト更新メソッド（更新するだけ、再生まで行わない）
    void KB_NowChieriPathLoad(string PathsTrsName)
    {
        //再生中に来たら再生中のをキャンセル
        if (KB_nowChieriPathMotionIEnum != null)
        {
            StopCoroutine(KB_nowChieriPathMotionIEnum); KB_nowChieriPathMotionIEnum = null;
            if (KB_nowChieriPosTweener != null) { KB_nowChieriPosTweener.Kill(); }
            if (KB_nowChieriRotTweener != null) { KB_nowChieriRotTweener.Kill(); }

            #region その他キャンセル時に戻すもの（智恵理表情や顔目の向きなど）
            FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
            FollowDOMove(IKLookAtHeadTargetTrs, PlayerHeadTargetTrs);
            DOTweenToLAIKSEyes(LAIKEyeS, LAIKSEyesDefWeight, 1);
            DOTweenToLAIKSHead(LAIKHeadS, LAIKSHeadDefWeight, 1);
            ChieriMotion("キリッ", 0.3f, 2, 0);
            #endregion
        }

        //■TrsからV3リスト作成
        //まずクリア
        KB_nowChieriPathPosList.Clear();
        KB_nowChieriPathRotList.Clear();


        Transform PathsTrs = null;
        //ポニーにあるかないか
        if (KB_PonyPathsTrs.Find(PathsTrsName) != null)
        { PathsTrs = KB_PonyPathsTrs.Find(PathsTrsName); }
        //では怪獣バジラにあるかないか
        else if (KB_KaijuPathsTrs.Find(PathsTrsName) != null)
        { PathsTrs = KB_KaijuPathsTrs.Find(PathsTrsName); }

        foreach (Transform x in PathsTrs)
        {
            KB_nowChieriPathPosList.Add(x.transform.position);
            KB_nowChieriPathRotList.Add(x.transform.rotation);
        }
    }

    #region 更新したPathリストで個別モーション コルーチン群
    IEnumerator KB_PonyTackleCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speedを参照して、ゆっくりにできる予定（難易度変わるからいらないかも）;

        Hukidashi("C3110");//そーれ

        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 1; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }


        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);

        number = 2; time = 1; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("f_口開き笑顔", 0.1f, 2, 0);

        number = 0; time = 1; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("笑顔01口眉_目閉じない", 0.1f, 2, 0);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_PonyRTackleCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speedを参照して、ゆっくりにできる予定（難易度変わるからいらないかも）;

        Hukidashi("C3110");//そーれ

        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 1; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }


        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);

        number = 2; time = 1; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("f_口開き笑顔", 0.1f, 2, 0);

        number = 3; time = 1; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);


        number = 0; time = 1; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("笑顔01口眉_目閉じない", 0.1f, 2, 0);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_PonyAimTackleCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speedを参照して、ゆっくりにできる予定（難易度変わるからいらないかも）;

        Hukidashi("C3120");//そーれ

        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 1; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }

        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);


        //Aim
        KB_PonyPlayerFrontPivotTrs.position = VRCameraTrs.position;
        KB_nowChieriPathPosList[2] = KB_PonyPlayerFrontPivotTrs.GetChild(0).position;

        number = 2; time = 1; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("f_口開き笑顔", 0.1f, 2, 0);

        number = 0; time = 1; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        ChieriMotion("笑顔01口眉_目閉じない", 0.1f, 2, 0);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_PonyDamageCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speedを参照して、ゆっくりにできる予定（難易度変わるからいらないかも）;

        ChieriMotion("f_きゃう", 0.1f, 2, 0);
        Hukidashi("C3150");//きゃう

        //■IKオフならIKオンをゼロ位置移動に（前行動キャンセル時）
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 0.3f; ease = Ease.InOutElastic;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }

        AseTare();
        ChieriMotion("f_む～", 0.3f, 2, 0);

        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }

    IEnumerator KB_KaijuTackleCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speed;

        Hukidashi("C3210");//があー

        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 1; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }


        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);

        number = 2; time = 1; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        number = 0; time = 1; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_KaijuChouhatu00Cor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1f;//girlAnim.speed;

        yield return null;

        //■智恵理 Path先見る向ける(FollowDOMoveはVector3渡しの場合、直数値入力用にGameobjectsサイズをかけてるので、割って渡す)
        FollowDOMove(IKLookAtEyeTargetTrs, KB_nowChieriPathPosList[0] / GameObjectsTrs.localScale.x);
        FollowDOMove(IKLookAtHeadTargetTrs, KB_nowChieriPathPosList[2] / GameObjectsTrs.localScale.x);
        Hukidashi("C3210");//があ～


        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            number = 0; time = 0.5f;
            IKTargetTrs.position = KB_nowChieriPathPosList[number];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[number];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, time / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, time / animSpeed);
            yield return new WaitForSeconds(time / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 0.5f; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(time / animSpeed);
        }

        //ガオー揺らし
        time = 1f / animSpeed;
        KB_nowChieriPosTweener =
            IKTargetTrs.DOShakePosition(time, 1 / GameObjectsTrs.localScale.x, 10, 90, false, false);
        yield return new WaitForSeconds(time);

        number = 1; time = 0.5f; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        number = 2; time = 0.5f; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        //■智恵理 Path先見る
        FollowDOMove(IKLookAtEyeTargetTrs, KB_nowChieriPathPosList[number] / GameObjectsTrs.localScale.x);
        Hukidashi("C3220");//がお～
        yield return new WaitForSeconds(time / animSpeed);

        //ガオー揺らし
        time = 1f / animSpeed;
        KB_nowChieriPosTweener =
            IKTargetTrs.DOShakePosition(time, 1 / GameObjectsTrs.localScale.x, 10, 90, false, false);
        yield return new WaitForSeconds(time);

        number = 1; time = 0.5f; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        number = 3; time = 0.5f; ease = Ease.OutSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        //智恵理 プレイヤー顔見
        FollowDOMove(IKLookAtEyeTargetTrs, PlayerEyeTargetTrs);
        FollowDOMove(IKLookAtHeadTargetTrs, KB_nowChieriPathPosList[number] / GameObjectsTrs.localScale.x);
        Hukidashi("C3230");//がおお～
        yield return new WaitForSeconds(time / animSpeed);

        //ガオー揺らし
        time = 2f / animSpeed;
        KB_nowChieriPosTweener =
            IKTargetTrs.DOShakePosition(time, 1 / GameObjectsTrs.localScale.x, 10, 90, false, false);
        yield return new WaitForSeconds(time);

        number = 1; time = 0.5f; ease = Ease.InSine;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds(time / animSpeed);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);

        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_KaijuRHikkakiCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speed;

        Hukidashi("C3110");//そーれ
        KB_KaijuPlayerFrontPivotTrs.position = PlayerTargetTrs.position;

        //■IKオフならIKオンをゼロ位置移動に
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 1; ease = Ease.InOutSine;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }

        yield return new WaitForSeconds(Mathf.Infinity);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }
    IEnumerator KB_KaijuDamageCor()
    {
        Transform IKTargetTrs = IKLHandTargetTrs;
        IKEffector IKEf = IKLHandEf;
        int number;
        float time;
        Ease ease;
        float animSpeed = 1;//girlAnim.speedを参照して、ゆっくりにできる予定（難易度変わるからいらないかも）;

        ChieriMotion("笑顔01口眉", 0.1f, 2, 0);
        Hukidashi("C3150");//きゃう

        //■IKオフならIKオンをゼロ位置移動に（前行動キャンセル時）
        if (IKEf.positionWeight != 1)
        {
            IKTargetTrs.position = KB_nowChieriPathPosList[0];
            IKTargetTrs.rotation = KB_nowChieriPathRotList[0];
            //IKオン
            DOTweenToIKEfPos(IKEf, 1, 1 / animSpeed);
            DOTweenToIKEfRot(IKEf, 1, 1 / animSpeed);
            yield return new WaitForSeconds(1f / animSpeed);
        }
        else//オンならTweener移動
        {
            number = 0; time = 0.3f; ease = Ease.InOutElastic;
            #region Tweener
            KB_nowChieriPosTweener
                = IKTargetTrs.DOMove(
                    KB_nowChieriPathPosList[number],
                    time / animSpeed)
                    .SetEase(ease);
            KB_nowChieriRotTweener
                = IKTargetTrs.DORotateQuaternion(
                    KB_nowChieriPathRotList[number],
                    time / animSpeed)
                    .SetEase(ease);
            #endregion
            yield return new WaitForSeconds(1f / animSpeed);
        }

        AseTare();
        ChieriMotion("f_む～", 0.3f, 2, 0);

        number = 1; time = 1; ease = Ease.OutBack;
        #region Tweener
        KB_nowChieriPosTweener
            = IKTargetTrs.DOMove(
                KB_nowChieriPathPosList[number],
                time / animSpeed)
                .SetEase(ease);
        KB_nowChieriRotTweener
            = IKTargetTrs.DORotateQuaternion(
                KB_nowChieriPathRotList[number],
                time / animSpeed)
                .SetEase(ease);
        #endregion
        yield return new WaitForSeconds((time + 0.2f) / animSpeed);

        //■終了
        //IKオフ
        DOTweenToIKEfPos(IKEf, 0, 1 / animSpeed);
        DOTweenToIKEfRot(IKEf, 0, 1 / animSpeed);
        yield return new WaitForSeconds(1f / animSpeed);
    }

    #endregion ▯更新したPathリストで個別モーション コルーチン群

    #endregion ▯智恵理バトル用Path再生メソッド

    #region プレイヤー頭エリアの判定
    bool KB_HeadEnterBool;
    public void KB_HeadAreaCollisionEnter(Collision collision)
    {
        //蹴られ用
        if (KB_HeadEnterBool == false && collision.collider == KB_Tsumasaki_R_Collider)
        {
            SEPlay(UISEObj, "punch-high2");
            KB_HeadEnterBool = true;
        }


        //バトル時ダメージ
        if (KB_HeadEnterBool == false && collision.collider.name == "BattlePony_Collider")
        {
            StartCoroutine(KB_PlayerDamage());
            KB_HeadEnterBool = true;
        }
        if (KB_HeadEnterBool == false && collision.collider.name == "Kaiju_Collider")
        {
            StartCoroutine(KB_PlayerDamage());
            KB_HeadEnterBool = true;
        }
    }

    #endregion

    #region 頭追従をやめてBipedに指定位置でアニメーションさせる（■若干ボツ　何かで使うかも知れないので一応残してる）
    IEnumerator tmpPlayerBipedAnimation;//キャンセル用変数
    void PlayerBipedAnimation(string animStateName, float transitionDuration, int layer, Vector3 localPosition, Vector3 localEulerAngles)
    {
        //再生中に来たらキャンセル
        if (tmpPlayerBipedAnimation != null)
        { StopCoroutine(tmpPlayerBipedAnimation); tmpPlayerBipedAnimation = null; }

        //来たのを変数に入れて再生
        StartCoroutine(tmpPlayerBipedAnimation
            = PlayerBipedAnimationCor(animStateName, transitionDuration, layer, localPosition, localEulerAngles));
    }
    IEnumerator PlayerBipedAnimationCor(string animStateName, float transitionDuration, int layer, Vector3 localPosition, Vector3 localEulerAngles)
    {
        //アニメーション再生
        PlayerMotion(animStateName, transitionDuration, layer);
        yield return null;//反映に1フレーム

        //FBBIKtoHeadEffectorをオフ
        PlayerFBBIKHeadEffectorObj.SetActive(false);

        //VRカメラにBipedペアレント・位置調整
        Player_DummyTrs.SetParent(VRCameraTrs);
        Player_DummyTrs.localPosition = localPosition;
        Player_DummyTrs.localEulerAngles = localEulerAngles;


        //アニメーション終了待ち
        yield return new WaitForSeconds(transitionDuration);//ブレンド時間分待機
        while (playerAnim.GetCurrentAnimatorStateInfo(layer).normalizedTime < 1)
        { yield return null; }

        //BipedペアレントをFBBIKtoHeadEffectorに戻す・位置調整（ゼロ位置）
        Player_DummyTrs.SetParent(PlayerFBBIKtoHeadEffectorObj.transform);
        Player_DummyTrs.localPosition =
        Player_DummyTrs.localEulerAngles = Vector3.zero;

        //FBBIKtoHeadEffectorをオン
        PlayerFBBIKHeadEffectorObj.SetActive(true);

        //コルーチン変数消して、noData再生して終了
        tmpPlayerBipedAnimation = null;
        PlayerMotion("_noData", 0f, layer);
        SEPlay(UISEObj, "UI_po");
    }
    #endregion

    #region Fixed経由系Bool
    bool
        KB_KaijuTebanashiBool;
    #endregion

    #endregion ▯怪獣バトル システム 変数 コルーチン群
    #region ■ポインターカーソルシステムSeePoint
    #region 変数
    bool
        isSeePointCursorSystem = false,
        isSeePointTempOff = false;

    #endregion

    IEnumerator SeePointCursorSystemIEnum()
    {
        if (isSeePointCursorSystem) { yield break; }
        isSeePointCursorSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        LayerMask
            seePointCursorLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("seeRayKakurePos")) +
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));


        RaycastHit
            seePointCursorRayHit;
        #endregion

        #region ■■■ループ
        while (isSeePointCursorSystem)
        {
            if (isSeePointTempOff == false &&
                Physics.Raycast(playerSeeRay, out seePointCursorRayHit, Mathf.Infinity, seePointCursorLayerMask))
            {
                #region ■ポインタ処理
                //存在させる
                if (SeePointTrs.gameObject.activeSelf != true)
                { SeePointTrs.gameObject.SetActive(true); }

                //ポインタの場所と大きさ
                SeePointTrs.position = seePointCursorRayHit.point;
                SeePointTrs.LookAt(PlayerTargetTrs, Vector3.forward);
                nearSizeAjust(SeePointTrs, 8000);

                #endregion
            }
            else
            {
                //ポインタ消し
                if (SeePointTrs.gameObject.activeSelf != false) { SeePointTrs.gameObject.SetActive(false); }
            }
            yield return null;
        }
        #endregion

        #region ■■■終了処理

        SeePointTrs.gameObject.SetActive(false);


        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }

    //必要なシステムが起動してなければ終了する用
    void SeePointSystemOff()
    {
        if (
            isTansakuSystem == false
            || isKOSystem == false
            || isRMEHwSystem == false
            )
        {
            isSeePointCursorSystem = false;
        }
    }
    #endregion

    #region ■メニューシステム

    #region 変数
    public bool
        isMenuSystem = false,
        isMenuLock = false,
        isMenuGamePause = false;

    public bool //一時的にユーザーに設定させないようにする用
        isForceDoF = false;


    //CanvasやScrollRect等のフォルダ階層オブジェ群
    [HideInInspector]
    public GameObject
        MenuFolder,//全ての親フォルダ
        TabBarWindowCanvasObj,
        MainMenuWindowCanvasObj,
        GraphicWindowCanvasObj,
        FlowChartMoveWindowCanvasObj,
        FlowChartWindowCanvasObj,
        SousaWindowCanvasObj,
        SousaWindowScrollRectObj,
        SousaWindowContentObj,
        ClothsWindowCanvasObj,
        InitialSettingWindowCanvasObj;

    //このコリダーRayが当たっている間のみ、メニュー内のマウスコリダー判定を取る（UIのマスクだけでは画面外も判定とってしまうので）
    [HideInInspector]
    public GameObject
        MouseOnMenuColliderObj,
        MouseOutMenuColliderObj;
    [HideInInspector]
    public BoxCollider
        MouseOnMenuCollider,
        MouseOutMenuCollider;

    //フローチャートのみこのコリダーRayも当たっている間のみ（欄外コマの判定を取らないよう）
    [HideInInspector]
    public GameObject
        MouseOnFlowChartColliderObj;
    [HideInInspector]
    public Collider
        MouseOnFlowChartCollider;

    GameObject //トグルオンオフをメソッドで行う用
        Toggle_OnProtObj,
        Toggle_OffProtObj;


    #region ■フローチャート
    //フローチャートコマデータのObjリスト（Evsのリソースロードで初期化したり、外部からの参照多め）
    [HideInInspector]
    public List<GameObject>
        flowChartKomaDataObjList = new List<GameObject>();

    //フローチャートの時系列Enum
    [HideInInspector]
    public enum flowChartLine
    { その他, 転送都市, シュリ, BAD, おまけ }



    //フローチャート用"データ"の入ったフォルダ（Canvasやウインドウでなく、データのみのGameobject群）
    [HideInInspector]
    GameObject
        FlowChartKomaDataFolder;

    //CanvasやScrollRect等のフォルダ階層オブジェ群
    [HideInInspector]
    public GameObject
        FlowChartScrollRectObj,
        FlowChartContentObj,

        FlowChartKomaDataWindowObj,//コマの内容表示ウインドウ
        RemainSentakusiWindowObj,
        RemainBadendWindowObj,
        RemainBADHolesObj,
        //プロット
        FlowChartProtFolderObj,
        FlowChartOneTimeProtObj,
        FlowChartKomaProtObj,
        FlowChartDummyKomaProtObj,
        RemainSentkusiObjProt,
        RemainBADHoleObjProt;




    #endregion

    public bool //フローチャートのイベント移動でメニュー閉じられる時 SEなくす・フェードアウトする用
        isFlowChartEventMove = false;
    #endregion

    IEnumerator MenuSystemIEnum(bool isScriptOn = false, bool isInitialSetting = false, bool isContinue = false)
    {
        if (isMenuSystem) { yield break; }
        isMenuSystem = true;

        //MenuFolderのPrefabなければ生成
        if (CameraAnchorTrs.Find("MenuFolder") == null)
        {
            MenuFolder = Instantiate(Resources.Load("EventSystem/Menu/Prefab/MenuFolder") as GameObject
                , CameraAnchorTrs, false);//Unity2018バグでInstantiateから直接ペアレントしないとColliderRayがEnableONOFFするまで動かなかった
        }
        //編集用にすでに配置してある場合
        else { MenuFolder = CameraAnchorTrs.Find("MenuFolder").gameObject; }

        //SE
        SEPlay(UISEObj, "UI_puyo");

        #region 初期化

        #region 主だったフォルダやCanvasやコリダーのObj取得

        //■一層目
        MouseOnMenuColliderObj = MenuFolder.transform.Find("MouseOnMenuCollider").gameObject;
        MouseOutMenuColliderObj = MenuFolder.transform.Find("MouseOutMenuCollider").gameObject;
        TabBarWindowCanvasObj = MenuFolder.transform.Find("TabBarWindowCanvas").gameObject;
        MainMenuWindowCanvasObj = MenuFolder.transform.Find("MainMenuWindowCanvas").gameObject;
        GraphicWindowCanvasObj = MenuFolder.transform.Find("GraphicWindowCanvas").gameObject;
        FlowChartMoveWindowCanvasObj = MenuFolder.transform.Find("FlowChartMoveWindowCanvas").gameObject;
        FlowChartWindowCanvasObj = MenuFolder.transform.Find("FlowChartWindowCanvas").gameObject;
        SousaWindowCanvasObj = MenuFolder.transform.Find("SousaWindowCanvas").gameObject;
        ClothsWindowCanvasObj = MenuFolder.transform.Find("ClothsWindowCanvas").gameObject;
        InitialSettingWindowCanvasObj = MenuFolder.transform.Find("InitialSettingWindowCanvas").gameObject;

        //メニューウインドウ内にマウスカーソルRayが来ているか判定用コリダー取得 （Rayはメニューウインドウそのもの範囲用 と ボタンやスライダー用に2本飛ばす）
        MouseOnMenuCollider = MouseOnMenuColliderObj.GetComponent<BoxCollider>();
        //メニュー外にマウス出たらPCマウス表示する用
        MouseOutMenuCollider = MouseOutMenuColliderObj.GetComponent<BoxCollider>();

        #region 二層目以降（タブバー　操作ウィンドウ）
        GameObject
            TabsObj = TabBarWindowCanvasObj.transform.Find("Tabs").gameObject,
            TabButton_MainObj = TabsObj.transform.Find("TabButton_Main").gameObject,
            TabButton_GraphicObj = TabsObj.transform.Find("TabButton_Graphic").gameObject,
            TabButton_FlowChartObj = TabsObj.transform.Find("TabButton_FlowChart").gameObject,
            TabButton_SousaObj = TabsObj.transform.Find("TabButton_Sousa").gameObject,
            TabButton_ClothsObj = TabsObj.transform.Find("TabButton_Cloths").gameObject,
            SousaWindowScrollRectObj = SousaWindowCanvasObj.transform.Find("ScrollRect").gameObject,
            SousaWindowContentObj = SousaWindowScrollRectObj.transform.Find("Content").gameObject;


        #region Image　と　カラー取得
        Image
            tabButton_MainImg = TabButton_MainObj.GetComponent<Image>(),
            tabButton_GraphicImg = TabButton_GraphicObj.GetComponent<Image>(),
            tabButton_FlowChartImg = TabButton_FlowChartObj.GetComponent<Image>(),
            tabButton_SousaImg = TabButton_SousaObj.GetComponent<Image>(),
            tabButton_ClothsImg = TabButton_ClothsObj.GetComponent<Image>();

        Color //今設定されてるカラーで取得（プロットなし）
            tabOnColor = tabButton_MainImg.color,
            tabOffColor = tabButton_GraphicImg.color;
        #endregion

        #endregion

        #region ■二層目以降（フローチャート）
        MouseOnFlowChartColliderObj = FlowChartWindowCanvasObj.transform.Find("MouseOnFlowChartCollider").gameObject;
        //フローチャートのみこのコリダーRayも当たっている間のみ（欄外コマの判定を取らないよう）
        MouseOnFlowChartCollider = MouseOnFlowChartColliderObj.GetComponent<Collider>();

        //コマ一覧をスクロールする
        FlowChartScrollRectObj = FlowChartWindowCanvasObj.transform.Find("ScrollRect").gameObject;
        //コマ一覧
        FlowChartContentObj = FlowChartScrollRectObj.transform.Find("Content").gameObject;

        //コマデータの内容表示ウインドウ
        FlowChartKomaDataWindowObj = FlowChartWindowCanvasObj.transform.Find("KomaDataWindow").gameObject;
        RemainSentakusiWindowObj = FlowChartKomaDataWindowObj.transform.Find("RemainSentakusiWindow").gameObject;
        RemainBadendWindowObj = FlowChartKomaDataWindowObj.transform.Find("RemainBadendWindow").gameObject;
        RemainBADHolesObj = RemainBadendWindowObj.transform.Find("RemainBADHolesObj").gameObject;
        //プロット
        FlowChartProtFolderObj = FlowChartWindowCanvasObj.transform.Find("ProtFolder").gameObject;
        FlowChartOneTimeProtObj = FlowChartProtFolderObj.transform.Find("OneTimeProt").gameObject;
        FlowChartKomaProtObj = FlowChartProtFolderObj.transform.Find("KomaProt").gameObject;
        FlowChartDummyKomaProtObj = FlowChartProtFolderObj.transform.Find("DummyKomaProt").gameObject;
        RemainSentkusiObjProt = RemainSentakusiWindowObj.transform.Find("RemainSentkusiObjProt").gameObject;
        RemainBADHoleObjProt = RemainBADHolesObj.transform.Find("RemainBADHoleObjProt").gameObject;
        #endregion

        #endregion

        //メニューの範囲内だけRay飛ばす判定用のRayのRaycastHit（ヒット判定しか取らず取得したデータ自体は使わない。のでダミーとしている）
        RaycastHit
            tmpDummyMouseOnMenuColliderRayHit,
            tmpDummyMouseOutMenuColliderRayHit,
            //フローチャート用のも
            tmpDummyMouseOnFlowChartColliderRayHit;

        //レイヤーマスク
        mouseRayLayerMask = (1 << LayerMask.NameToLayer("MouseRayReceive"));

        //グラフィックのトグルOnOFFのプロット
        GameObject
            GraphicProtFolder = GraphicWindowCanvasObj.transform.Find("ProtFolder").gameObject;


        #region ■トグル 取得と設定反映
        GameObject
            Toggle_JapaneseObj,
            Toggle_EnglishObj;
        #region 言語設定トグル、初期起動なら初期設定のトグルに
        if (DB.isUserInitialSetting == false)
        {
            Toggle_JapaneseObj = InitialSettingWindowCanvasObj.transform.Find("Toggle_Japanese").gameObject;
            Toggle_EnglishObj = InitialSettingWindowCanvasObj.transform.Find("Toggle_English").gameObject;
        }
        else
        {
            Toggle_JapaneseObj = MainMenuWindowCanvasObj.transform.Find("Toggle_Japanese").gameObject;
            Toggle_EnglishObj = MainMenuWindowCanvasObj.transform.Find("Toggle_English").gameObject;
        }
        #endregion

        Toggle_OnProtObj = GraphicProtFolder.transform.Find("Toggle_OnProt").gameObject;
        Toggle_OffProtObj = GraphicProtFolder.transform.Find("Toggle_OffProt").gameObject;

        GameObject
            Toggle_NowPlayerSintyouObj = MainMenuWindowCanvasObj.transform.Find("Toggle_NowPlayerSintyou").gameObject,
            Toggle_AntialiasingObj = GraphicWindowCanvasObj.transform.Find("Toggle_Antialiasing").gameObject,
            Toggle_AmbientOcclusionObj = GraphicWindowCanvasObj.transform.Find("Toggle_AmbientOcclusion").gameObject,
            Toggle_BloomObj = GraphicWindowCanvasObj.transform.Find("Toggle_Bloom").gameObject,
            Toggle_DepthOfFieldObj = GraphicWindowCanvasObj.transform.Find("Toggle_DepthOfField").gameObject,
            Toggle_FogObj = GraphicWindowCanvasObj.transform.Find("Toggle_Fog").gameObject,
            Toggle_FieldOfViewObj = GraphicWindowCanvasObj.transform.Find("Toggle_FieldOfView").gameObject,
            Toggle_TPSModeObj = GraphicWindowCanvasObj.transform.Find("Toggle_TPSMode").gameObject,
            Toggle_VRUpDownRotateObj = GraphicWindowCanvasObj.transform.Find("Toggle_VRUpDownRotate").gameObject,
            Toggle_VRSmoothRotateObj = GraphicWindowCanvasObj.transform.Find("Toggle_VRSmoothRotate").gameObject,
            //今はメニュー表示しない//Toggle_FreeCameraModeObj = GraphicWindowCanvasObj.transform.Find("Toggle_FreeCameraMode").gameObject,
            Toggle_FixityOutfitObj = ClothsWindowCanvasObj.transform.Find("Toggle_FixityOutfit").gameObject,
            Toggle_BarefootObj = ClothsWindowCanvasObj.transform.Find("Toggle_Barefoot").gameObject,
            Toggle_TanktopObj = ClothsWindowCanvasObj.transform.Find("Toggle_Tanktop").gameObject,
            Toggle_BikiniObj = ClothsWindowCanvasObj.transform.Find("Toggle_Bikini").gameObject;


        //言語設定 日本語　English
        if (DB.isEnglish)//英語
        {
            TogglleChange(Toggle_EnglishObj, true);
            TogglleChange(Toggle_JapaneseObj, false);
        }
        else　//日本語
        {
            TogglleChange(Toggle_EnglishObj, false);
            TogglleChange(Toggle_JapaneseObj, true);
        }

        //PPv2設定 DBから反映
        TogglleChange(Toggle_AntialiasingObj, DB.isUserAntialiasing);
        TogglleChange(Toggle_AmbientOcclusionObj, DB.isUserAmbientOcclusion);
        TogglleChange(Toggle_BloomObj, DB.isUserBloom);
        TogglleChange(Toggle_DepthOfFieldObj, DB.isUserDepthOfFieldV1);
        TogglleChange(Toggle_FogObj, DB.isUserFog);

        //身長
        TogglleChange(Toggle_NowPlayerSintyouObj, DB.isUserFixityMakotoHeightVis);
        //アンロックされてなかったら非表示
        if (DB.isUserInfoVisMakotoHeightUnlock == false && DB.isDebugMode == false)
        { Toggle_NowPlayerSintyouObj.SetActive(false); }

        //■Cloths
        TogglleChange(Toggle_FixityOutfitObj, DB.isUserFixityOutfit);
        TogglleChange(Toggle_BarefootObj, DB.isUserClothsBarefoot);
        TogglleChange(Toggle_TanktopObj, DB.isUserClothsTankTop);
        TogglleChange(Toggle_BikiniObj, DB.isUserClothsBikini);

        //ビキニがON時はBarefootトグルObjオフ
        if (DB.isUserClothsBikini) { Toggle_BarefootObj.SetActive(false); }


        //VRRotate関係 まずActiveオフ
        Toggle_VRUpDownRotateObj.SetActive(false);
        Toggle_VRSmoothRotateObj.SetActive(false);
        //TPSモードがONなら
        if (DB.isUserTPSMode)
        {
            TogglleChange(Toggle_TPSModeObj, true);
            //VR時ならRotate関係 Activeオン
            if (XRSettings.enabled)
            {
                Toggle_VRUpDownRotateObj.SetActive(true);
                Toggle_VRSmoothRotateObj.SetActive(true);
            }
        }
        else
        {
            TogglleChange(Toggle_TPSModeObj, false);
        }

        //VRUpDownRotate
        TogglleChange(Toggle_VRUpDownRotateObj, DB.isUserVRUpDownRotate);

        //VRSmoothRotate
        TogglleChange(Toggle_VRSmoothRotateObj, DB.isUserVRSmoothRotate);

        ////FreeCameraMode(今はメニューに搭載しない)
        //TogglleChange(Toggle_FreeCameraModeObj, DB.isUserFreeCameraMode);


        //■PCプレイだったら
        if (XRSettings.enabled == false)
        {
            //FOV オン
            TogglleChange(Toggle_FieldOfViewObj, true);
        }
        else
        {
            //FOV Activeオフ
            Toggle_FieldOfViewObj.SetActive(false);
        }



        #endregion

        #region ■スライダー 取得と設定反映

        //音量とマウスレート
        GameObject
            Slider_MasterObj = MainMenuWindowCanvasObj.transform.Find("Slider_Master").gameObject,
            Slider_BGMObj = MainMenuWindowCanvasObj.transform.Find("Slider_BGM").gameObject,
            Slider_SEObj = MainMenuWindowCanvasObj.transform.Find("Slider_SE").gameObject,
            Slider_MouseRateObj = MainMenuWindowCanvasObj.transform.Find("Slider_MouseRate").gameObject,
            Slider_StickRateObj = MainMenuWindowCanvasObj.transform.Find("Slider_StickRate").gameObject;

        Slider
            masterSlider = Slider_MasterObj.GetComponent<Slider>(),
            bgmSlider = Slider_BGMObj.GetComponent<Slider>(),
            seSlider = Slider_SEObj.GetComponent<Slider>(),
            mouseRateSlider = Slider_MouseRateObj.GetComponent<Slider>(),
            stickRateSlider = Slider_StickRateObj.GetComponent<Slider>();

        //PostProcessing
        GameObject
            Slider_DepthOfFieldObj = Toggle_DepthOfFieldObj.transform.Find("Slider_DepthOfField").gameObject,
            Slider_FieldOfViewObj = Toggle_FieldOfViewObj.transform.Find("Slider_FieldOfView").gameObject;
        Slider
            Slider_DepthOfFieldSlider = Slider_DepthOfFieldObj.GetComponent<Slider>(),
            Slider_FieldOfViewSlider = Slider_FieldOfViewObj.GetComponent<Slider>();

        #region 音量・マウスレートのスライダー

        //スライダーに、Valueの変更を察知してメソッド実行するのをAdd（内部的にはUnityActionというのを使っているらしい）
        masterSlider.onValueChanged.AddListener(SetMasterVolume);
        bgmSlider.onValueChanged.AddListener(SetBGMVolume);
        seSlider.onValueChanged.AddListener(SetSEVolume);
        mouseRateSlider.onValueChanged.AddListener(SetMouseRate);
        stickRateSlider.onValueChanged.AddListener(SetStickRate);

        //ゲージ表示DBから反映
        masterSlider.value = DB.userMasterVolume;
        bgmSlider.value = DB.userBGMVolume;
        seSlider.value = DB.userSEVolume;
        mouseRateSlider.value = DB.userMouseCameraSensitivityFlt - 1; //+1基準で処理しているため反映は-1（0だとスライダーが処理できない & マウス止まってしまうので）
        stickRateSlider.value = DB.userStickCameraSensitivity - 0.1f; //+0.1で処理しているため

        #endregion

        #region PPv2設定 と Camera広角 DBから反映

        //最大値から最小値を引いた数をMaxにし、最小値を0にする（後の設定時に最小値をプラスする）（スライダー操作が最小値0でないといけない（Rayで座標から入力しているので））
        Slider_DepthOfFieldSlider.minValue = 0;
        Slider_DepthOfFieldSlider.maxValue = DB.adjustDepthOfFieldV1x50MaxFloat - DB.adjustDepthOfFieldV1x50MinFloat;
        Slider_DepthOfFieldSlider.value = DB.userDepthOfFieldV1Float - DB.adjustDepthOfFieldV1x50MinFloat;

        //x100を使うときが来たら、イベントかプレイヤー大きさでif取ってそれを代入する予定


        Slider_FieldOfViewSlider.minValue = 0;
        Slider_FieldOfViewSlider.maxValue = DB.adjustFieldOfViewMaxFloat - DB.adjustFieldOfViewMinFloat;
        Slider_FieldOfViewSlider.value = DB.userFieldOfViewFloat - DB.adjustFieldOfViewMinFloat;

        #endregion

        #endregion

        #region ■フローチャート
        //時系列コマフォルダ一覧List（取得後OneTwoThree並べ替える用）
        List<GameObject> timeFolderObjsList = new List<GameObject>();

        //今マウスが乗っかってるコマオブジェ （乗ってたらアウトラインなど表示する用）（コマ以外に乗ったらnullにする）
        GameObject
            nowMouseOnKomaObj = null;
        //今マウスの乗っているコマのイベントナンバー（アウトラインやSE処理を一回にするため取得する）（nullは-1で代替）
        int
            nowMouseOnKomaEventInt = -1;

        //フローチャートコマ一覧を操作する用（Contentをスクロールさせる）
        RectTransform
            flowChartContentRectTrs = FlowChartContentObj.GetComponent<RectTransform>();

        //サムネイル拡大のObj Image Text（コマデータ詳細ウインドウObjの中）
        GameObject
            komaThumbnailImageObj = FlowChartKomaDataWindowObj.transform.Find("ThumbnailImage").gameObject;
        Image
            komaThumbnailZoomImage = komaThumbnailImageObj.GetComponent<Image>();
        Text
            komaThumbnailTitleText = komaThumbnailImageObj.transform.Find("Text").GetComponent<Text>();
        #endregion
        #region フローチャート取得後処理(コンティニューの場合のコマ選びここ)
        //■変数
        ////フローチャートに表示されるコマObjリスト（アウトラインや、開いた時にContentスクロール位置を読み出すためなど）
        //List<GameObject> visKomaObjList = new List<GameObject>();

        //選択肢穴オブジェ入れ替え用（現在表示コマデータ変更時に前のコマの選択肢穴を消して新しいのを入れる　の繰り返し用）
        List<GameObject> nowVisRemaineSentakusiObjList = new List<GameObject>();
        List<GameObject> nowVisRemaineBADObjList = new List<GameObject>();


        //NoVisKomasFolder(フローチャートに表示しないコマはこのフォルダに)
        GameObject NoVisKomasFolder
            = FlowChartScrollRectObj.transform.Find("NoVisKomasFolder").gameObject;
        NoVisKomasFolder.SetActive(false);

        //プロットデータ非表示
        FlowChartProtFolderObj.SetActive(false);
        RemainSentkusiObjProt.SetActive(false);
        RemainBADHoleObjProt.SetActive(false);

        #region ■メインイベントが何番かを取得 (コンティニューの場合のコマ選びここ)
        int mainEventNum;

        if (isContinue == false)
        {
            mainEventNum =
                DB.eventNamesList.IndexOf
                (
                    FlowChartKomaDataFolder.transform.GetChild(DB.nowEventNum)
                    .GetComponent<FlowChartKoma>().mainEventName
                );
            //↑が-1(null)だった場合、現在イベントがメインイベントなので現在イベントナンバーに戻し
            if (mainEventNum == -1)
            { mainEventNum = DB.nowEventNum; }
        }

        //コンティニューの場合は、セーブデータのnowEventコマ
        else
        {
            //■セーブデータからロード（コマデータリストからセーブされてるナンバー読み取り、コマデータからメインイベントname参照）
            mainEventNum =
                DB.eventNamesList.IndexOf
                (
                    flowChartKomaDataObjList[int.Parse(DB.saveDataDict[nameof(DB.nowEventNum)])]
                    .GetComponent<FlowChartKoma>().mainEventName
                );
            //↑が-1(null)だった場合、そのイベントがメインイベントなのでそのナンバーに
            if (mainEventNum == -1)
            {
                mainEventNum = flowChartKomaDataObjList[int.Parse(DB.saveDataDict[nameof(DB.nowEventNum)])]
                               .GetComponent<FlowChartKoma>().eventNum;
            }
        }


        #endregion

        //メインイベントコマObj取得用変数（ペアレントした後で位置を取得する用）(Content位置設定用)
        GameObject mainEventKomaObj = null;

        #region ■コマオブジェデータ読み取ってコマ生成

        OrderedDictionary<string, int> //コマを分岐ごとに詰めて表示する用フォルダ名と連番のDict
            folderNameEnum_IntDict = new OrderedDictionary<string, int>();


        for (int i = 0; i < flowChartKomaDataObjList.Count; i++)
        {
            //コマデータ変数化
            var tmpKomaData = flowChartKomaDataObjList[i].GetComponent<FlowChartKoma>();

            //コマをプロットからクローン
            GameObject NewKoma = Instantiate(FlowChartKomaProtObj);
            //名前つけ
            NewKoma.name = tmpKomaData.eventNum.ToString("D3") + " " + tmpKomaData.eventName;

            //■サムネイルSprite設定
            //サムネイル画像が指定されていたら
            if (tmpKomaData.thumbnailImageSprite != null)
            {
                NewKoma.transform.Find("ThumbnailImage").GetComponent<Image>().sprite
                    = tmpKomaData.thumbnailImageSprite;
            }

            //フローチャートに表示しないコマはNoVisKomasフォルダへ
            if (tmpKomaData.isFlowChartVis == false)
            { NewKoma.transform.SetParent(NoVisKomasFolder.transform, false); }
            //表示するコマはフォルダ振り分けに
            else
            {
                #region ヒントでもなくプレイヤー到達してないコマもNoVisKomasフォルダへ（デバッグ時は全解放）
                if (tmpKomaData.isHintVisFlag == false && tmpKomaData.isPlayerVisFlag == false && DB.isDebugMode == false)
                {
                    NewKoma.transform.SetParent(NoVisKomasFolder.transform, false);
                    goto 抜け;
                }
                //ヒントはONなら
                else if (tmpKomaData.isHintVisFlag && tmpKomaData.isPlayerVisFlag == false)
                {
                    //サムネイルにヒントイメージ被せ
                    NewKoma.transform.Find("ThumbnailImage/HintImage").gameObject.SetActive(true);
                }
                #endregion

                #region コマデータのフォルダ名を読み取り、時系列Enum（その他 転送都市 シュリ BAD）で連番フォルダ作成。（転送都市の0とシュリの0が同じフォルダになるように）
                string tmpFolderName = tmpKomaData.folderName;

                //フォルダ名空っぽはUnFolderName
                if (string.IsNullOrWhiteSpace(tmpFolderName))
                { tmpFolderName = "UnFolderName"; }

                //ややこしい変数作成
                //フォルダ名+Enum
                var folderNamePlusEnumStr = tmpFolderName + tmpKomaData.flowChartLine.ToString();


                //まず、「フォルダ名+Enum」のString　がDictKeyにあれば
                if (folderNameEnum_IntDict.ContainsKey(folderNamePlusEnumStr))
                {
                    //Contentに「フォルダ名+連番」フォルダが既にあるかどうか
                    foreach (Transform k in FlowChartContentObj.transform)
                    {
                        if (k.name == tmpFolderName + folderNameEnum_IntDict[folderNamePlusEnumStr])
                        {
                            //ペアレントするフォルダ名確定（連番をつける）
                            tmpFolderName = tmpFolderName + folderNameEnum_IntDict[folderNamePlusEnumStr].ToString();
                            //その「フォルダ名+Enum」のDictValue連番を加算して フォルダ作成スキップ
                            folderNameEnum_IntDict[folderNamePlusEnumStr]++;
                            goto フォルダあった;
                        }
                    }
                }
                //DictKeyに「フォルダ名+Enum」なければ
                else
                {
                    //0番で新規Add
                    folderNameEnum_IntDict.Add(folderNamePlusEnumStr, 0);

                    //Contentに「フォルダ名+連番」(0番)フォルダが既にあるかどうか
                    foreach (Transform k in FlowChartContentObj.transform)
                    {
                        if (k.name == tmpFolderName + folderNameEnum_IntDict[folderNamePlusEnumStr])
                        {
                            //ペアレントするフォルダ名確定（連番をつける）
                            tmpFolderName = tmpFolderName + folderNameEnum_IntDict[folderNamePlusEnumStr].ToString();
                            //その「フォルダ名+Enum」のDictValue連番を加算して フォルダ作成スキップ
                            folderNameEnum_IntDict[folderNamePlusEnumStr]++;
                            goto フォルダあった;
                        }
                    }

                }

                //■フォルダ名+その連番でフォルダ作成
                //フォルダをプロットからクローン
                GameObject tmpFolderObj = Instantiate(FlowChartOneTimeProtObj);
                //フォルダ名+連番 を名前に
                tmpFolderObj.name = tmpFolderName
                    + folderNameEnum_IntDict[folderNamePlusEnumStr].ToString();
                //ペアレント
                tmpFolderObj.transform.SetParent(FlowChartContentObj.transform, false);
                //リストに追加（後でコマ並べ替え用）
                timeFolderObjsList.Add(tmpFolderObj);
                //ペアレントするフォルダ名確定（連番をつける）
                tmpFolderName = tmpFolderName
                    + folderNameEnum_IntDict[folderNamePlusEnumStr].ToString();
                //その「フォルダ名+Enum」のDictValue連番を加算して フォルダ作成終了
                folderNameEnum_IntDict[folderNamePlusEnumStr]++;


                //生成したので、
                フォルダあった:

                #region その他 転送都市 シュリ BAD　で位置分け

                //その他だったらただ入れる
                if (tmpKomaData.flowChartLine == flowChartLine.その他)
                {
                    //本体をContentにペアレント
                    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                }
                //転送都市だったら
                else if (tmpKomaData.flowChartLine == flowChartLine.転送都市)
                {
                    //本体をContentにペアレント
                    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);

                    //ダミー生成
                    GameObject tmpDummyKomaObj = Instantiate(FlowChartDummyKomaProtObj);
                    tmpDummyKomaObj.name = "DummyKoma";
                    //ダミーをペアレント
                    tmpDummyKomaObj.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                }
                //シュリだったら
                else if (tmpKomaData.flowChartLine == flowChartLine.シュリ)
                {
                    //フォルダにコマが既にあるなら
                    if (FlowChartContentObj.transform.Find(tmpFolderName).childCount > 0)
                    {
                        //ダミーがあったらダミーを消して
                        if (FlowChartContentObj.transform.Find(tmpFolderName + "/DummyKoma") != null)
                        { Destroy(FlowChartContentObj.transform.Find(tmpFolderName + "/DummyKoma").gameObject); }

                        //本体をContentにペアレント
                        NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                    }
                    //コマないなら
                    else
                    {
                        //ダミーを入れてから
                        GameObject tmpDummyKomaObj = Instantiate(FlowChartDummyKomaProtObj);
                        tmpDummyKomaObj.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                        //本体をContentにペアレント
                        NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                    }
                }
                //BADだったら
                else if (tmpKomaData.flowChartLine == flowChartLine.BAD)
                {
                    //問題ないため（転送やシュリがあってもなくても（ダミーであっても）BADのダミーは作っていないので）
                    //本体をContentにペアレント
                    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                }
                //おまけだったら（既存（タイトルなど）の左に置くために フォルダ内で 0おまけ 1既存 2ダミー の順にする）
                else if (tmpKomaData.flowChartLine == flowChartLine.おまけ)
                {
                    //既存のコマがひとつだけ入っていること前提

                    //本体をContentにペアレントし
                    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                    //本体を0番目にする
                    NewKoma.transform.SetAsFirstSibling();
                    //ダミーを入れる(0おまけ 1既存 2ダミー の順になる)
                    GameObject tmpDummyKomaObj = Instantiate(FlowChartDummyKomaProtObj);
                    tmpDummyKomaObj.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                }

                #endregion
                #endregion
                #region //以前の　時間を読み取り、すでにその時間フォルダあればそこに、なければ時間フォルダ生成
                //string tmpFolderName = tmpKomaData.day + "d" + tmpKomaData.hour + "h" + tmpKomaData.minute + "m";
                //foreach (Transform k in FlowChartContentObj.transform)
                //{
                //    if (k.name == tmpFolderName)
                //    { goto 同じ時間フォルダあった; }
                //}

                ////同じ時間フォルダなかったので、その時間フォルダをプロットからクローン
                //GameObject NewTime = Instantiate(FlowChartOneTimeProtObj);
                //NewTime.name = tmpFolderName;
                //NewTime.transform.SetParent(FlowChartContentObj.transform, false);
                ////リストに追加（後でコマ並べ替え用）
                //timeFolderObjsList.Add(NewTime);

                ////ここで生成したので、あった処理へ↓
                //同じ時間フォルダあった:

                //#region その他 One Two Three　で位置分け

                ////その他だったらただ入れる
                //if (tmpKomaData.flowChartLine == flowChartLine.その他)
                //{
                //    //本体をContentにペアレント
                //    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //}
                ////Oneだったら
                //else if (tmpKomaData.flowChartLine == flowChartLine.One)
                //{
                //    //本体をContentにペアレント
                //    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);

                //    //ダミー生成
                //    GameObject tmpDummyKomaObj = Instantiate(FlowChartDummyKomaProtObj);
                //    //ダミーをペアレント
                //    tmpDummyKomaObj.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //}
                ////Twoだったら
                //else if (tmpKomaData.flowChartLine == flowChartLine.Two)
                //{
                //    //時間フォルダにコマが既にあるなら
                //    if (FlowChartContentObj.transform.Find(tmpFolderName).childCount > 0)
                //    {
                //        //ダミーがあるはずなので、ダミーを消して
                //        Destroy(FlowChartContentObj.transform.Find(tmpFolderName).GetChild(1).gameObject);
                //        //本体をContentにペアレント
                //        NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //    }
                //    //Oneコマないなら
                //    else
                //    {
                //        //ダミーを入れてから
                //        GameObject tmpDummyKomaObj = Instantiate(FlowChartDummyKomaProtObj);
                //        tmpDummyKomaObj.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //        //本体をContentにペアレント
                //        NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //    }
                //}
                ////Threeだったら
                //else if (tmpKomaData.flowChartLine == flowChartLine.Three)
                //{
                //    //問題ないため（OneTwoがあってもなくても（ダミーであっても）Threeのダミーは作っていないので）
                //    //本体をContentにペアレント
                //    NewKoma.transform.SetParent(FlowChartContentObj.transform.Find(tmpFolderName), false);
                //}


                //#endregion

                #endregion

                #region 現在のメインイベントのコマなら、アウトライン表示。Content位置設定用Obj変数も設定
                if (mainEventNum == tmpKomaData.eventNum)
                {
                    NewKoma.transform.Find("OutlineNowEvent").gameObject.SetActive(true);
                    mainEventKomaObj = NewKoma;
                }
                #endregion
                #region サムネイルコマにコマデータコンポーネントをコピーして付与（後で参照楽にするためのみ）
                Type type = tmpKomaData.GetType();
                Component copy = NewKoma.AddComponent(type);
                // Copied fields can be restricted with BindingFlags
                FieldInfo[] fields = type.GetFields();
                foreach (FieldInfo field in fields)
                {
                    field.SetValue(copy, field.GetValue(tmpKomaData));
                }
                #endregion
            }
            抜け:;
        }
        #endregion

        #endregion


        #region ■強制OFF系
        //■Dof強制オフだったら
        if (isForceDoF)
        {
            Toggle_DepthOfFieldObj.SetActive(false);
            Slider_DepthOfFieldSlider.enabled = false;
        }
        #endregion


        #endregion

        #region 起動時処理

        MenuFolder.SetActive(true);

        #region スクリプトで開いているなら
        if (isScriptOn == true)
        {
            #region 初期起動なら初期起動のみ
            if (isInitialSetting)
            {
                TabBarWindowCanvasObj.SetActive(false);
                MainMenuWindowCanvasObj.SetActive(false);
                GraphicWindowCanvasObj.SetActive(false);
                FlowChartMoveWindowCanvasObj.SetActive(false);
                FlowChartWindowCanvasObj.SetActive(false);
                SousaWindowCanvasObj.SetActive(false);

                InitialSettingWindowCanvasObj.SetActive(true);
            }
            #endregion

            #region コンティニューでのFlowchart開きなら フローチャートウィンドウを
            else if (isContinue)
            {
                MainMenuWindowCanvasObj.SetActive(false);
                GraphicWindowCanvasObj.SetActive(false);
                FlowChartWindowCanvasObj.SetActive(true);
                SousaWindowCanvasObj.SetActive(false);

                #region メニュー□ グラフィック□ フローチャート■ 操作□
                MainMenuWindowCanvasObj.SetActive(false);
                GraphicWindowCanvasObj.SetActive(false);
                FlowChartWindowCanvasObj.SetActive(true);
                SousaWindowCanvasObj.SetActive(false);

                tabButton_MainImg.color =
                tabButton_GraphicImg.color = tabOffColor;
                tabButton_FlowChartImg.color = tabOnColor;
                tabButton_SousaImg.color = tabOffColor;
                #endregion

            }
            #endregion
        }

        #endregion

        //メニューの言語設定
        LanguageChangeRealTIme();

        //身長テキスト
        //言語名（メニューの）
        Toggle_NowPlayerSintyouObj.transform.Find("Text").GetComponent<TextMeshProUGUI>().text
            = nowPlayerSintyouFloat.ToString("f1") + " cm";


        //メニューウインドウの位置を見てる方向に
        GameObject defMenuObj = Resources.Load("EventSystem/Menu/Prefab/MenuFolder") as GameObject;
        MenuFolder.transform.SetParent(VRCameraTrs);
        MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
        MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;

        //ポーズOn(位置ズレ対策に1フレ待ち前にポーズ)
        isMenuGamePause = true;

        yield return null;

        MenuFolder.transform.SetParent(CameraAnchorTrs);

        #region ユーザーポーズ時はマウス起動しない（1フレ必要だったのでここ）
        if (isUserGamePause == false)
        {
            //NoVRならマウス占有解除
            if (XRSettings.enabled == false)
            {
                Cursor.lockState = CursorLockMode.None;
            }
            // マウスカーソル起動
            StartCoroutine(MouseCursorSystem());
        }
        #endregion


        #region Contentスクロールデフォルト位置を現在の位置で取得（開くたびにそこへ移動させる用）
        //※フローチャートは開くまで位置が設定されないので、開いた時に移動する。　ので、位置変数はない
        bool
            isFlowChartOpenOnece = false;


        //操作説明
        RectTransform
            sousaWindowContentRectTrs = SousaWindowContentObj.GetComponent<RectTransform>();
        Vector2
            sousaWindowContentDefPos = sousaWindowContentRectTrs.anchoredPosition;
        bool
            isSousaWindowOpenOnece = false;

        #endregion

        #endregion

        #region ループ
        while (isMenuSystem)
        {
            #region ■メニュー挙動（マウスカーソルシステム動いてること前提の色々）

            //マウス、ユーザーゲームポーズじゃない状態前提
            if (isMouseCursorSystem)
            {
                //メニュー範囲外コリダー内かつ
                if (MouseOutMenuCollider.Raycast(mouseRay, out tmpDummyMouseOutMenuColliderRayHit, Mathf.Infinity))
                {
                    //「マウス効く範囲コリダー」に当たってる場合のみ動作
                    if (MouseOnMenuCollider.Raycast(mouseRay, out tmpDummyMouseOnMenuColliderRayHit, Mathf.Infinity))
                    {
                        #region カーソル消してたらつけ
                        if (MouseCursorImage.enabled == false)
                        {
                            MouseCursorImage.enabled = true;
                            Cursor.visible = false;//PCは消し
                        }
                        #endregion

                        //マウスRayがコリダーに当たっていること前提
                        if (Physics.Raycast(mouseRay, out mouseOnMenuRayHit, Mathf.Infinity, mouseRayLayerMask))
                        {
                            //Debug.DrawRay(mouseRay.origin, mouseRay.direction * 100, Color.red);
                            Debug.DrawLine(mouseRay.origin, mouseOnMenuRayHit.point, Color.red);

                            #region 各ボタンに当たっている時
                            if (mouseOnMenuRayHit.collider.tag == "MenuButton")
                            {
                                //決定押したときに
                                if (isKetteiDown == true)
                                {
                                    #region タブメニューボタン
                                    if ("TabButton_Main" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region メニュー■ グラフィック□ フローチャート□ 操作□ 着替え□
                                        //ウィンドウ自体のOnOff（タブボタンではない）
                                        MainMenuWindowCanvasObj.SetActive(true);
                                        GraphicWindowCanvasObj.SetActive(false);
                                        FlowChartWindowCanvasObj.SetActive(false);
                                        SousaWindowCanvasObj.SetActive(false);
                                        ClothsWindowCanvasObj.SetActive(false);

                                        //タブボタンのカラー
                                        tabButton_MainImg.color =
                                            tabOnColor;
                                        tabButton_GraphicImg.color =
                                        tabButton_FlowChartImg.color =
                                        tabButton_SousaImg.color =
                                        tabButton_ClothsImg.color =
                                            tabOffColor;
                                        #endregion
                                    }
                                    else if ("TabButton_Graphic" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region メニュー□ グラフィック■ フローチャート□ 操作□ 着替え□
                                        MainMenuWindowCanvasObj.SetActive(false);
                                        GraphicWindowCanvasObj.SetActive(true);
                                        FlowChartWindowCanvasObj.SetActive(false);
                                        SousaWindowCanvasObj.SetActive(false);
                                        ClothsWindowCanvasObj.SetActive(false);

                                        tabButton_MainImg.color =
                                            tabOffColor;
                                        tabButton_GraphicImg.color =
                                            tabOnColor;
                                        tabButton_FlowChartImg.color =
                                        tabButton_SousaImg.color =
                                        tabButton_ClothsImg.color =
                                            tabOffColor;
                                        #endregion
                                    }
                                    else if ("TabButton_FlowChart" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region メニュー□ グラフィック□ フローチャート■ 操作□ 着替え□
                                        MainMenuWindowCanvasObj.SetActive(false);
                                        GraphicWindowCanvasObj.SetActive(false);
                                        FlowChartWindowCanvasObj.SetActive(true);
                                        SousaWindowCanvasObj.SetActive(false);
                                        ClothsWindowCanvasObj.SetActive(false);

                                        tabButton_MainImg.color =
                                        tabButton_GraphicImg.color =
                                        tabOffColor;
                                        tabButton_FlowChartImg.color = tabOnColor;
                                        tabButton_SousaImg.color =
                                        tabButton_ClothsImg.color =
                                            tabOffColor;
                                        #endregion
                                    }
                                    else if ("TabButton_Sousa" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region メニュー□ グラフィック□ フローチャート□ 操作■ 着替え□
                                        MainMenuWindowCanvasObj.SetActive(false);
                                        GraphicWindowCanvasObj.SetActive(false);
                                        FlowChartWindowCanvasObj.SetActive(false);
                                        SousaWindowCanvasObj.SetActive(true);
                                        ClothsWindowCanvasObj.SetActive(false);

                                        tabButton_MainImg.color =
                                        tabButton_GraphicImg.color =
                                        tabButton_FlowChartImg.color =
                                            tabOffColor;
                                        tabButton_SousaImg.color =
                                            tabOnColor;
                                        tabButton_ClothsImg.color =
                                            tabOffColor;
                                        #endregion
                                    }
                                    else if ("TabButton_Cloths" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region メニュー□ グラフィック□ フローチャート□ 操作□ 着替え■
                                        MainMenuWindowCanvasObj.SetActive(false);
                                        GraphicWindowCanvasObj.SetActive(false);
                                        FlowChartWindowCanvasObj.SetActive(false);
                                        SousaWindowCanvasObj.SetActive(false);
                                        ClothsWindowCanvasObj.SetActive(true);

                                        tabButton_MainImg.color =
                                        tabButton_GraphicImg.color =
                                        tabButton_FlowChartImg.color =
                                        tabButton_SousaImg.color =
                                            tabOffColor;
                                        tabButton_ClothsImg.color =
                                            tabOnColor;
                                        #endregion
                                    }
                                    #endregion
                                    else if ("Button_CameraReset" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        CameraReset(null, null, true);//VRポジションリセット

                                        //■メニューウインドウの位置を見てる方向に
                                        MenuFolder.transform.SetParent(VRCameraTrs);
                                        MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
                                        MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;
                                        yield return null;
                                        MenuFolder.transform.SetParent(CameraAnchorTrs);
                                        SEPlay(UISEObj, "UI_pin");
                                    }
                                    else if ("Button_Save&Exit" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        SEPlay(UISEObj, "UI_p");
                                        StartCoroutine(SaveUserData());

                                        #region ゲーム終了確認ウインドウ（フローチャートのを流用）

                                        #region ウインドウ出現演出
                                        //シーン移動イメージとテキストの親非表示
                                        GameObject tmpRootObj =
                                            FlowChartMoveWindowCanvasObj.transform.Find("ConfirmImgaeText").gameObject;
                                        tmpRootObj.SetActive(false);

                                        Vector3
                                            tmpDefScl = FlowChartMoveWindowCanvasObj.transform.localScale;
                                        FlowChartMoveWindowCanvasObj.transform.localScale = Vector3.zero;

                                        yield return null;

                                        FlowChartMoveWindowCanvasObj.SetActive(true);

                                        FlowChartMoveWindowCanvasObj.transform.DOScale(tmpDefScl, 0.1f)
                                            //.SetEase(Ease.OutBack)
                                            .SetUpdate(true);

                                        //EXTRA非表示
                                        FlowChartMoveWindowCanvasObj.transform.Find("Button_MoveEXTRA").gameObject.SetActive(false);

                                        #endregion
                                        yield return null;

                                        //ゲーム終了説明文表示
                                        FlowChartMoveWindowCanvasObj.transform.Find("GameExitText").gameObject.SetActive(true);

                                        while (isMenuSystem)//Menu終了したら強制終了
                                        {
                                            #region 確認ウィンドウ専用でレイ処理（メニューのとほぼ同じ）
                                            //動いてること前提
                                            if (isMouseCursorSystem)
                                            {
                                                //メニュー範囲外コリダー内かつ
                                                if (MouseOutMenuCollider.Raycast(mouseRay, out tmpDummyMouseOutMenuColliderRayHit, Mathf.Infinity))
                                                {
                                                    //「マウス効く範囲コリダー」に当たってる場合のみ動作
                                                    if (MouseOnMenuCollider.Raycast(mouseRay, out tmpDummyMouseOnMenuColliderRayHit, Mathf.Infinity))
                                                    {
                                                        #region カーソル消してたらつけ
                                                        if (MouseCursorImage.enabled == false)
                                                        {
                                                            MouseCursorImage.enabled = true;
                                                            Cursor.visible = false;//PCは消し
                                                        }
                                                        #endregion
                                                        //マウスRayがコリダーに当たっていること前提
                                                        if (Physics.Raycast(mouseRay, out mouseOnMenuRayHit, Mathf.Infinity, mouseRayLayerMask))
                                                        {
                                                            //決定押したときに
                                                            if (isKetteiDown == true)
                                                            {
                                                                //OKなら
                                                                if ("Button_MoveOK" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                {
                                                                    //セーブしてゲーム終了
                                                                    SEPlay(UISEObj, "UI_fuwa-", 0.4f);
                                                                    isFlowChartEventMove = true;//閉じSEなし
                                                                    isMenuSystem = false;
#if UNITY_EDITOR
                                                                    EditorApplication.isPlaying = false;
#elif UNITY_STANDALONE
      Application.Quit();
#endif
                                                                    break;
                                                                }
                                                                //キャンセルなら
                                                                else if ("Button_MoveCancel" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                {
                                                                    //確認ウィンドウ消して抜け
                                                                    SEPlay(UISEObj, "UI_pata");
                                                                    FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                    break;
                                                                }
                                                                //ウィンドウ内のなにもないところなら
                                                                else if ("MoveWindowCollider" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                { }//なにもしないけど、一応命令保持
                                                                   //ウィンドウ外なら
                                                                else
                                                                {
                                                                    //キャンセルと同じ扱い
                                                                    SEPlay(UISEObj, "UI_pata");
                                                                    FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                    break;
                                                                }
                                                            }
                                                            //Bボタンを押したら
                                                            else if (isBackDown == true)
                                                            {
                                                                //キャンセル扱い
                                                                SEPlay(UISEObj, "UI_pata");
                                                                FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                break;
                                                            }

                                                        }
                                                    }
                                                    else //「マウス効く範囲コリダー」外
                                                    {
                                                        #region PCマウスかつPCプレイならゲームカーソル消し
                                                        if (isMouseStickControll == false)
                                                        {
                                                            if (XRSettings.enabled == false)
                                                            {
                                                                if (MouseCursorImage.enabled)
                                                                {
                                                                    MouseCursorImage.enabled = false;
                                                                    Cursor.visible = true;//PCはつけ
                                                                }
                                                            }
                                                        }
                                                        #endregion
                                                    }
                                                }
                                            }
                                            #endregion
                                            yield return null;
                                        }
                                        //ゲーム終了説明文非表示
                                        FlowChartMoveWindowCanvasObj.transform.Find("GameExitText").gameObject.SetActive(false);

                                        #endregion
                                    }
                                    else if ("Button_GraphicDefault" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        #region 各Graphic設定をデフォルトの値に戻して反映処理
                                        DB.isUserAntialiasing =
                                        DB.isUserAmbientOcclusion =
                                        DB.isUserBloom = true;
                                        //Dof 強制オフでなければ
                                        if (isForceDoF == false) { DB.isUserDepthOfFieldV1 = false; }
                                        //Fov
                                        DB.isUserFog = false;

                                        PPv2FPSLayerComponent.antialiasingMode =
                                        PPv2TPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.FastApproximateAntialiasing;
                                        nowPPv2AmbientOcclusion.active =
                                        nowPPv2Bloom.active = true;
                                        //Dof 強制オフでなければ
                                        if (isForceDoF == false) { postPB.profile.depthOfField.enabled = false; }
                                        //Fov
                                        PPv2FPSLayerComponent.fog.enabled =
                                        PPv2TPSLayerComponent.fog.enabled = false;
                                        RenderSettings.fog = false;

                                        TogglleChange(Toggle_AntialiasingObj, true);
                                        TogglleChange(Toggle_AmbientOcclusionObj, true);
                                        TogglleChange(Toggle_BloomObj, true);

                                        //Dof 強制オフでなければ
                                        if (isForceDoF == false) { TogglleChange(Toggle_DepthOfFieldObj, false); }
                                        //Fov
                                        TogglleChange(Toggle_FogObj, false);


                                        //■スライダーValueと本値
                                        //Dof 強制オフでなければ
                                        if (isForceDoF == false)
                                        {
                                            TogglleChange(Toggle_DepthOfFieldObj, false);

                                            Slider_DepthOfFieldSlider.value = DB.defaultDepthOfFieldV1x50Float - DB.adjustDepthOfFieldV1x50MinFloat;
                                            nowPPv1DepthOfFieldSetting.focusDistance
                                                = DB.userDepthOfFieldV1Float
                                                = DB.defaultDepthOfFieldV1x50Float;
                                            postPB.profile.depthOfField.settings = nowPPv1DepthOfFieldSetting;
                                        }

                                        //FoV
                                        Slider_FieldOfViewSlider.value = DB.defaultFieldOfViewFloat - DB.adjustFieldOfViewMinFloat;
                                        VRCamera.fieldOfView
                                            = DB.userFieldOfViewFloat
                                            = DB.defaultFieldOfViewFloat;

                                        #endregion
                                        SEPlay(UISEObj, "UI_pin");
                                    }
                                    else if ("Button_DebugInfoOutput" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        SEPlay("UI_pin");
                                        #region 情報出力処理
                                        string tmpStr = "スペック\n";
                                        tmpStr += string.Format("OS: {0}", SystemInfo.operatingSystem);
                                        tmpStr += "\n";
                                        tmpStr += string.Format("CPU: {0} / {1}cores", SystemInfo.processorType, SystemInfo.processorCount);
                                        tmpStr += "\n";
                                        tmpStr += string.Format("GPU: {0} / {1}MB API: {2}", SystemInfo.graphicsDeviceName, SystemInfo.graphicsMemorySize, SystemInfo.graphicsDeviceType);
                                        tmpStr += "\n";

                                        const uint mega = 1024 * 1024;
                                        tmpStr += string.Format("Memory: {0:####.0} / {1}.0MB GCCount: {2}", Profiler.usedHeapSizeLong / (float)mega, SystemInfo.systemMemorySize, System.GC.CollectionCount(0));
                                        tmpStr += "\n";

                                        //tmpStr += string.Format("Performance: {0:#0.#}fps", m_fps);
                                        //tmpStr += "\n";

                                        Resolution reso = Screen.currentResolution;
                                        tmpStr += string.Format("Resolution: {0} x {1} RefreshRate: {2}Hz", reso.width, reso.height, reso.refreshRate);
                                        tmpStr += "\n";

                                        //コントローラー
                                        tmpStr += "\nコントローラー\n";
                                        for (int i = 0; i < Input.GetJoystickNames().Length; i++)
                                        {
                                            tmpStr += Input.GetJoystickNames()[i] + "\n";
                                        }

                                        //VR情報　一部
                                        tmpStr += "\n\nVR接続 " + XRSettings.enabled;
                                        tmpStr += "\nXRDevice.model " + XRDevice.model;
                                        tmpStr += "\nXRSettings.loadedDeviceName " + XRSettings.loadedDeviceName;
                                        tmpStr += "\nXRSettings.eyeTextureDesc " + XRSettings.eyeTextureDesc;
                                        tmpStr += "\nXRSettings.eyeTextureHeight " + XRSettings.eyeTextureHeight;
                                        tmpStr += "\nXRSettings.eyeTextureResolutionScale " + XRSettings.eyeTextureResolutionScale;
                                        tmpStr += "\nXRSettings.eyeTextureWidth " + XRSettings.eyeTextureWidth;
                                        tmpStr += "\nXRSettings.gameViewRenderMode " + XRSettings.gameViewRenderMode;
                                        tmpStr += "\nXRSettings.isDeviceActive " + XRSettings.isDeviceActive;
                                        tmpStr += "\nXRSettings.showDeviceView " + XRSettings.showDeviceView;
                                        for (int i = 0; i < XRSettings.supportedDevices.Length; i++)
                                        { tmpStr += "\nXRSettings.supportedDevices " + "i " + XRSettings.supportedDevices[i]; }


                                        #region ファイル名用に時間取得
                                        var tmpTimeStr = System.DateTime.Now.Year.ToString("D4");
                                        tmpTimeStr += System.DateTime.Now.Month.ToString("D2");
                                        tmpTimeStr += System.DateTime.Now.Day.ToString("D2");
                                        tmpTimeStr += System.DateTime.Now.Hour.ToString("D2");
                                        tmpTimeStr += System.DateTime.Now.Minute.ToString("D2");
                                        tmpTimeStr += System.DateTime.Now.Second.ToString("D2");
                                        #endregion

                                        //ファイルに書き出し
                                        using (StreamWriter
                                            writer = new StreamWriter(Application.streamingAssetsPath + "/DebugInfo" + tmpTimeStr + ".json"
                                            , false
                                            , Encoding.GetEncoding("utf-8")))
                                        {
                                            writer.WriteLine(tmpStr);
                                        }


                                        Debug.Log(tmpStr);
                                        #endregion
                                        SubTitleVis(true
                                            , "<size=30>ResizeMe_Data/StreamingAssets/DebugInfo_.json</size>\n<size=40>デバッグ情報テキストを出力しました。</size>"
                                            , 0, true, 0);
                                        mouseOnMenuRayHit.collider.gameObject.SetActive(false);
                                    }
                                    else if ("Button_MoveSetumei" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        SEPlay(UISEObj, "UI_pin");
                                        SousaWindowCanvasObj.SetActive(false);
                                        #region 操作説明 移動ポイント説明表示
                                        GameObject SousaSetumeiKOWindowCanvas;
                                        if (DB.isEnglish)
                                        {
                                            SousaSetumeiKOWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiKOEngWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }
                                        else
                                        {
                                            SousaSetumeiKOWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiKOWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }

                                        //FadeBlack(0.5f, 0.5f);

                                        yield return null;//キーDown解除待ち

                                        SousaSetumeiKOWindowCanvas.transform.SetParent(MenuFolder.transform);

                                        while (
                                            isKetteiDown == false
                                            && isMenuPauseDown == false
                                            )
                                        {
                                            yield return null;
                                        }

                                        //FadeBlack(0, 0.5f);
                                        Destroy(SousaSetumeiKOWindowCanvas);
                                        #endregion
                                        SousaWindowCanvasObj.SetActive(true);
                                        SEPlay(UISEObj, "UI_pata");
                                    }
                                    else if ("Button_ClimbSetumei" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        SEPlay(UISEObj, "UI_pin");
                                        SousaWindowCanvasObj.SetActive(false);
                                        #region 操作説明 登り操作説明表示
                                        GameObject SousaSetumeiANWindowCanvas;
                                        if (DB.isEnglish)
                                        {
                                            SousaSetumeiANWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiANEngWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }
                                        else
                                        {
                                            SousaSetumeiANWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiANWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }

                                        //FadeBlack(0.5f, 0.5f);

                                        yield return null;//キーUp待ち

                                        SousaSetumeiANWindowCanvas.transform.SetParent(MenuFolder.transform);

                                        while (
                                            isKetteiDown == false
                                            && isMenuPauseDown == false
                                            )
                                        {
                                            yield return null;
                                        }

                                        //FadeBlack(0, 0.5f);
                                        Destroy(SousaSetumeiANWindowCanvas);
                                        #endregion
                                        SousaWindowCanvasObj.SetActive(true);
                                        SEPlay(UISEObj, "UI_pata");
                                    }
                                    else if ("Button_TansakuSetumei" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        SEPlay(UISEObj, "UI_pin");
                                        SousaWindowCanvasObj.SetActive(false);
                                        #region 操作説明 探索操作説明表示
                                        GameObject SousaSetumeiTansakuWindowCanvas;
                                        if (DB.isEnglish)
                                        {
                                            SousaSetumeiTansakuWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiTansakuEngWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }
                                        else
                                        {
                                            SousaSetumeiTansakuWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiTansakuWindowCanvas") as GameObject
                                                , VRCameraTrs, false);
                                        }

                                        //FadeBlack(0.5f, 0.5f);

                                        yield return null;//キーUp待ち

                                        SousaSetumeiTansakuWindowCanvas.transform.SetParent(MenuFolder.transform);

                                        while (
                                            isKetteiDown == false
                                            && isMenuPauseDown == false
                                            )
                                        {
                                            yield return null;
                                        }

                                        //FadeBlack(0, 0.5f);
                                        Destroy(SousaSetumeiTansakuWindowCanvas);
                                        #endregion
                                        SousaWindowCanvasObj.SetActive(true);
                                        SEPlay(UISEObj, "UI_pata");
                                    }
                                    else if ("Button_InitialSettingOK" == mouseOnMenuRayHit.collider.gameObject.name)
                                    {
                                        //閉じ
                                        isMouseCursorSystem =
                                        isMenuSystem = false;

                                        //初期設定完了
                                        DB.isUserInitialSetting = true;
                                        SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                    }
                                }
                            }
                            #endregion

                            #region 各トグルに当たっている時
                            else if (mouseOnMenuRayHit.collider.tag == "MenuToggle")
                            {
                                //決定押したときに
                                if (isKetteiDown == true)
                                {
                                    GameObject
                                        itToggleObj = mouseOnMenuRayHit.collider.gameObject;

                                    #region それぞれif処理

                                    #region 言語設定トグル
                                    if (Toggle_EnglishObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isEnglish)
                                        {
                                            //なにもしない
                                        }
                                        else
                                        {
                                            DB.isEnglish = true;
                                            TogglleChange(itToggleObj, true);
                                            TogglleChange(Toggle_JapaneseObj, false);
                                            LanguageChangeRealTIme();
                                        }
                                    }
                                    else if (Toggle_JapaneseObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isEnglish)
                                        {
                                            DB.isEnglish = false;
                                            TogglleChange(itToggleObj, true);
                                            TogglleChange(Toggle_EnglishObj, false);
                                            LanguageChangeRealTIme();
                                        }
                                        else
                                        {
                                            //なにもしない
                                        }
                                    }
                                    #endregion

                                    #region 身長
                                    else if (Toggle_NowPlayerSintyouObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //bool変更 //処理自体はInfoVisSystemIEnum()
                                        if (DB.isUserFixityMakotoHeightVis)
                                        {
                                            DB.isUserFixityMakotoHeightVis =
                                            isInfoMakotoHeightVis = false;//同時に表示も

                                            TogglleChange(Toggle_NowPlayerSintyouObj, DB.isUserFixityMakotoHeightVis);
                                        }
                                        else
                                        {
                                            DB.isUserFixityMakotoHeightVis =
                                            isInfoMakotoHeightVis = true;//同時に表示も

                                            TogglleChange(itToggleObj, DB.isUserFixityMakotoHeightVis);
                                        }
                                    }
                                    #endregion

                                    #region ■Graphicのトグル
                                    else if (Toggle_AntialiasingObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserAntialiasing)
                                        {
                                            DB.isUserAntialiasing = false;
                                            PPv2FPSLayerComponent.antialiasingMode =
                                            PPv2TPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.None;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserAntialiasing = true;
                                            PPv2FPSLayerComponent.antialiasingMode =
                                            PPv2TPSLayerComponent.antialiasingMode = PostProcessLayer.Antialiasing.FastApproximateAntialiasing;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_AmbientOcclusionObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserAmbientOcclusion)
                                        {
                                            DB.isUserAmbientOcclusion = false;
                                            nowPPv2AmbientOcclusion.active = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserAmbientOcclusion = true;
                                            nowPPv2AmbientOcclusion.active = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_BloomObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserBloom)
                                        {
                                            DB.isUserBloom = false;
                                            nowPPv2Bloom.active = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserBloom = true;
                                            nowPPv2Bloom.active = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_DepthOfFieldObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserDepthOfFieldV1)
                                        {
                                            DB.isUserDepthOfFieldV1 = false;
                                            postPB.profile.depthOfField.enabled = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserDepthOfFieldV1 = true;
                                            postPB.profile.depthOfField.enabled = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_FogObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //ためしにこれだけDBのBoolを利用した設定
                                        if (DB.isUserFog)
                                        { DB.isUserFog = false; }
                                        else
                                        { DB.isUserFog = true; }

                                        PPv2FPSLayerComponent.fog.enabled =
                                        PPv2TPSLayerComponent.fog.enabled = DB.isUserFog;
                                        RenderSettings.fog = DB.isUserFog;
                                        TogglleChange(itToggleObj, DB.isUserFog);

                                    }//FieldOfViewはゲージのみ

                                    else if (Toggle_TPSModeObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserTPSMode)
                                        {
                                            DB.isUserTPSMode = false;
                                            isTPSCameraSystem = false;
                                            TogglleChange(itToggleObj, false);

                                            #region VRRotate関係オフ
                                            DB.isUserVRUpDownRotate = DB.isUserVRSmoothRotate = false;
                                            Toggle_VRUpDownRotateObj.SetActive(false);
                                            Toggle_VRSmoothRotateObj.SetActive(false);
                                            TogglleChange(Toggle_VRUpDownRotateObj, false);
                                            TogglleChange(Toggle_VRSmoothRotateObj, false);
                                            #endregion
                                        }
                                        else
                                        {
                                            DB.isUserTPSMode = true;
                                            //TPSCameraシステム起動
                                            StartCoroutine(TPSCameraSystemIEnum());
                                            TogglleChange(itToggleObj, true);

                                            //VR時ならRotate関係 Activeオン
                                            if (XRSettings.enabled)
                                            {
                                                Toggle_VRUpDownRotateObj.SetActive(true);
                                                Toggle_VRSmoothRotateObj.SetActive(true);
                                            }

                                            GraphicWindowCanvasObj.SetActive(false);
                                            #region TPS説明表示
                                            SEPlay("UI_pin");

                                            #region カメラトラッキングリセット
                                            CameraReset(null, null, true);//VRポジションリセット

                                            //■メニューウインドウの位置を見てる方向に
                                            MenuFolder.transform.SetParent(VRCameraTrs);
                                            MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
                                            MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;
                                            yield return null;
                                            MenuFolder.transform.SetParent(CameraAnchorTrs);
                                            #endregion

                                            GameObject SousaSetumeiTPSWindowCanvas;
                                            if (DB.isEnglish)
                                            {
                                                SousaSetumeiTPSWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiTPSEngWindowCanvas") as GameObject
                                                    , VRCameraTrs, false);
                                            }
                                            else
                                            {
                                                SousaSetumeiTPSWindowCanvas = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiTPSWindowCanvas") as GameObject
                                                    , VRCameraTrs, false);
                                            }

                                            yield return null;//キーUp待ち

                                            SousaSetumeiTPSWindowCanvas.transform.SetParent(MenuFolder.transform);

                                            while (
                                                isKetteiDown == false
                                                && isMenuPauseDown == false
                                                )
                                            {
                                                yield return null;
                                            }

                                            Destroy(SousaSetumeiTPSWindowCanvas);
                                            #endregion
                                            GraphicWindowCanvasObj.SetActive(true);
                                            SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                        }
                                    }
                                    else if (Toggle_VRUpDownRotateObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserVRUpDownRotate)
                                        {
                                            DB.isUserVRUpDownRotate = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserVRUpDownRotate = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_VRSmoothRotateObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        if (DB.isUserVRSmoothRotate)
                                        {
                                            DB.isUserVRSmoothRotate = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserVRSmoothRotate = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    #region //フリーカメラモード//（今はメニューに表示しない）
                                    //else if (Toggle_FreeCameraModeObj == mouseOnMenuRayHit.collider.gameObject)
                                    //{
                                    //    if (DB.isUserFreeCameraMode)
                                    //    {
                                    //        DB.isUserFreeCameraMode = false;
                                    //        //DB.isUserFreeCameraModeは FreeをONOFFできるようにするのみで 実システムのオフはこっち
                                    //        isFreeCameraModeSystem = false;

                                    //        TogglleChange(itToggleObj, false);

                                    //        //終了
                                    //    }
                                    //    else
                                    //    {
                                    //        DB.isUserFreeCameraMode = true;
                                    //        TogglleChange(itToggleObj, true);

                                    //        GraphicWindowCanvasObj.SetActive(false);
                                    //        #region 説明表示
                                    //        SEPlay("UI_pin");

                                    //        #region カメラトラッキングリセット
                                    //        CameraReset(null, null, true);//VRポジションリセット

                                    //        //■メニューウインドウの位置を見てる方向に
                                    //        MenuFolder.transform.SetParent(VRCameraTrs);
                                    //        MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
                                    //        MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;
                                    //        yield return null;
                                    //        MenuFolder.transform.SetParent(CameraAnchorTrs);
                                    //        #endregion

                                    //        GameObject SousaSetumeiFreeCameraWindowCanvas;
                                    //        if (DB.isEnglish)
                                    //        {
                                    //            SousaSetumeiFreeCameraWindowCanvas
                                    //                = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiFreeCameraEngWindowCanvas") as GameObject
                                    //                , VRCameraTrs, false);
                                    //        }
                                    //        else
                                    //        {
                                    //            SousaSetumeiFreeCameraWindowCanvas
                                    //                = Instantiate(Resources.Load("EventSystem/Menu/Prefab/SousaSetumeiFreeCameraWindowCanvas") as GameObject
                                    //                , VRCameraTrs, false);
                                    //        }

                                    //        yield return null;//キーUp待ち

                                    //        SousaSetumeiFreeCameraWindowCanvas.transform.SetParent(MenuFolder.transform);

                                    //        while (
                                    //            isKetteiDown == false
                                    //            && isMenuPauseDown == false
                                    //            )
                                    //        {
                                    //            yield return null;
                                    //        }

                                    //        Destroy(SousaSetumeiFreeCameraWindowCanvas);
                                    //        #endregion
                                    //        GraphicWindowCanvasObj.SetActive(true);
                                    //        SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                    //    }
                                    //}
                                    #endregion

                                    #endregion

                                    #region Cloths
                                    else if (Toggle_FixityOutfitObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //bool変更
                                        if (DB.isUserFixityOutfit)
                                        {
                                            DB.isUserFixityOutfit = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserFixityOutfit = true;
                                            TogglleChange(itToggleObj, true);
                                        }
                                    }
                                    else if (Toggle_BarefootObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //bool変更
                                        if (DB.isUserClothsBarefoot)
                                        {
                                            DB.isUserClothsBarefoot = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserClothsBarefoot = true;
                                            TogglleChange(itToggleObj, true);
                                        }

                                        //処理自体はメソッドで
                                        ClothsApply();
                                    }
                                    else if (Toggle_TanktopObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //bool変更
                                        if (DB.isUserClothsTankTop)
                                        {
                                            DB.isUserClothsTankTop = false;
                                            TogglleChange(itToggleObj, false);
                                        }
                                        else
                                        {
                                            DB.isUserClothsTankTop = true;
                                            TogglleChange(itToggleObj, true);

                                            //もしビキニから切り替えだったら
                                            if (DB.isUserClothsBikini)
                                            {
                                                //barefootを表示 トグルオン DBオン
                                                Toggle_BarefootObj.SetActive(true);
                                                TogglleChange(Toggle_BarefootObj, true);
                                                DB.isUserClothsBarefoot = true;

                                                //ビキニ トグルオフ DBオフ
                                                TogglleChange(Toggle_BikiniObj, false);
                                                DB.isUserClothsBikini = false;
                                            }

                                        }

                                        //処理自体はメソッドで
                                        ClothsApply();
                                    }
                                    else if (Toggle_BikiniObj == mouseOnMenuRayHit.collider.gameObject)
                                    {
                                        //bool変更
                                        if (DB.isUserClothsBikini)
                                        {
                                            DB.isUserClothsBikini = false;
                                            TogglleChange(itToggleObj, false);

                                            //barefootを表示 トグルオフ DBオフ
                                            Toggle_BarefootObj.SetActive(true);
                                            TogglleChange(Toggle_BarefootObj, false);
                                            DB.isUserClothsBarefoot = false;

                                            //※結果 制服靴下になる
                                        }
                                        else
                                        {
                                            DB.isUserClothsBikini = true;
                                            TogglleChange(itToggleObj, true);

                                            //barefootを非表示 トグルオフ DBオフ
                                            Toggle_BarefootObj.SetActive(false);
                                            TogglleChange(Toggle_BarefootObj, false);
                                            DB.isUserClothsBarefoot = false;

                                            //Tanktopトグルオフ DBオフ
                                            TogglleChange(Toggle_TanktopObj, false);
                                            DB.isUserClothsTankTop = false;

                                            //※ 結果ビキニになる
                                        }

                                        //処理自体はメソッドで
                                        ClothsApply();
                                    }
                                    #endregion

                                    #endregion
                                }
                            }
                            #endregion

                            #region スライダーに当たっている時
                            else if (mouseOnMenuRayHit.collider.tag == "MenuSlider")
                            {
                                //決定押したときに、スライダー値変更（マウス離すまで）
                                if (isKetteiDown == true)
                                {
                                    //■座標からスライダー値入力
                                    //Width
                                    float width =
                                        mouseOnMenuRayHit.collider.transform.GetComponent<RectTransform>().sizeDelta.x;
                                    //MaxValue
                                    float maxValue =
                                        mouseOnMenuRayHit.collider.transform.parent.GetComponent<Slider>().maxValue;

                                    while (isKettei)
                                    {
                                        //スライダーのローカルから見たマウス位置
                                        float sliderMouseLocalX =
                                            mouseOnMenuRayHit.collider.transform.InverseTransformPoint(MouseCursorObj.transform.position).x;

                                        //当たった位置を、スライダーBackImageのローカルから見てのx位置を、スライダーの値に変換
                                        //((当たった位置ローカルX / Width) * MaxValue = 位置をValueに変換した値)
                                        mouseOnMenuRayHit.collider.transform.parent.GetComponent<Slider>().value
                                            = (sliderMouseLocalX / width) * maxValue;
                                        //□座標からスライダー値入力ここまで


                                        #region それぞれif処理
                                        //最大値から最小値を引いた数がMaxなので最小値をプラスする（スライダー操作が最小値0でないといけない（Rayで座標から入力しているので））
                                        if (Slider_DepthOfFieldObj == mouseOnMenuRayHit.collider.transform.parent.gameObject)
                                        {
                                            nowPPv1DepthOfFieldSetting.focusDistance =
                                                DB.userDepthOfFieldV1Float =
                                                (Slider_DepthOfFieldSlider.value + DB.adjustDepthOfFieldV1x50MinFloat);

                                            //代入
                                            postPB.profile.depthOfField.settings = nowPPv1DepthOfFieldSetting;

                                            //後にx100でやる場合は大きさかイベントでif取る予定

                                        }
                                        else if (Slider_FieldOfViewObj == mouseOnMenuRayHit.collider.transform.parent.gameObject)
                                        {
                                            VRCamera.fieldOfView =
                                            TPSCamera.fieldOfView =
                                            DB.userFieldOfViewFloat =
                                                (Slider_FieldOfViewSlider.value + DB.adjustFieldOfViewMinFloat);
                                        }
                                        #endregion

                                        //音量とマウスレートはスライダーから直接処理されている

                                        yield return null;
                                    }

                                }
                            }
                            #endregion

                            #region フローチャートウィンドウに当たっている時（欄外コマをクリックしないようフローチャートのみ専用範囲コリダー兼）
                            else if (MouseOnFlowChartCollider.Raycast(mouseRay, out tmpDummyMouseOnFlowChartColliderRayHit, Mathf.Infinity))
                            {
                                //コマに当たっている時（↑のフローチャートウィンドウRayではないことに注意）
                                if (mouseOnMenuRayHit.collider.tag == "FlowChartKoma")
                                {
                                    //前回番号と違ったら一回処理
                                    if (nowMouseOnKomaEventInt != int.Parse(mouseOnMenuRayHit.collider.name.Substring(0, 3)))//intに変換 頭三文字
                                    {
                                        //前のアウトライン消してオブジェ更新
                                        if (nowMouseOnKomaObj != null)
                                        { nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(false); }
                                        nowMouseOnKomaObj = mouseOnMenuRayHit.collider.gameObject;

                                        //番号更新（名前がイベントインデックスナンバーなのでintに変換（3桁なので頭三文字）して取得してList参照に使う）
                                        nowMouseOnKomaEventInt = int.Parse(mouseOnMenuRayHit.collider.name.Substring(0, 3));

                                        #region サムネイルをデータ画面に拡大表示
                                        //コマデータ変数に。
                                        var tmpKomaData = flowChartKomaDataObjList[nowMouseOnKomaEventInt].GetComponent<FlowChartKoma>();

                                        //■サムネイルを拡大の方へ更新
                                        //nullならなにもしない
                                        if (tmpKomaData.thumbnailImageSprite == null) { }
                                        //ヒント状態なら（ヒントコマでTrueで、プレイヤー到達状態Falseなら）
                                        else if (tmpKomaData.isHintVisFlag && tmpKomaData.isPlayerVisFlag == false)
                                        {
                                            //image消して透明
                                            komaThumbnailZoomImage.sprite = null;
                                            komaThumbnailZoomImage.color = new Color(0, 0, 0, 1);
                                        }
                                        //前と別画像なら更新 
                                        else if (tmpKomaData.thumbnailImageSprite != komaThumbnailZoomImage.sprite)
                                        {
                                            komaThumbnailZoomImage.sprite = tmpKomaData.thumbnailImageSprite;
                                            komaThumbnailZoomImage.color = new Color(1, 1, 1, 1);//ヒントで消してた時用にカラー更新
                                        }

                                        //コマタイトルをテキストへ
                                        if (DB.isEnglish)
                                        { komaThumbnailTitleText.text = tmpKomaData.eventNameEnglish; }
                                        else
                                        { komaThumbnailTitleText.text = tmpKomaData.eventName; }
                                        //ヒント状態ならヒント
                                        if (tmpKomaData.isHintVisFlag && tmpKomaData.isPlayerVisFlag == false)
                                        {
                                            if (DB.isEnglish)
                                            { komaThumbnailTitleText.text = tmpKomaData.hintMessageEng; }
                                            else { komaThumbnailTitleText.text = tmpKomaData.hintMessage; }
                                        }
                                        #endregion

                                        #region 選択肢List読み取り データ画面へ生成反映

                                        //■まず前回の選択肢オブジェ削除
                                        for (int i = 0; i < nowVisRemaineSentakusiObjList.Count; i++)
                                        { Destroy(nowVisRemaineSentakusiObjList[i]); }
                                        nowVisRemaineSentakusiObjList.Clear();


                                        //タイトルの数だけ処理
                                        for (int i = 0; i < tmpKomaData.sentakushiTitleList.Count; i++)
                                        {
                                            //プロットからクローン生成
                                            GameObject tmpRemainSentakushiObj = Instantiate(RemainSentkusiObjProt);
                                            //選択肢タイトル名に
                                            tmpRemainSentakushiObj.name = tmpKomaData.sentakushiTitleList[i];
                                            //ペアレント（プロットと同じ場所）
                                            tmpRemainSentakushiObj.transform.SetParent(RemainSentkusiObjProt.transform.parent, false);
                                            //Activeに
                                            tmpRemainSentakushiObj.SetActive(true);
                                            //後で削除用にリストへ
                                            nowVisRemaineSentakusiObjList.Add(tmpRemainSentakushiObj);



                                            //選択肢穴Objプロット取得
                                            GameObject sentakushiHoleObjProt = tmpRemainSentakushiObj.transform.GetChild(0).gameObject;

                                            //選択肢sを配列に
                                            string[] tmpSentakushisArray =
                                                tmpKomaData.sentakushisList[i].Split(new string[] { "_s" }, StringSplitOptions.None);

                                            //配列にしたのを今までどおりの処理
                                            for (int k = 0; k < tmpSentakushisArray.Length - 1; k++)//Split配列だと最後空白が入るので-1
                                            {
                                                //生成
                                                GameObject tmpHoleObj
                                                    = Instantiate(sentakushiHoleObjProt
                                                        , tmpRemainSentakushiObj.transform
                                                        , false);

                                                //名前つけ
                                                tmpHoleObj.name = tmpSentakushisArray[k]; //※k = コマデータの中の選択肢sListの中のそれぞれ選択肢を分割したString

                                                //名前に■(選択済みマーク)があれば OnマークTrue
                                                if (tmpHoleObj.name.IndexOf("■") >= 0)
                                                { tmpHoleObj.transform.GetChild(2).gameObject.SetActive(true); }

                                                //名前に□(現在選択しているマーク)があれば アウトラインTrue
                                                if (tmpHoleObj.name.IndexOf("□") == 0)
                                                { tmpHoleObj.transform.GetChild(0).gameObject.SetActive(true); }
                                            }
                                            //プロット表示オフ
                                            sentakushiHoleObjProt.SetActive(false);

                                        }


                                        #endregion
                                        #region //Old_選択肢Obj読み取り データ画面へ生成反映

                                        ////■まず前回の選択肢オブジェ削除
                                        //for (int i = 0; i < nowVisRemaineSentakusiObjList.Count; i++)
                                        //{ Destroy(nowVisRemaineSentakusiObjList[i]); }
                                        //nowVisRemaineSentakusiObjList.Clear();


                                        ////コマデータオブジェから選択肢Obj検索
                                        //foreach (Transform k in flowChartKomaDataObjList[nowMouseOnKomaEventInt].transform)
                                        //{
                                        //    //■選択肢Objだったら
                                        //    if (k.name.IndexOf("S_") == 0)
                                        //    {
                                        //        //プロットからクローン生成
                                        //        GameObject tmpRemainSentakushiObj = Instantiate(RemainSentkusiObjProt);
                                        //        //一応選択肢タイトル名に
                                        //        tmpRemainSentakushiObj.name = k.name;
                                        //        //ペアレント（プロットと同じ場所）
                                        //        tmpRemainSentakushiObj.transform.SetParent(RemainSentkusiObjProt.transform.parent, false);
                                        //        //Activeに
                                        //        tmpRemainSentakushiObj.SetActive(true);
                                        //        //後で削除用にリストへ
                                        //        nowVisRemaineSentakusiObjList.Add(tmpRemainSentakushiObj);


                                        //        //選択肢穴Objプロット取得
                                        //        GameObject sentakushiHoleObjProt = tmpRemainSentakushiObj.transform.GetChild(0).gameObject;
                                        //        //■選択肢の数だけ穴生成　(※最初forでやったがやはり変になった（全部にActive命令が入ったりした）のでforeach)
                                        //        foreach (Transform l in k)
                                        //        {
                                        //            //生成
                                        //            GameObject tmpHoleObj
                                        //                = Instantiate(sentakushiHoleObjProt
                                        //                    , tmpRemainSentakushiObj.transform
                                        //                    , false);

                                        //            //名前つけ
                                        //            tmpHoleObj.name = l.name; //※l = コマデータObjの中の選択肢Objの中のそれぞれ選択肢ObjTrs

                                        //            //名前に■(選択済みマーク)があれば OnマークTrue
                                        //            if (tmpHoleObj.name.IndexOf("■") >= 0)
                                        //            { tmpHoleObj.transform.GetChild(2).gameObject.SetActive(true); }

                                        //            //名前に□(現在選択しているマーク)があれば アウトラインTrue
                                        //            if (tmpHoleObj.name.IndexOf("□") == 0)
                                        //            { tmpHoleObj.transform.GetChild(0).gameObject.SetActive(true); }
                                        //        }
                                        //        //プロット表示オフ
                                        //        sentakushiHoleObjProt.SetActive(false);
                                        //    }
                                        //}




                                        #endregion
                                        //↑隠し選択肢の処理は保留（□■以外のマークをつけておき、周回boolかintで判定し、表示する予定（選択肢フキダシ自体の表示も同じように））

                                        #region BADエンドデータ読み込み データ画面へ生成反映

                                        //■まず前回のBADオブジェ削除
                                        for (int i = 0; i < nowVisRemaineBADObjList.Count; i++)
                                        { Destroy(nowVisRemaineBADObjList[i]); }
                                        nowVisRemaineBADObjList.Clear();

                                        //BADエンド存在すれば
                                        if (tmpKomaData.badEndList.Count > 0)
                                        {
                                            for (int i = 0; i < tmpKomaData.badEndList.Count; i++)
                                            {
                                                //プロットからクローン生成
                                                GameObject tmpBADObj = Instantiate(RemainBADHoleObjProt);
                                                //一応BADタイトル名に
                                                tmpBADObj.name = tmpKomaData.badEndList[i];
                                                //ペアレント（プロットと同じ場所）
                                                tmpBADObj.transform.SetParent(RemainBADHoleObjProt.transform.parent, false);
                                                //Activeに
                                                tmpBADObj.SetActive(true);
                                                //後で削除用にリストへ
                                                nowVisRemaineBADObjList.Add(tmpBADObj);

                                                //名前に■(選択済みマーク)があれば OnマークTrue
                                                if (tmpBADObj.name.IndexOf("■") >= 0)
                                                { tmpBADObj.transform.GetChild(2).gameObject.SetActive(true); }
                                            }
                                        }

                                        #endregion


                                        //アウトライン発光
                                        nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(true);
                                    }

                                    //決定でイベント移動確認ウインドウへ
                                    if (isKetteiDown == true)
                                    {
                                        //コマデータ取得
                                        var tmpKomaData =
                                            flowChartKomaDataObjList[nowMouseOnKomaEventInt].GetComponent<FlowChartKoma>();

                                        //ヒント状態なら
                                        if (tmpKomaData.isHintVisFlag && tmpKomaData.isPlayerVisFlag == false)
                                        { goto 抜け; }

                                        SEPlay(UISEObj, "UI_p");
                                        #region ウインドウ出現演出
                                        Vector3
                                            tmpDefScl = FlowChartMoveWindowCanvasObj.transform.localScale;
                                        FlowChartMoveWindowCanvasObj.transform.localScale = Vector3.zero;

                                        yield return null;

                                        FlowChartMoveWindowCanvasObj.SetActive(true);

                                        FlowChartMoveWindowCanvasObj.transform.DOScale(tmpDefScl, 0.1f)
                                            //.SetEase(Ease.OutBack)
                                            .SetUpdate(true);

                                        #endregion
                                        yield return null;

                                        #region 確認テキスト イメージ表示
                                        //イメージとテキストの親表示
                                        GameObject tmpRootObj =
                                            FlowChartMoveWindowCanvasObj.transform.Find("ConfirmImgaeText").gameObject;
                                        tmpRootObj.SetActive(true);

                                        //■サムネイルとコマタイトルを設定
                                        Image tmpImg =
                                            tmpRootObj.transform.Find("ThumbnailImage").GetComponent<Image>();
                                        TextMeshProUGUI tmpKomaTitleText =
                                            tmpImg.transform.Find("Text").GetComponent<TextMeshProUGUI>();

                                        //Image
                                        if (tmpKomaData.thumbnailImageSprite == null) { }
                                        else
                                        { tmpImg.sprite = tmpKomaData.thumbnailImageSprite; }

                                        //Text
                                        if (DB.isEnglish)
                                        { tmpKomaTitleText.text = tmpKomaData.eventNameEnglish; }
                                        else
                                        { tmpKomaTitleText.text = tmpKomaData.eventName; }

                                        //EXTRA非表示
                                        FlowChartMoveWindowCanvasObj.transform.Find("Button_MoveEXTRA").gameObject.SetActive(false);
                                        //EXTRA
                                        if (tmpKomaData.isEXTRA)
                                        { FlowChartMoveWindowCanvasObj.transform.Find("Button_MoveEXTRA").gameObject.SetActive(true); }

                                        #endregion

                                        while (isMenuSystem)//Menu終了したら強制終了
                                        {
                                            #region 確認ウィンドウ専用でレイ処理（メニューのとほぼ同じ）
                                            //動いてること前提
                                            if (isMouseCursorSystem)
                                            {
                                                //メニュー範囲外コリダー内かつ
                                                if (MouseOutMenuCollider.Raycast(mouseRay, out tmpDummyMouseOutMenuColliderRayHit, Mathf.Infinity))
                                                {
                                                    //「マウス効く範囲コリダー」に当たってる場合のみ動作
                                                    if (MouseOnMenuCollider.Raycast(mouseRay, out tmpDummyMouseOnMenuColliderRayHit, Mathf.Infinity))
                                                    {
                                                        #region カーソル消してたらつけ
                                                        if (MouseCursorImage.enabled == false)
                                                        {
                                                            MouseCursorImage.enabled = true;
                                                            Cursor.visible = false;//PCは消し
                                                        }
                                                        #endregion
                                                        //マウスRayがコリダーに当たっていること前提
                                                        if (Physics.Raycast(mouseRay, out mouseOnMenuRayHit, Mathf.Infinity, mouseRayLayerMask))
                                                        {
                                                            //決定押したときに
                                                            if (isKetteiDown == true)
                                                            {
                                                                DB.isEXTRAEnter = false;//事前オフ
                                                                //OKなら
                                                                if ("Button_MoveOK" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                {
                                                                    //メニュー終了してイベント移動
                                                                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                                                    SEPlay(UISEObj, "UI_fuwa-", 0.4f);

                                                                    BGMPlay(false, null, 0, 3f, 3f);//BGMフェードアウト
                                                                    isFlowChartEventMove = true;//閉じSEなし
                                                                    isMenuSystem = false;//メニュー消し
                                                                    isMenuLock = true;//メニューロック
                                                                    isANSystem = false;

                                                                    EventMove(nowMouseOnKomaEventInt, true, true);
                                                                    break;
                                                                }
                                                                //キャンセルなら
                                                                else if ("Button_MoveCancel" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                {
                                                                    //確認ウィンドウ消して抜け
                                                                    SEPlay(UISEObj, "UI_pata");
                                                                    FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                    break;
                                                                }
                                                                //EXTRAなら
                                                                else if ("Button_MoveEXTRA" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                {
                                                                    //メニュー終了してイベント移動
                                                                    SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                                                    SEPlay(UISEObj, "UI_fuwa-", 0.4f);

                                                                    BGMPlay(false, null, 0, 3f, 3f);//BGMフェードアウト
                                                                    isFlowChartEventMove = true;//閉じSEなし
                                                                    isMenuSystem = false;//メニュー消し
                                                                    isMenuLock = true;//メニューロック
                                                                    isANSystem = false;
                                                                    DB.isEXTRAEnter = true;

                                                                    EventMove(nowMouseOnKomaEventInt, true, true);
                                                                    break;
                                                                }                                                                //ウィンドウ内のなにもないところなら
                                                                else if ("MoveWindowCollider" == mouseOnMenuRayHit.collider.gameObject.name)
                                                                { }//なにもしないけど、一応命令保持
                                                                   //ウィンドウ外なら
                                                                else
                                                                {
                                                                    //キャンセルと同じ扱い
                                                                    SEPlay(UISEObj, "UI_pata");
                                                                    FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                    break;
                                                                }
                                                            }
                                                            //Bボタンを押したら
                                                            else if (isBackDown == true)
                                                            {
                                                                //キャンセル扱い
                                                                SEPlay(UISEObj, "UI_pata");
                                                                FlowChartMoveWindowCanvasObj.SetActive(false);
                                                                break;
                                                            }

                                                        }
                                                    }
                                                    else //「マウス効く範囲コリダー」外
                                                    {
                                                        #region PCマウスかつPCプレイならゲームカーソル消し
                                                        if (isMouseStickControll == false)
                                                        {
                                                            if (XRSettings.enabled == false)
                                                            {
                                                                if (MouseCursorImage.enabled)
                                                                {
                                                                    MouseCursorImage.enabled = false;
                                                                    Cursor.visible = true;//PCはつけ
                                                                }
                                                            }
                                                        }
                                                        #endregion
                                                    }
                                                }
                                            }
                                            #endregion
                                            yield return null;
                                        }
                                    }
                                    抜け:;
                                }
                                //何も指してない（指してるのがコマじゃなかったら）
                                else
                                {
                                    //番号-1じゃなければ一回処理
                                    if (nowMouseOnKomaEventInt != -1)
                                    {
                                        //番号nullの代わりに-1
                                        nowMouseOnKomaEventInt = -1;

                                        //アウトライン消し コマオブジェ指定null
                                        if (nowMouseOnKomaObj != null)
                                        {
                                            nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(false);
                                            nowMouseOnKomaObj = null;
                                        }
                                    }
                                }
                                #region マウススクロールでContentスクロール
                                if (mouseWheelFloat != 0f)
                                {
                                    flowChartContentRectTrs.anchoredPosition
                                          -= new Vector2(0, (mouseWheelFloat * 30) * Time.unscaledDeltaTime);
                                }
                                #endregion
                                #region 上下入力ボタンダウン化しint1ずつ操作（Contentスクロール）（今は選択上下AXIS兼のため、XBOX時のみに）
                                if (DB.playerController == DataBridging.PlayerVRController.Xbox)
                                {
                                    if (sentakuAxisY == 1f || sentakuAxisY == 1f)
                                    {
                                        //Debug.Log("Up Key");
                                        flowChartContentRectTrs.anchoredPosition -= new Vector2(0,
                                            1 * Time.unscaledDeltaTime);
                                    }
                                    if (sentakuAxisY == -1f || sentakuAxisY == -1f)
                                    {
                                        //Debug.Log("Down Key");
                                        flowChartContentRectTrs.anchoredPosition += new Vector2(0,
                                            1 * Time.unscaledDeltaTime);
                                    }
                                }


                                #endregion
                            }

                            #endregion
                        }
                    }
                    //何も指してない（メニューウインドウ外だったら）
                    else
                    {
                        #region PCマウスかつPCプレイならゲームカーソル消し
                        if (isMouseStickControll == false)
                        {
                            if (XRSettings.enabled == false)
                            {
                                if (MouseCursorImage.enabled)
                                {
                                    MouseCursorImage.enabled = false;
                                    Cursor.visible = true;//PCはつけ
                                }
                            }
                        }
                        #endregion

                        #region フローチャート ・アウトライン消し
                        //番号-1じゃなければ一回処理
                        if (nowMouseOnKomaEventInt != -1)
                        {
                            //番号nullの代わりに-1
                            nowMouseOnKomaEventInt = -1;

                            //アウトライン消し コマオブジェ指定null
                            if (nowMouseOnKomaObj != null)
                            {
                                nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(false);
                                nowMouseOnKomaObj = null;
                            }
                        }
                        #endregion                        
                    }

                }
                #region キーボード操作系 タブメニュー切り替えや身長

                #region タブメニュー切り替え
                if (Input.GetButtonDown(DB.inputDict["右手"])
                    || isBackDown)
                {
                    if (MainMenuWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック■ フローチャート□ 操作□ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(true);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                            tabOffColor;
                        tabButton_GraphicImg.color =
                            tabOnColor;
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                    else if (GraphicWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート■ 操作□ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(true);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabOffColor;
                        tabButton_FlowChartImg.color = tabOnColor;
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion

                    }
                    else if (FlowChartWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート□ 操作■ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(true);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                            tabOffColor;
                        tabButton_SousaImg.color =
                            tabOnColor;
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                    else if (SousaWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート□ 操作□ 着替え■
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(true);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                            tabOffColor;
                        tabButton_ClothsImg.color =
                            tabOnColor;
                        #endregion

                    }
                    else if (ClothsWindowCanvasObj.activeSelf)
                    {
                        #region メニュー■ グラフィック□ フローチャート□ 操作□ 着替え□
                        //ウィンドウ自体のOnOff（タブボタンではない）
                        MainMenuWindowCanvasObj.SetActive(true);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        //タブボタンのカラー
                        tabButton_MainImg.color =
                            tabOnColor;
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                }
                else if (Input.GetButtonDown(DB.inputDict["左手"]))
                {
                    if (MainMenuWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート□ 操作□ 着替え■
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(true);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                            tabOffColor;
                        tabButton_ClothsImg.color =
                            tabOnColor;
                        #endregion
                    }
                    else if (GraphicWindowCanvasObj.activeSelf)
                    {
                        #region メニュー■ グラフィック□ フローチャート□ 操作□ 着替え□
                        //ウィンドウ自体のOnOff（タブボタンではない）
                        MainMenuWindowCanvasObj.SetActive(true);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        //タブボタンのカラー
                        tabButton_MainImg.color =
                            tabOnColor;
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                    else if (FlowChartWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック■ フローチャート□ 操作□ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(true);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                            tabOffColor;
                        tabButton_GraphicImg.color =
                            tabOnColor;
                        tabButton_FlowChartImg.color =
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                    else if (SousaWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート■ 操作□ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(true);
                        SousaWindowCanvasObj.SetActive(false);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabOffColor;
                        tabButton_FlowChartImg.color = tabOnColor;
                        tabButton_SousaImg.color =
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                    else if (ClothsWindowCanvasObj.activeSelf)
                    {
                        #region メニュー□ グラフィック□ フローチャート□ 操作■ 着替え□
                        MainMenuWindowCanvasObj.SetActive(false);
                        GraphicWindowCanvasObj.SetActive(false);
                        FlowChartWindowCanvasObj.SetActive(false);
                        SousaWindowCanvasObj.SetActive(true);
                        ClothsWindowCanvasObj.SetActive(false);

                        tabButton_MainImg.color =
                        tabButton_GraphicImg.color =
                        tabButton_FlowChartImg.color =
                            tabOffColor;
                        tabButton_SousaImg.color =
                            tabOnColor;
                        tabButton_ClothsImg.color =
                            tabOffColor;
                        #endregion
                    }
                }
                #endregion

                #region //身長表示
                //if (Input.GetKeyDown(KeyCode.M))
                //{
                //    TogglleChange(Toggle_NowPlayerSintyouObj, isInfoMakotoHeightVis);
                //}

                #endregion

                #endregion
            }
            //ユーザーゲームポーズでなくなったら
            else if (isUserGamePause == false)
            {
                //NoVRならマウス占有解除
                if (XRSettings.enabled == false)
                {
                    Cursor.lockState = CursorLockMode.None;
                }
                //もしマウスカーソル動いてなかったら起動
                StartCoroutine(MouseCursorSystem());

                //メニューウインドウの位置を見てる方向に
                MenuFolder.transform.SetParent(VRCameraTrs);
                MenuFolder.transform.localPosition = defMenuObj.transform.localPosition;
                MenuFolder.transform.localEulerAngles = defMenuObj.transform.localEulerAngles;
                yield return null;
                MenuFolder.transform.SetParent(CameraAnchorTrs);
            }

            #endregion

            #region フローチャート スティックでのカーソルが範囲はみ出たらその分動く
            if (cursorClampOutYFlt > 0)
            {
                flowChartContentRectTrs.anchoredPosition -= new Vector2(0,
                    1 * Time.unscaledDeltaTime);
            }
            else if (cursorClampOutYFlt < 0)
            {
                flowChartContentRectTrs.anchoredPosition += new Vector2(0,
                    1 * Time.unscaledDeltaTime);
            }


            #endregion
            #region フローチャート初回開き時に現在コマへ移動
            if (FlowChartWindowCanvasObj.activeSelf)
            {
                if (isFlowChartOpenOnece == false)
                {
                    //メインイベント(存在していたら)
                    if (mainEventKomaObj != null)
                    {
                        #region そのコマ位置へ移動（選択状態にもする）
                        //一瞬で移動する用に一旦速度0
                        var tmpScrollRect =
                            FlowChartScrollRectObj.GetComponent<ScrollRect>();
                        float defElasticity = tmpScrollRect.elasticity;
                        tmpScrollRect.elasticity = 0;

                        yield return null;//表示するのを待つために1フレ必要（これのためにここで設定することになっている）

                        flowChartContentRectTrs.localPosition = new Vector3(flowChartContentRectTrs.localPosition.x
                            , -mainEventKomaObj.transform.parent.localPosition.y
                            - 0.35f//調整（真ん中ぐらいに来るように）
                            , flowChartContentRectTrs.localPosition.z);

                        #region フローチャートは現在コマを選択状態にする処理も（マウス当てたときと同じ処理）

                        //「//コマに当たっている時（↑のフローチャートウィンドウRayではないことに注意）」と同じ処理
                        //mouseOnMenuRayHit.collider　を　mainEventKomaObj　に変えただけ

                        //前のアウトライン消してオブジェ更新
                        if (nowMouseOnKomaObj != null)
                        { nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(false); }
                        nowMouseOnKomaObj = mainEventKomaObj.gameObject;

                        //番号更新（名前がイベントインデックスナンバーなのでintに変換（3桁なので頭三文字）して取得してList参照に使う）
                        nowMouseOnKomaEventInt = int.Parse(mainEventKomaObj.name.Substring(0, 3));

                        #region サムネイルをデータ画面に拡大表示
                        //コマデータ変数に。
                        var tmpKomaData = flowChartKomaDataObjList[nowMouseOnKomaEventInt].GetComponent<FlowChartKoma>();

                        //■サムネイルを拡大の方へ更新
                        //前と別画像なら更新 nullならなにもしない
                        if (tmpKomaData.thumbnailImageSprite == null) { }
                        else if (tmpKomaData.thumbnailImageSprite != komaThumbnailZoomImage.sprite)
                        { komaThumbnailZoomImage.sprite = tmpKomaData.thumbnailImageSprite; }

                        //コマタイトルをテキストへ
                        if (DB.isEnglish)
                        {
                            //無ければ日本語
                            if (tmpKomaData.eventNameEnglish == null) { komaThumbnailTitleText.text = tmpKomaData.eventName; }
                            else { komaThumbnailTitleText.text = tmpKomaData.eventNameEnglish; }
                        }
                        else
                        { komaThumbnailTitleText.text = tmpKomaData.eventName; }

                        #endregion

                        #region 選択肢List読み取り データ画面へ生成反映

                        //■まず前回の選択肢オブジェ削除
                        for (int i = 0; i < nowVisRemaineSentakusiObjList.Count; i++)
                        { Destroy(nowVisRemaineSentakusiObjList[i]); }
                        nowVisRemaineSentakusiObjList.Clear();


                        //タイトルの数だけ処理
                        for (int i = 0; i < tmpKomaData.sentakushiTitleList.Count; i++)
                        {
                            //プロットからクローン生成
                            GameObject tmpRemainSentakushiObj = Instantiate(RemainSentkusiObjProt);
                            //選択肢タイトル名に
                            tmpRemainSentakushiObj.name = tmpKomaData.sentakushiTitleList[i];
                            //ペアレント（プロットと同じ場所）
                            tmpRemainSentakushiObj.transform.SetParent(RemainSentkusiObjProt.transform.parent, false);
                            //Activeに
                            tmpRemainSentakushiObj.SetActive(true);
                            //後で削除用にリストへ
                            nowVisRemaineSentakusiObjList.Add(tmpRemainSentakushiObj);



                            //選択肢穴Objプロット取得
                            GameObject sentakushiHoleObjProt = tmpRemainSentakushiObj.transform.GetChild(0).gameObject;

                            //選択肢sを配列に
                            string[] tmpSentakushisArray =
                                tmpKomaData.sentakushisList[i].Split(new string[] { "_s" }, StringSplitOptions.None);

                            //配列にしたのを今までどおりの処理
                            for (int k = 0; k < tmpSentakushisArray.Length - 1; k++)//Split配列だと最後空白が入るので-1
                            {
                                //生成
                                GameObject tmpHoleObj
                                    = Instantiate(sentakushiHoleObjProt
                                        , tmpRemainSentakushiObj.transform
                                        , false);

                                //名前つけ
                                tmpHoleObj.name = tmpSentakushisArray[k]; //※k = コマデータの中の選択肢sListの中のそれぞれ選択肢を分割したString

                                //名前に■(選択済みマーク)があれば OnマークTrue
                                if (tmpHoleObj.name.IndexOf("■") >= 0)
                                { tmpHoleObj.transform.GetChild(2).gameObject.SetActive(true); }

                                //名前に□(現在選択しているマーク)があれば アウトラインTrue
                                if (tmpHoleObj.name.IndexOf("□") == 0)
                                { tmpHoleObj.transform.GetChild(0).gameObject.SetActive(true); }
                            }
                            //プロット表示オフ
                            sentakushiHoleObjProt.SetActive(false);

                        }


                        #endregion
                        //↑隠し選択肢の処理は保留（□■以外のマークをつけておき、周回boolかintで判定し、表示する予定（選択肢フキダシ自体の表示も同じように））

                        #region BADエンドデータ読み込み データ画面へ生成反映

                        //■まず前回のBADオブジェ削除
                        for (int i = 0; i < nowVisRemaineBADObjList.Count; i++)
                        { Destroy(nowVisRemaineBADObjList[i]); }
                        nowVisRemaineBADObjList.Clear();

                        //BADエンド存在すれば
                        if (tmpKomaData.badEndList.Count > 0)
                        {
                            for (int i = 0; i < tmpKomaData.badEndList.Count; i++)
                            {
                                //プロットからクローン生成
                                GameObject tmpBADObj = Instantiate(RemainBADHoleObjProt);
                                //一応BADタイトル名に
                                tmpBADObj.name = tmpKomaData.badEndList[i];
                                //ペアレント（プロットと同じ場所）
                                tmpBADObj.transform.SetParent(RemainBADHoleObjProt.transform.parent, false);
                                //Activeに
                                tmpBADObj.SetActive(true);
                                //後で削除用にリストへ
                                nowVisRemaineBADObjList.Add(tmpBADObj);

                                //名前に■(選択済みマーク)があれば OnマークTrue
                                if (tmpBADObj.name.IndexOf("■") >= 0)
                                { tmpBADObj.transform.GetChild(2).gameObject.SetActive(true); }
                            }
                        }

                        #endregion


                        //アウトライン発光
                        nowMouseOnKomaObj.transform.Find("OutlineMouseOn").gameObject.SetActive(true);
                        #endregion

                        yield return null;
                        //一瞬で移動させたので速度戻し
                        tmpScrollRect.elasticity = defElasticity;

                        #endregion
                    }
                    isFlowChartOpenOnece = true;

                    #region //コマデータ開いて1フレーム経ったことでコマ並ぶので、ライン引く （破綻したので一旦止め（obj表示でキャンバスからはみ出る）(プレイヤーチョイスenumの分岐追いがややこしい（Twoを選んだらTwoのままにしなきゃいけない。2重分岐でfourやfiveが来た時破綻）)）
                    //yield return null;//コマがない時は1フレ経たないので保険

                    ////現在シーンまでしか線繋がない。
                    ////・内部的にはone Twoのenumでラインが引かれる
                    ////　・分岐のあるコマにプレイヤー用のenum変数があり、選んでいる方のenmuに線を引いていく
                    ////　　・そのenmuはその分岐イベント自体でコマデータを遠隔変更する。

                    ////■ラインオブジェクトをプロットからクローン
                    //GameObject SceneLineObj =
                    //    Instantiate(FlowChartProtFolderObj.transform.Find("SceneLineObjProt").gameObject);

                    ////まず、一個でも時間フォルダ（コマ）生成されてるか確認
                    //if (FlowChartContentObj.transform.childCount > 0)
                    //{
                    //    LineRenderer lineRenderer = SceneLineObj.GetComponent<LineRenderer>();

                    //    //Contentフォルダに　時間フォルダ/コマフォルダ　と入っているのでforeach
                    //    int kInt = 0; //連番
                    //    Vector3 tmpLinePos = new Vector3(0,0.045f,0); //ライン位置取得用変数
                    //    var tmpPlayerChoiceLineEnum = flowChartLine.その他;//その他スタート(playerChoiceLineを読み取って変えていく)
                    //    foreach (RectTransform k in FlowChartContentObj.transform)
                    //    {
                    //        //0個目だけは処理が少し特別
                    //        if (kInt == 0)
                    //        {
                    //            //現在のLineEnumのコマ探し //時間フォルダの中にコマが入っているのでforeach
                    //            foreach (Transform l in k)
                    //            {
                    //                //現在チョイスラインEnumと同じコマだったら、それのx位置読み取り（0個目は今の所その他確定）
                    //                if (l.GetComponent<FlowChartKoma>().flowChartLine == tmpPlayerChoiceLineEnum)
                    //                { tmpLinePos.x = l.localPosition.x; }
                    //            }

                    //            //ライン位置セット
                    //            lineRenderer.positionCount++;
                    //            lineRenderer.SetPosition(kInt, tmpLinePos);

                    //            //0個目の時間フォルダにラインObjペアレント(先にペアレントしてると、↑のforeachでコマデータ読もうとしてしまう)
                    //            SceneLineObj.transform.SetParent(k, false);

                    //        }
                    //        else //1個目以降（y位置が0個目と違う）
                    //        {
                    //            //現在のLineEnumのコマ探し //時間フォルダの中にコマが入っているのでforeach
                    //            foreach (RectTransform l in k)
                    //            {
                    //                Debug.Log(l.name);
                    //                //フローチャートコマ持ってるもののみ
                    //                if (l.GetComponent<FlowChartKoma>())
                    //                {
                    //                    //現在チョイスラインEnumと同じコマだったら、それのx位置にしてy位置は追加
                    //                    if (l.GetComponent<FlowChartKoma>().flowChartLine == tmpPlayerChoiceLineEnum)
                    //                    {
                    //                        tmpLinePos.x = l.anchoredPosition.x;
                    //                        tmpLinePos.y += -0.11f;//時間フォルダずれ分のy追加

                    //                        //そのコマのplayerChoiceLineがtmpと違ったら更新
                    //                        if (l.GetComponent<FlowChartKoma>().playerChoiceLine != tmpPlayerChoiceLineEnum)
                    //                        { tmpPlayerChoiceLineEnum = l.GetComponent<FlowChartKoma>().playerChoiceLine; }
                    //                    }
                    //                }
                    //            }

                    //            //ライン位置セット
                    //            lineRenderer.positionCount++;
                    //            lineRenderer.SetPosition(kInt, tmpLinePos);
                    //        }


                    //        kInt++;
                    //    }

                    //}
                    ////一個も時間フォルダなかったのでなにもしない
                    //else
                    //{ }


                    #endregion

                }
            }
            else
            {
                //開くたびにピクッと動くのが目立つので、一回のみに
                //if (isFlowChartOpenOnece)
                //{ isFlowChartOpenOnece = false; }
            }
            #endregion

            #region 操作ウィンドウ開いてる時処理
            if (SousaWindowCanvasObj.activeSelf)
            {
                #region Content 該当ウィンドウ開いたら初期位置へ
                if (isSousaWindowOpenOnece == false)
                {
                    sousaWindowContentRectTrs.anchoredPosition = sousaWindowContentDefPos;
                    isSousaWindowOpenOnece = true;
                }
                #endregion
                #region マウススクロールで操作説明Contentスクロール
                if (mouseWheelFloat != 0f)
                {
                    sousaWindowContentRectTrs.anchoredPosition
                          -= new Vector2(0, (mouseWheelFloat * 30) * Time.unscaledDeltaTime);
                }
                #endregion

                #region 上下入力ボタンダウン化しint1ずつ操作（Contentスクロール）（選択上下AXIS兼のため、今はXBOX時のみ）
                if (DB.playerController == DataBridging.PlayerVRController.Xbox)
                {
                    if (sentakuAxisY == 1f || sentakuAxisY == 1f)
                    {
                        sousaWindowContentRectTrs.anchoredPosition -= new Vector2(0,
                            1 * Time.unscaledDeltaTime);
                    }
                    if (sentakuAxisY == -1f || sentakuAxisY == -1f)
                    {
                        sousaWindowContentRectTrs.anchoredPosition += new Vector2(0,
                            1 * Time.unscaledDeltaTime);
                    }
                }
                #endregion
            }
            else
            {
                if (isSousaWindowOpenOnece)
                { isSousaWindowOpenOnece = false; }
            }
            #endregion

            #region ■コンティニュー時強制 フローチャート移動確認ウインドウ（コードコピペしてるだけなので後々注意）
            if (isContinue)
            {
                isContinue = false;

                SEPlay(UISEObj, "UI_p");
                #region ウインドウ出現演出
                Vector3
                    tmpDefScl = FlowChartMoveWindowCanvasObj.transform.localScale;
                FlowChartMoveWindowCanvasObj.transform.localScale = Vector3.zero;

                yield return null;

                FlowChartMoveWindowCanvasObj.SetActive(true);

                FlowChartMoveWindowCanvasObj.transform.DOScale(tmpDefScl, 0.1f)
                    //.SetEase(Ease.OutBack)
                    .SetUpdate(true);

                #endregion
                yield return null;

                #region 確認テキスト イメージ表示
                //イメージとテキストの親表示
                GameObject tmpRootObj =
                    FlowChartMoveWindowCanvasObj.transform.Find("ConfirmImgaeText").gameObject;
                tmpRootObj.SetActive(true);

                //■サムネイルとコマタイトルを設定
                Image tmpImg =
                    tmpRootObj.transform.Find("ThumbnailImage").GetComponent<Image>();
                TextMeshProUGUI tmpKomaTitleText =
                    tmpImg.transform.Find("Text").GetComponent<TextMeshProUGUI>();
                var tmpKomaData =
                    flowChartKomaDataObjList[nowMouseOnKomaEventInt].GetComponent<FlowChartKoma>();

                //Image
                if (tmpKomaData.thumbnailImageSprite == null) { }
                else
                { tmpImg.sprite = tmpKomaData.thumbnailImageSprite; }

                //Text
                if (DB.isEnglish)
                { tmpKomaTitleText.text = tmpKomaData.eventNameEnglish; }
                else
                { tmpKomaTitleText.text = tmpKomaData.eventName; }


                #endregion

                while (isMenuSystem)//Menu終了したら強制終了
                {
                    #region 確認ウィンドウ専用でレイ処理（メニューのとほぼ同じ）
                    //動いてること前提
                    if (isMouseCursorSystem)
                    {
                        //メニュー範囲外コリダー内かつ
                        if (MouseOutMenuCollider.Raycast(mouseRay, out tmpDummyMouseOutMenuColliderRayHit, Mathf.Infinity))
                        {
                            //「マウス効く範囲コリダー」に当たってる場合のみ動作
                            if (MouseOnMenuCollider.Raycast(mouseRay, out tmpDummyMouseOnMenuColliderRayHit, Mathf.Infinity))
                            {
                                #region カーソル消してたらつけ
                                if (MouseCursorImage.enabled == false)
                                {
                                    MouseCursorImage.enabled = true;
                                    Cursor.visible = false;//PCは消し
                                }
                                #endregion
                                //マウスRayがコリダーに当たっていること前提
                                if (Physics.Raycast(mouseRay, out mouseOnMenuRayHit, Mathf.Infinity, mouseRayLayerMask))
                                {
                                    //決定押したときに
                                    if (isKetteiDown == true)
                                    {
                                        //OKなら
                                        if ("Button_MoveOK" == mouseOnMenuRayHit.collider.gameObject.name)
                                        {
                                            //メニュー終了してイベント移動
                                            SEPlay(UISEObj, "ui_scifi_hightech_confirm");
                                            SEPlay(UISEObj, "UI_fuwa-", 0.4f);

                                            BGMPlay(false, null, 0, 3f, 3f);//BGMフェードアウト
                                            isFlowChartEventMove = true;//閉じSEなし
                                            isMenuSystem = false;//メニュー消し
                                            isMenuLock = true;//メニューロック
                                            EventMove(nowMouseOnKomaEventInt, true, true);
                                            break;
                                        }
                                        //キャンセルなら
                                        else if ("Button_MoveCancel" == mouseOnMenuRayHit.collider.gameObject.name)
                                        {
                                            //確認ウィンドウ消して抜け
                                            SEPlay(UISEObj, "UI_pata");
                                            FlowChartMoveWindowCanvasObj.SetActive(false);
                                            break;
                                        }
                                        //ウィンドウ内のなにもないところなら
                                        else if ("MoveWindowCollider" == mouseOnMenuRayHit.collider.gameObject.name)
                                        { }//なにもしないけど、一応命令保持
                                           //ウィンドウ外なら
                                        else
                                        {
                                            //キャンセルと同じ扱い
                                            SEPlay(UISEObj, "UI_pata");
                                            FlowChartMoveWindowCanvasObj.SetActive(false);
                                            break;
                                        }
                                    }
                                    //Bボタンを押したら
                                    else if (isBackDown == true)
                                    {
                                        //キャンセル扱い
                                        SEPlay(UISEObj, "UI_pata");
                                        FlowChartMoveWindowCanvasObj.SetActive(false);
                                        break;
                                    }

                                }
                            }
                            else //「マウス効く範囲コリダー」外
                            {
                                #region PCマウスかつPCプレイならゲームカーソル消し
                                if (isMouseStickControll == false)
                                {
                                    if (XRSettings.enabled == false)
                                    {
                                        if (MouseCursorImage.enabled)
                                        {
                                            MouseCursorImage.enabled = false;
                                            Cursor.visible = true;//PCはつけ
                                        }
                                    }
                                }
                                #endregion
                            }
                        }
                    }
                    #endregion
                    yield return null;
                }
            }
            #endregion

            yield return null;
        }


        #endregion

        //■作業
        //BAD穴
        //PlayerVisで見てないイベントコマ非表示かロックコマに
        //現在のフラグ状況で線つなぎ（フラグをコマに持たせるか、フラグを直接読み取って処理するか）

        //ロード中メニュー出せないように

        //順番並べ替えとライン繋ぎ
        //現コマからなにに繋ぐかの指定をコマデータに入れる？
        //プレイヤーが辿ってるラインと辿ってないライン

        //■保留
        //フローチャートコマ一覧ウインドウの拡大縮小

        #region 終了処理
        ////終了音
        //if (
        //    isFlowChartEventMove == false ||
        //    DB.isUserInitialSetting == false
        //    )
        //{ SEPlay(UISEObj, "UI_pata"); }


        Destroy(MenuFolder);
        //マウス終了
        isMouseCursorSystem = false;
        //マウス占有
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        //ポーズ解除
        isMenuGamePause = false;
        #endregion
        yield break;
    }

    //リアルタイムで言語変更できるところを変更
    void LanguageChangeRealTIme()
    {
        #region 言語設定関係なく一定のものMisc
        //言語名(初起動の)
        InitialSettingWindowCanvasObj.transform.Find("Toggle_English/Text").GetComponent<Text>().text
            =
        //言語名（メニューの）
        MainMenuWindowCanvasObj.transform.Find("Toggle_English/Text").GetComponent<Text>().text
            = engMiscDict["LanguageName"];

        #endregion

        if (DB.isEnglish)
        {
            //Main
            MainMenuWindowCanvasObj.transform.Find("Slider_Master/Text").GetComponent<Text>().text
                = "MasterVolume";
            MainMenuWindowCanvasObj.transform.Find("Slider_BGM/Text").GetComponent<Text>().text
                = "BGM";
            MainMenuWindowCanvasObj.transform.Find("Slider_SE/Text").GetComponent<Text>().text
                = "SE";
            MainMenuWindowCanvasObj.transform.Find("CameraSensitivityText").GetComponent<TextMeshProUGUI>().text
                = "CameraSensitivity";
            MainMenuWindowCanvasObj.transform.Find("Slider_MouseRate/Text").GetComponent<Text>().text
                = "Mouse";
            MainMenuWindowCanvasObj.transform.Find("Slider_StickRate/Text").GetComponent<Text>().text
                = "Stick";
            MainMenuWindowCanvasObj.transform.Find("Button_CameraReset/Text").GetComponent<Text>().text
                = "CameraReset";
            MainMenuWindowCanvasObj.transform.Find("Button_Save&Exit/Text").GetComponent<Text>().text
                = "Save & Exit";

            //Graphic
            GraphicWindowCanvasObj.transform.Find("Toggle_TPSMode/Text").GetComponent<Text>().text
                = "TPS Mode";
            GraphicWindowCanvasObj.transform.Find("Button_GraphicDefault/Text").GetComponent<Text>().text
                = "GraphicDefault";

            //フローチャート説明
            FlowChartWindowCanvasObj.transform.Find("SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Hover over a scene to view\nits title and click on it to\nstart playing from that scene.";

            //操作説明
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/Kettei/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Confirm";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/Tokusyu/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Special actions (scroll / back)";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/SentakuLogVis/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "View backlog";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/MenuPoseMouseOut/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Menu / detach mouse from game window";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/CameraControl/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Rotate camera (only left/right when playing in VR)";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/CameraReset/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "Reset camera";

            //操作説明ボタン
            SousaWindowCanvasObj.transform.Find("Button_MoveSetumei/Text").GetComponent<Text>().text
                = "Movement";
            SousaWindowCanvasObj.transform.Find("Button_ClimbSetumei/Text").GetComponent<Text>().text
                = "Climbing";

            //着替え
            ClothsWindowCanvasObj.transform.Find("Toggle_Barefoot/Text").GetComponent<Text>().text
                = "Barefoot";
            ClothsWindowCanvasObj.transform.Find("Toggle_Tanktop/Text").GetComponent<Text>().text
                = "Tanktop";
            ClothsWindowCanvasObj.transform.Find("Toggle_FixityOutfit/Text").GetComponent<Text>().text
                = "Preserve settings";

            //確認ウインドウ
            FlowChartMoveWindowCanvasObj.transform.Find("ConfirmImgaeText/Text").GetComponent<TextMeshProUGUI>().text
                = "Start playing from this scene?";
            FlowChartMoveWindowCanvasObj.transform.Find("GameExitText").GetComponent<TextMeshProUGUI>().text
                = "Quit the game?\nWhen you restart,\nthe game will start from\nthe intro to this scene.";

            //初期起動の決定ボタン
            InitialSettingWindowCanvasObj.transform.Find("Button_InitialSettingOK/Text").GetComponent<Text>().text
                = "Confirm";

        }
        else
        {
            //Main
            MainMenuWindowCanvasObj.transform.Find("Slider_Master/Text").GetComponent<Text>().text
                = "音量";
            MainMenuWindowCanvasObj.transform.Find("Slider_BGM/Text").GetComponent<Text>().text
                = "BGM";
            MainMenuWindowCanvasObj.transform.Find("Slider_SE/Text").GetComponent<Text>().text
                = "SE";
            MainMenuWindowCanvasObj.transform.Find("CameraSensitivityText").GetComponent<TextMeshProUGUI>().text
                = "カメラ操作感度";
            MainMenuWindowCanvasObj.transform.Find("Slider_MouseRate/Text").GetComponent<Text>().text
                = "マウス";
            MainMenuWindowCanvasObj.transform.Find("Slider_StickRate/Text").GetComponent<Text>().text
                = "スティック";
            MainMenuWindowCanvasObj.transform.Find("Button_CameraReset/Text").GetComponent<Text>().text
                = "カメラリセット";
            MainMenuWindowCanvasObj.transform.Find("Button_Save&Exit/Text").GetComponent<Text>().text
                = "セーブ＆終了";

            //Graphic
            GraphicWindowCanvasObj.transform.Find("Toggle_TPSMode/Text").GetComponent<Text>().text
                = "TPS モード";
            GraphicWindowCanvasObj.transform.Find("Button_GraphicDefault/Text").GetComponent<Text>().text
                = "デフォルト設定";

            //フローチャート説明
            FlowChartWindowCanvasObj.transform.Find("SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "シーンを選択すると詳細が\n表示されます。\n決定することでシーンへ\nジャンプできます。";

            //操作説明
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/Kettei/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "決定";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/Tokusyu/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "特殊(切り替え・バック)";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/SentakuLogVis/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "選択・ログ表示";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/MenuPoseMouseOut/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "メニュー・マウス占有外す";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/CameraControl/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "カメラ回転(VR時は左右のみ)";
            SousaWindowCanvasObj.transform.Find("ScrollRect/Content/CameraReset/Texts/SetumeiText").GetComponent<TextMeshProUGUI>().text
                = "カメラリセット";

            //操作説明ボタン
            SousaWindowCanvasObj.transform.Find("Button_MoveSetumei/Text").GetComponent<Text>().text
                = "移動操作";
            SousaWindowCanvasObj.transform.Find("Button_ClimbSetumei/Text").GetComponent<Text>().text
                = "登り操作";

            //着替え
            ClothsWindowCanvasObj.transform.Find("Toggle_Barefoot/Text").GetComponent<Text>().text
                = "素足";
            ClothsWindowCanvasObj.transform.Find("Toggle_Tanktop/Text").GetComponent<Text>().text
                = "タンクトップ";
            ClothsWindowCanvasObj.transform.Find("Toggle_FixityOutfit/Text").GetComponent<Text>().text
                = "設定を維持";

            //確認ウインドウ
            FlowChartMoveWindowCanvasObj.transform.Find("ConfirmImgaeText/Text").GetComponent<TextMeshProUGUI>().text
                = "上記シーン冒頭へ移動します。";
            FlowChartMoveWindowCanvasObj.transform.Find("GameExitText").GetComponent<TextMeshProUGUI>().text
                = "ゲームを終了します。\n再開時は現在のシーン冒頭から\n開始します。";

            //初期起動の決定ボタン
            InitialSettingWindowCanvasObj.transform.Find("Button_InitialSettingOK/Text").GetComponent<Text>().text
                = "決定";
        }

    }

    //着替え処理
    void ClothsApply()
    {
        //素足 タンクトップ ビキニのDBboolを参照するが
        //・ビキニとタンクトップON　はありえない
        //・ビキニと素足オフ　はありえない

        //ので、ビキニを最初に判定する
        if (DB.isUserClothsBikini)
        {
            #region ビキニに切り替え処理
            //制服OFF
            GirlMeshTrs.Find("NeckTai").gameObject.SetActive(false);
            GirlMeshTrs.Find("Pants").gameObject.SetActive(false);
            GirlMeshTrs.Find("Sailor").gameObject.SetActive(false);
            GirlMeshTrs.Find("Skirt").gameObject.SetActive(false);

            //タンクトップOFF
            GirlMeshTrs.Find("Spats").gameObject.SetActive(false);
            GirlMeshTrs.Find("TankTop").gameObject.SetActive(false);

            //靴下OFF
            SocksObj.SetActive(false);

            
            //ビキニON
            GirlMeshTrs.Find("Bikini").gameObject.SetActive(true);
            
            //マテリアル
            BodyObj.GetComponent<Renderer>().material = mat_body_Bikini;
            #endregion
        }

        //以降4つは　素足とタンクトップで判定
        else if (
            DB.isUserClothsBarefoot &&
            DB.isUserClothsTankTop == false
            )
        {
            #region 制服に切り替え処理
            //制服ON
            GirlMeshTrs.Find("NeckTai").gameObject.SetActive(true);
            GirlMeshTrs.Find("Pants").gameObject.SetActive(true);
            GirlMeshTrs.Find("Sailor").gameObject.SetActive(true);
            GirlMeshTrs.Find("Skirt").gameObject.SetActive(true);

            //タンクトップOFF
            GirlMeshTrs.Find("Spats").gameObject.SetActive(false);
            GirlMeshTrs.Find("TankTop").gameObject.SetActive(false);

            //ビキニOFF
            GirlMeshTrs.Find("Bikini").gameObject.SetActive(false);

            #endregion
            #region 素足に切り替え処理
            BodyObj.GetComponent<Renderer>().material = mat_body_Barefoot;
            SocksObj.SetActive(false);
            #endregion
        }
        else if (
            DB.isUserClothsBarefoot == false &&
            DB.isUserClothsTankTop == false
            )
        {
            #region 制服に切り替え処理
            //制服ON
            GirlMeshTrs.Find("NeckTai").gameObject.SetActive(true);
            GirlMeshTrs.Find("Pants").gameObject.SetActive(true);
            GirlMeshTrs.Find("Sailor").gameObject.SetActive(true);
            GirlMeshTrs.Find("Skirt").gameObject.SetActive(true);

            //タンクトップOFF
            GirlMeshTrs.Find("Spats").gameObject.SetActive(false);
            GirlMeshTrs.Find("TankTop").gameObject.SetActive(false);

            //ビキニOFF
            GirlMeshTrs.Find("Bikini").gameObject.SetActive(false);

            #endregion
            #region 靴下に切り替え処理
            BodyObj.GetComponent<Renderer>().material = mat_body;
            SocksObj.SetActive(true);
            #endregion
        }
        else if (
            DB.isUserClothsBarefoot &&
            DB.isUserClothsTankTop
            )
        {
            #region タンクトップに切り替え処理
            //制服OFF
            GirlMeshTrs.Find("NeckTai").gameObject.SetActive(false);
            GirlMeshTrs.Find("Pants").gameObject.SetActive(false);
            GirlMeshTrs.Find("Sailor").gameObject.SetActive(false);
            GirlMeshTrs.Find("Skirt").gameObject.SetActive(false);

            //タンクトップON
            GirlMeshTrs.Find("Spats").gameObject.SetActive(true);
            GirlMeshTrs.Find("TankTop").gameObject.SetActive(true);

            //ビキニOFF
            GirlMeshTrs.Find("Bikini").gameObject.SetActive(false);

            #endregion
            #region 素足に切り替え処理
            BodyObj.GetComponent<Renderer>().material = mat_body_TankTop_Barefoot;
            SocksObj.SetActive(false);
            #endregion
        }
        else if (
            DB.isUserClothsBarefoot == false &&
            DB.isUserClothsTankTop
            )
        {
            #region タンクトップに切り替え処理
            //制服OFF
            GirlMeshTrs.Find("NeckTai").gameObject.SetActive(false);
            GirlMeshTrs.Find("Pants").gameObject.SetActive(false);
            GirlMeshTrs.Find("Sailor").gameObject.SetActive(false);
            GirlMeshTrs.Find("Skirt").gameObject.SetActive(false);

            //タンクトップON
            GirlMeshTrs.Find("Spats").gameObject.SetActive(true);
            GirlMeshTrs.Find("TankTop").gameObject.SetActive(true);

            //ビキニOFF
            GirlMeshTrs.Find("Bikini").gameObject.SetActive(false);

            #endregion
            #region 靴下に切り替え処理
            BodyObj.GetComponent<Renderer>().material = mat_body_TankTop;
            SocksObj.SetActive(true);
            #endregion
        }
    }

    //トグルONOFF時の処理メソッド化
    void TogglleChange(GameObject ToggleObj, bool On)
    {
        if (On)
        {
            ToggleObj.GetComponent<Image>().color = Toggle_OnProtObj.GetComponent<Image>().color;
            ToggleObj.transform.Find("ToggleCheckmark").gameObject.SetActive(true);
        }
        else
        {
            ToggleObj.GetComponent<Image>().color = Toggle_OffProtObj.GetComponent<Image>().color;
            ToggleObj.transform.Find("ToggleCheckmark").gameObject.SetActive(false);
        }
    }
    #endregion
    #region ■情報表示システム（身長リアルタイム表示など）
    #region 変数
    bool
        isInfoVisSystem = false;
    bool
        isInfoMakotoHeightVis = false,
        isInfoFPSVis = false;//未実装
    #endregion

    IEnumerator InfoVisSystemIEnum()
    {
        if (isInfoVisSystem) { yield break; }
        isInfoVisSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化

        bool
            isOnceInfoMakotoHeightVis = false;

        GameObject MakotoHeightTextObj
            = Instantiate(Resources.Load("EventSystem/InfoVisSystem/Prefab/MakotoHeightTextObj") as GameObject
            , MessageCanvasTrs
            , false);
        Text MakotoHeightText = MakotoHeightTextObj.GetComponent<Text>();
        MakotoHeightTextObj.SetActive(false);

        #endregion

        #region ■■■ループ
        while (isInfoVisSystem)
        {
            #region マコト身長表示
            if (isInfoMakotoHeightVis)
            {
                if (isOnceInfoMakotoHeightVis == false)//Once
                {
                    isOnceInfoMakotoHeightVis = true;
                    MakotoHeightTextObj.SetActive(isInfoMakotoHeightVis);
                }

                //更新し続け
                if (isInfoMakotoHeightVis)
                {
                    MakotoHeightText.text = nowPlayerSintyouFloat.ToString("f1") + " cm";
                }
            }
            else//false
            {
                if (isOnceInfoMakotoHeightVis)//Once
                {
                    isOnceInfoMakotoHeightVis = false;
                    MakotoHeightTextObj.SetActive(isInfoMakotoHeightVis);
                }
            }
            #endregion
            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }


    #endregion


    #region ■アニメトリガーシステム（足音揺れなど）

    #region 変数
    bool
        isAnimEventSystem = false;
    bool //ひとつでもイベント再生しているか検知用
        AT_isAnimTriggerEventPlaying = false;

    bool //各イベントでカメラなど動き発生してるか検知用
        AT_isCameraAnchorPlaying = false;
    Vector3 //揺れる前アンカー取得用
        AT_defCameraAnchorLclPos;

    public GameObject //数値変化読み取り用ボーンObj
        AnimTriggerBoneObj;

    //任意で単発再生用
    bool
        isAnimTriggerRForcePlay = false,
        isAnimTriggerLForcePlay = false;

    //現在再生しているアニメトリガーイベントのOrderdDict（重複再生や、オールクリア用に）
    OrderedDictionary<int, Coroutine>
        AT_intCorDict = new OrderedDictionary<int, Coroutine>();

    bool //設置足どちらかのフラグ
        isAnimTriggerRFoot = false,
        isAnimTriggerLFoot = false;

    //足跡オブジェ用
    GameObject
        chieriFootStepObjFolder;
    ChieriFootStepSpawn //智恵理rootにコンポーネントある
        chieriFootStepSpawn;

    //Decal判定Area
    GameObject
        ChieriFootstepDecalAreaCollObj;
    ChieriFootstepDecalAreaColl
        chieriFootstepDecalAreaColl;
    #endregion

    //■本体
    IEnumerator AnimEventSystemIEnum()
    {
        if (isAnimEventSystem) { yield break; }
        isAnimEventSystem = true;

        #region 初期化

        bool //イベント発生を1フレのみにする用
            isTriggerOn = false;

        int //イベントのDictに入れるときのキー
            tmpEventKeyInt = 0;

        #region 智恵理の足跡オブジェ関係

        //たくさん生み出すのでフォルダにまとめる（既にあれば取得）
        if (GameObject.Find("chieriFootStepObjFolder")) { chieriFootStepObjFolder = GameObject.Find("chieriFootStepObjFolder"); }
        else //生成
        {
            chieriFootStepObjFolder = new GameObject();
            chieriFootStepObjFolder.transform.SetParent(GameObjectsTrs);
            chieriFootStepObjFolder.name = nameof(chieriFootStepObjFolder);
            chieriFootStepObjFolder.transform.localScale = Vector3.one;
            chieriFootStepObjFolder.transform.localPosition = Vector3.zero;
        }

        //智恵理の足跡オブジェ取得（コンポーネントにしてある）
        if (GirlTrs.GetComponent<ChieriFootStepSpawn>())
        { chieriFootStepSpawn = GirlTrs.gameObject.GetComponent<ChieriFootStepSpawn>(); }
        else //なければ付与(後でデフォルトのObj設定)
        {
            chieriFootStepSpawn = GirlTrs.gameObject.AddComponent<ChieriFootStepSpawn>();
        }
        #endregion

        #region DecalAreaObj生成と取得
        ChieriFootstepDecalAreaCollObj
            = Instantiate(Resources.Load("EventSystem/ChieriFootStep/ChieriFootstepDecalAreaCollObj") as GameObject
            , GameObjectsTrs
            , false);
        ChieriFootstepDecalAreaCollObj.name = nameof(ChieriFootstepDecalAreaCollObj);

        chieriFootstepDecalAreaColl
            = ChieriFootstepDecalAreaCollObj.GetComponent<ChieriFootstepDecalAreaColl>();
        #endregion

        #endregion

        #region ループ
        while (isAnimEventSystem)
        {
            #region 足設置トリガー

            #region 次の設置足が右か左かの判定 （現在、脛角度を監視）
            if (
                GirlRCalfTrs.localEulerAngles.z > 20
                && GirlRCalfTrs.localEulerAngles.z < 100 //360に
                )
            {
                isAnimTriggerRFoot = true;
                isAnimTriggerLFoot = false;
            }
            else if (
                GirlLCalfTrs.localEulerAngles.z > 20
                && GirlLCalfTrs.localEulerAngles.z < 100 //360に
                )
            {
                isAnimTriggerRFoot = false;
                isAnimTriggerLFoot = true;
            }

            #endregion

            #region 両足左右判定 190818 xが0.01以上で右足、-0.01以下で左足の判定
            //右足
            if (isTriggerOn == false &&
                AnimTriggerBoneObj.transform.localPosition.x <= -0.01f)
            {
                isTriggerOn = true;

                isAnimTriggerRFoot = true;
                isAnimTriggerLFoot = false;

                //揺れイベント追加
                AT_intCorDict.Add
                    (tmpEventKeyInt++,//キー値を+して
                    StartCoroutine(FootStepCameraShakeIEnum(tmpEventKeyInt)));//そのキーを引数にイベント開始
            }
            //左足
            else if (isTriggerOn == false &&
                AnimTriggerBoneObj.transform.localPosition.x >= 0.01f)
            {
                isTriggerOn = true;

                isAnimTriggerRFoot = false;
                isAnimTriggerLFoot = true;

                //揺れイベント追加
                AT_intCorDict.Add
                    (tmpEventKeyInt++,//キー値を+して
                    StartCoroutine(FootStepCameraShakeIEnum(tmpEventKeyInt)));//そのキーを引数にイベント開始
            }
            #endregion

            #region トリガー用のダミーボーンが Y 0.01以上動いたら発生（既存の指定も動くように残し。↑と共存）
            else if (isTriggerOn == false &&
                (AnimTriggerBoneObj.transform.localPosition.y >= 0.01f || -0.01f >= AnimTriggerBoneObj.transform.localPosition.y)
                || isAnimTriggerRForcePlay || isAnimTriggerLForcePlay)//任意単発再生用
            {
                isTriggerOn = true;

                #region 任意単発再生用
                //どちらの足かを設定して
                if (isAnimTriggerRForcePlay) { isAnimTriggerRFoot = true; isAnimTriggerLFoot = false; }
                else if (isAnimTriggerLForcePlay) { isAnimTriggerRFoot = false; isAnimTriggerLFoot = true; }
                //オフ
                isAnimTriggerRForcePlay = isAnimTriggerLForcePlay = false;

                #endregion

                //揺れイベント追加
                AT_intCorDict.Add
                    (tmpEventKeyInt++,//キー値を+して
                    StartCoroutine(FootStepCameraShakeIEnum(tmpEventKeyInt)));//そのキーを引数にイベント開始
            }
            #endregion

            //トリガー用のダミーボーンが戻ったらboolオフ
            else if (isTriggerOn == true)
            {
                //xが戻っている上で、yも戻っていればオフ
                if (AnimTriggerBoneObj.transform.localPosition.x < 0.01f && -0.01f < AnimTriggerBoneObj.transform.localPosition.x)
                {
                    if (AnimTriggerBoneObj.transform.localPosition.y < 0.01f && -0.01f < AnimTriggerBoneObj.transform.localPosition.y)
                    {
                        isTriggerOn = false;
                    }
                }
            }

            #endregion

            #region 全てのイベントが終了したらDictなどクリア
            if
                (AT_isAnimTriggerEventPlaying
                && AT_isCameraAnchorPlaying == false)
            {
                //Debug.Log("全イベント終了");
                AT_isAnimTriggerEventPlaying = false;

                //Dict終了してキーも0
                AT_intCorDict.Clear();
                tmpEventKeyInt = 0;
            }
            #endregion

            yield return null;
        }
        #endregion

        #region 終了処理

        //足設置揺れTweener
        AT_footStepCameraShakeTweener.Pause();//キャンセルはポーズで（OnkillはComplete時にも走る）
        AT_footStepCameraShakeTweener.Kill();
        AT_footStepCameraShakeTweener = null;

        //カメラ位置など変更中だった場合、直す
        if (AT_isCameraAnchorPlaying)
        {
            //アンカーカメラ位置
            CameraAnchorTrs.localPosition = AT_defCameraAnchorLclPos;
            AT_isCameraAnchorPlaying = false;
        }

        Debug.Log("全アニメトリガーイベント強制終了");
        AT_isAnimTriggerEventPlaying = false;
        //Dict終了してキーも0
        AT_intCorDict.Clear();
        tmpEventKeyInt = 0;


        #endregion
        yield break;
    }

    //足音ランダム再生メソッド
    String FootStepSE(List<string> SEStrList = null)
    {
        string
            playSEStr = "UI_po";

        //リスト未指定の場合
        if (SEStrList == null)
        { playSEStr = footStepSEStr_flooring2List[UnityEngine.Random.Range(0, footStepSEStr_flooring2List.Count)]; }
        else
        { playSEStr = SEStrList[UnityEngine.Random.Range(0, SEStrList.Count)]; }

        //playSEStr = footStepSEStr_flooring2List[UnityEngine.Random.Range(0, footStepSEStr_flooring2List.Count)];
        //playSEStr = footStepSEStr_flooring1List[UnityEngine.Random.Range(0, footStepSEStr_flooring1List.Count)];
        //playSEStr = footStepSEStr_carpet1List[UnityEngine.Random.Range(0, footStepSEStr_carpet1List.Count)];
        //playSEStr = footStepSEStr_BetaAsiList[UnityEngine.Random.Range(0, footStepSEStr_BetaAsiList.Count)];

        ////足音のデバッグコンソール表示
        //Debug.Log(playSEStr);
        return playSEStr;
    }

    //起こるイベント群 //足音も足跡（chieriFootStepSpawn・Decal）もこの中
    #region カメラ揺らしと足音と足跡（距離とサイズで計算）
    Tweener //揺れのTweener
        AT_footStepCameraShakeTweener;

    //足音も足跡（chieriFootStepSpawn・Decal）もこの中
    IEnumerator FootStepCameraShakeIEnum(int dictKey, float delay = 0)
    {
        //イベントでカメラアンカー動いていない場合のみ、デフォ値取得
        if (AT_isCameraAnchorPlaying == false)
        {
            //揺れる前のアンカー取得
            AT_defCameraAnchorLclPos = CameraAnchorTrs.localPosition;

            //カメラアンカー動かしてる検知用Bool
            AT_isCameraAnchorPlaying = true;
            //全イベントの再生検知用Bool
            AT_isAnimTriggerEventPlaying = true;
        }

        bool //Tweenerの終了が、完了かキャンセルかで 終了処理変更用
            isOnCompBreak = false,
            isOnPauseBreak = false;

        #region ■カメラ揺らしと足音と足跡（距離とサイズで計算）

        #region 降ろした足判定と位置取得（判定取れなければ智恵理の真下）
        //ひとまず智恵理の真下Pos取得して
        Vector3 tmpOnFootPos = new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z);

        //右足か左足か設定 （どちらもとれなければ智恵理真下になる）
        if (isAnimTriggerRFoot)
        {
            tmpOnFootPos = new Vector3(GirlRFootTrs.position.x, 0, GirlRFootTrs.position.z);
            Debug.Log("RightFoot設置判定");
        }
        else if (isAnimTriggerLFoot)
        {
            tmpOnFootPos = new Vector3(GirlLFootTrs.position.x, 0, GirlLFootTrs.position.z);
            Debug.Log("LFoot設置判定");
        }
        else { Debug.Log("足設置判定取れず。Bip001中心下に"); }

        #endregion

        #region ■智恵理とプレイヤーの距離 サイズなどから、揺れや音などの強さを計算
        //Jukesさんから色々教わり、その注釈をコメントに交えてある。

        //智恵理とプレイヤーの距離（智恵理視点から見たメートル数とす）
        float girlToPlayerDistance =
        Vector3.Distance(
            GameObjectsTrs.InverseTransformPoint(tmpOnFootPos)
            , GameObjectsTrs.InverseTransformPoint(CameraObjectsTrs.position));

        #region 揺れの大きさ 距離と大きさから計算 //Scale0.015を最小と仮定した上での計算式

        //後の計算で 距離1.5 かつ スケール0.015 で0.05
        //距離0.37程 で0.8 になる数字    //※"この式のまま"スケール0.03の場合は 距離0.37程 で0.4になる
        float baseYurePow = 0.1125f * 0.015f;


        ////■距離0.37以降は0.37で固定する（最大値）
        //float limitDistance = Mathf.Max(girlToPlayerDistance, 0.37f);
        float limitDistance = Mathf.Max(girlToPlayerDistance, 0.37f);


        //■計算により、一定以上の小ささかつ近づきでしか揺れないので、これいらない
        ////プレイヤー 一定以上小さくなければ揺れゼロ
        //if (nowPlayerLocalScale.z > DB.playerScale_JougiDeHakariZero.z)
        //{ baseYurePow = 0; }


        //結果代入
        //Pow（累乗）を2にしてあるけども、3にすればもっとカーブがきつくなる（3以上は入れない）
        float yurePow = baseYurePow / Mathf.Pow(limitDistance, 3f)
            / nowPlayerLocalScale.z;//大きさが考慮される

        //演出調整用
        yurePow *= footYurePowMul;

        if (footYurePowMul == 0.05f)//演出調整してるときは何もしない
        {
            //距離1.5より離れる（数値が0.05以下）の場合、0に
            if (yurePow < 0.05f)
            { yurePow = 0; }
        }


        #endregion

        #region //揺れの遅延　（高音が後から遅れて聴こえるのは現実的でもいらないかも。なので適用せず式だけ残してある）

        //音速は
        //空気 1秒 340メートル
        //地面 1秒 4000～7000メートル
        float soundVelocity = 340 * nowPlayerLocalScale.z;
        float yureVelocity = 4000 * nowPlayerLocalScale.z;
        //智恵理主観での伝わる早さ。　プレイヤー主観で見ると（0.015倍の時）66倍

        //プレイヤー0.015を1とした場合、智恵理は66倍の大きさ
        //プレイヤー0.03を1とした場合、智恵理は33倍の大きさ

        //いらない
        //float baseSoundDelay = 0.05f;
        //float baseYureDelay = 0.07f;

        //結果代入
        float yureDelayTime = girlToPlayerDistance / yureVelocity;
        float soundDelayTime = girlToPlayerDistance / soundVelocity;
        #endregion

        #endregion

        #region ■足音
        //※高音は離れるほど聴こえなくなる率高し　ので、高音と低音で音を分ける

        //そして、揺れの大きさそのものが音量と考えてよし
        //ので、式が揺れとほぼ同じ

        //■高音 （反比例をきつくした）
        float highSoundVolume = baseYurePow / Mathf.Pow(limitDistance, 3)
            / nowPlayerLocalScale.z;//大きさが考慮される


        //■低音はbaseYurePowだと距離感足りないのでベースの数字を上げ
        float lowSoundPow = 0.1125f * 0.015f * 7;

        //反比例カーブ具合は2で 揺れと同じ
        float lowSoundVolume = lowSoundPow / Mathf.Pow(limitDistance, 0.5f)
            / nowPlayerLocalScale.z;//大きさが考慮される

        //音量が小さいと感じたら、適当に掛け算で調整
        highSoundVolume *= footHighVolMul;
        lowSoundVolume *= footLowVolMul;

        //Debug.Log(girlToPlayerDistance);


        #region 0.3倍（定規で縮められて以降）
        if (nowPlayerLocalScale == DB.playerScale_JougiDeHakariZero)
        {
            SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 2);
            SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), Other3DSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume, 0.5f);

            SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume);
        }
        #endregion
        #region 0.15倍（ペットボトル入れられてから朝など）
        else if (nowPlayerLocalScale == DB.playerScale_PetbottleIreZero)
        {
            #region 小さな家シーンの場合
            //イベント名で指定
            if (evs[DB.nowEventNum].Key == "小さな家")
            {
                //Debug.Log("小さな家専用音量");
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List)
                    , highSoundVolume / 4);
                SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), Other3DSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList)
                    , highSoundVolume / 4, 0.5f);

                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List)
                    , lowSoundVolume / 7);
            }
            #endregion
            else
            {
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 1);
                SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), Other3DSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume, 0.5f);

                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume / 3);
            }


        }
        #endregion

        #region 0.1倍（都市前半）
        else if (nowPlayerLocalScale.x <= DB.playerScale_City01.x && nowPlayerLocalScale.x >= 0.0091f)//0.0099～とかになることがあるので追加条件
        {
            Debug.Log("0.1倍都市前半");
            #region それぞれ場合わけ
            //イベント名で指定
            if (evs[DB.nowEventNum].Key == "")
            {
                //■低音はbaseYurePowだと距離感足りないのでベースの数字を上げ
                lowSoundPow = 0.1125f * 0.015f * 5;

                //反比例カーブ具合は2で 揺れと同じ
                lowSoundVolume = lowSoundPow / Mathf.Pow(limitDistance, 0.1f)//距離による変化少なめで0.1
                    / nowPlayerLocalScale.z;//大きさが考慮される

                //音量が小さいと感じたら、適当に掛け算で調整
                highSoundVolume *= footHighVolMul;
                lowSoundVolume *= footLowVolMul / 2;

                Debug.Log("足音低音" + lowSoundVolume);

                //SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 3);
                //SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), AsiotoSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume / 3, 0.5f);
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume);
            }

            #endregion
            else
            {
                #region ■転送都市用にyurePowを再計算
                //Pow（累乗）を2にしてあるけども、3にすればもっとカーブがきつくなる（3以上は入れない）
                yurePow = baseYurePow / Mathf.Pow(limitDistance, 2.3f)
                    / nowPlayerLocalScale.z;//大きさが考慮される

                //演出調整用
                yurePow *= 0.5f;

                #endregion

                //■低音はbaseYurePowだと距離感足りないのでベースの数字を上げ
                lowSoundPow = 0.1125f * 0.015f * 5; //全体的に5ぐらいにして

                //反比例カーブ具合は2で 揺れと同じ
                lowSoundVolume = lowSoundPow / Mathf.Pow(limitDistance, 0.1f)//距離による変化少なめで0.1
                    / nowPlayerLocalScale.z;//大きさが考慮される

                //音量が小さいと感じたら、適当に掛け算で調整
                highSoundVolume *= footHighVolMul;
                lowSoundVolume *= footLowVolMul;


                //SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 3);
                //SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), AsiotoSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume / 3, 0.5f);
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume);
            }
        }
        #endregion
        #region 0.1倍未満　※ためしに0.1倍未満は同じ
        else if (nowPlayerLocalScale.x < 0.009)
        {
            Debug.Log("0.1倍未満");
            #region それぞれ場合わけ（シーン名など）
            //イベント名で指定
            if (evs[DB.nowEventNum].Key == "")
            {
                //■低音はbaseYurePowだと距離感足りないのでベースの数字を上げ
                lowSoundPow = 0.1125f * 0.015f * 5;

                //反比例カーブ具合は2で 揺れと同じ
                lowSoundVolume = lowSoundPow / Mathf.Pow(limitDistance, 0.1f)//距離による変化少なめで0.1
                    / nowPlayerLocalScale.z;//大きさが考慮される //100分の1の設定


                //音量が小さいと感じたら、適当に掛け算で調整
                highSoundVolume *= footHighVolMul;
                lowSoundVolume *= footLowVolMul / 2;

                Debug.Log("足音低音" + lowSoundVolume);

                //SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 3);
                //SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), AsiotoSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume / 3, 0.5f);
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume);
            }

            #endregion
            else //場合分けなし（この大きさでのデフォ）
            {
                #region ■転送都市用にyurePowを再計算
                //Pow（累乗）を2にしてあるけども、3にすればもっとカーブがきつくなる（3以上は入れない）
                yurePow = baseYurePow / Mathf.Pow(limitDistance, 2.3f)
                    /// nowPlayerLocalScale.z;//大きさが考慮される //100分の1の設定
                    / 0.01f;//100分の1想定

                //演出調整用
                yurePow *= 1.5f;

                #endregion

                //■低音はbaseYurePowだと距離感足りないのでベースの数字を上げ
                lowSoundPow = 0.1125f * 0.015f * 5; //全体的に5ぐらいにして

                //反比例カーブ具合は2で 揺れと同じ
                lowSoundVolume = lowSoundPow / Mathf.Pow(limitDistance, 0.1f)//距離による変化少なめで0.1
                    / nowPlayerLocalScale.z;//大きさが考慮される

                //音量が小さいと感じたら、適当に掛け算で調整
                highSoundVolume *= footHighVolMul;
                lowSoundVolume *= footLowVolMul;


                //SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiPicthMinus10List), highSoundVolume / 3);
                //SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), AsiotoSEObj, FootStepSE(woodFloorCreakingShortPicthMinus6SEStrList), highSoundVolume / 3, 0.5f);
                SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_Low1List), lowSoundVolume);
            }
        }
        #endregion
        #region それ以外
        else
        {
            SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(footStepSEStr_BetaAsiList), highSoundVolume);
            SEPlay(new Vector3(Bip001Trs.position.x, 0, Bip001Trs.position.z), AsiotoSEObj, FootStepSE(woodFloorCreakingShortSEStrList), highSoundVolume * 10);

            SEPlay(tmpOnFootPos, AsiotoSEObj, "testFootStep01", lowSoundVolume);
        }
        #endregion

        ////低音 距離で音分け
        //if (girlToPlayerDistance > 2)
        //{ SEPlay(tmpOnFootPos, AsiotoSEObj, "testFootStep01", lowSoundVolume); }
        //else if (2 >= girlToPlayerDistance && girlToPlayerDistance > 1.5f)
        //{ SEPlay(tmpOnFootPos, AsiotoSEObj, "testFootStep02", lowSoundVolume); }
        //else if (1.5f >= girlToPlayerDistance && girlToPlayerDistance > 0.7f)
        //{ SEPlay(tmpOnFootPos, AsiotoSEObj, "testFootStep03", lowSoundVolume); }
        //else if (0.7f >= girlToPlayerDistance)
        //{ SEPlay(tmpOnFootPos, AsiotoSEObj, "testFootStep04", lowSoundVolume); }


        //プレイヤー 一定以上小さくなければ音普通の
        if (nowPlayerLocalScale.z > DB.playerScale_JougiDeHakariZero.z)
        {
            //SEPlay(AsiotoSEObj, FootStepSE(), GirlTrs.gameObject, 3);
            SEPlay(tmpOnFootPos, AsiotoSEObj, FootStepSE(), 3);
        }
        //else //大きければズーン（暫定）
        //{ SEPlay(AsiotoSEObj, "testFootStep01", GirlTrs.gameObject, 2); }


        #endregion

        if (chieriFootStepSpawn.isFootStepObj)
        {
            #region 足跡 chieriFootStepSpawn

            if (isAnimTriggerLFoot)
            {
                for (int i = 0; i < chieriFootStepSpawn.lFootSpawnObjs.Length; i++)
                {
                    GameObject tmpLfootStepObj = Instantiate(chieriFootStepSpawn.lFootSpawnObjs[i].Obj
                        , GirlLFootTrs
                        , false);
                    tmpLfootStepObj.name = nameof(tmpLfootStepObj) + i + chieriFootStepSpawn.lFootSpawnObjs[i].Obj.name;

                    ////オフセット位置に
                    //tmpLfootStepObj.transform.localPosition += chieriFootStepSpawn.lFootSpawnObjs[i].offsetLocalPos;

                    //回転をYのみにするならする（智恵理足設置状態を0にするならzが90）
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].isRotYOnly)
                    { tmpLfootStepObj.transform.eulerAngles = new Vector3(0, tmpLfootStepObj.transform.eulerAngles.y, 0); }

                    //Yをワールド0位置にするならする
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].isPosYWorldZero)
                    { tmpLfootStepObj.transform.position = new Vector3(tmpLfootStepObj.transform.position.x, 0, tmpLfootStepObj.transform.position.z); }

                    //フォルダに設置(LateUpdateで)
                    LateAction(() =>
                    { tmpLfootStepObj.transform.SetParent(chieriFootStepObjFolder.transform, true); });

                    DB.evMoveDelObjList.Add(tmpLfootStepObj);
                    //時間が0より大きいならオート消しコンポーネント付与
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].autoDelTime > 0)
                    { tmpLfootStepObj.AddComponent<autoObjDestroy>().autoDelTime = chieriFootStepSpawn.lFootSpawnObjs[i].autoDelTime; }
                }
            }
            else if (isAnimTriggerRFoot)
            {
                for (int i = 0; i < chieriFootStepSpawn.rFootSpawnObjs.Length; i++)
                {
                    GameObject tmpRfootStepObj = Instantiate(chieriFootStepSpawn.rFootSpawnObjs[i].Obj
                        , GirlRFootTrs
                        , false);
                    tmpRfootStepObj.name = nameof(tmpRfootStepObj) + i + chieriFootStepSpawn.rFootSpawnObjs[i].Obj.name;

                    ////オフセット位置に
                    //tmpRfootStepObj.transform.localPosition += chieriFootStepSpawn.rFootSpawnObjs[i].offsetLocalPos;

                    //回転をYのみにするならする（智恵理足設置状態を0にするならzが90）
                    if (chieriFootStepSpawn.rFootSpawnObjs[i].isRotYOnly)
                    { tmpRfootStepObj.transform.eulerAngles = new Vector3(0, tmpRfootStepObj.transform.eulerAngles.y, 0); }

                    //Yをワールド0位置にするならする
                    if (chieriFootStepSpawn.rFootSpawnObjs[i].isPosYWorldZero)
                    { tmpRfootStepObj.transform.position = new Vector3(tmpRfootStepObj.transform.position.x, 0, tmpRfootStepObj.transform.position.z); }

                    //フォルダに設置(LateUpdateで)
                    LateAction(() =>
                    { tmpRfootStepObj.transform.SetParent(chieriFootStepObjFolder.transform, true); });

                    DB.evMoveDelObjList.Add(tmpRfootStepObj);
                    //時間が0より大きいならオート消しコンポーネント付与
                    if (chieriFootStepSpawn.rFootSpawnObjs[i].autoDelTime > 0)
                    { tmpRfootStepObj.AddComponent<autoObjDestroy>().autoDelTime = chieriFootStepSpawn.rFootSpawnObjs[i].autoDelTime; }
                }
            }
            else//足判定取れないなら、ひとまず左足用Obj
            {
                for (int i = 0; i < chieriFootStepSpawn.lFootSpawnObjs.Length; i++)
                {
                    GameObject tmpLfootStepObj = Instantiate(chieriFootStepSpawn.lFootSpawnObjs[i].Obj
                        , GirlLFootTrs
                        , false);
                    tmpLfootStepObj.name = nameof(tmpLfootStepObj) + i + chieriFootStepSpawn.lFootSpawnObjs[i].Obj.name;

                    ////オフセット位置に
                    //tmpLfootStepObj.transform.localPosition += chieriFootStepSpawn.lFootSpawnObjs[i].offsetLocalPos;

                    //回転をYのみにするならする（智恵理足設置状態を0にするならzが90）
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].isRotYOnly)
                    { tmpLfootStepObj.transform.eulerAngles = new Vector3(0, tmpLfootStepObj.transform.eulerAngles.y, 0); }

                    //Yをワールド0位置にするならする
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].isPosYWorldZero)
                    { tmpLfootStepObj.transform.position = new Vector3(tmpLfootStepObj.transform.position.x, 0, tmpLfootStepObj.transform.position.z); }

                    //フォルダに設置(LateUpdateで)
                    LateAction(() =>
                    { tmpLfootStepObj.transform.SetParent(chieriFootStepObjFolder.transform, true); });

                    DB.evMoveDelObjList.Add(tmpLfootStepObj);
                    //時間が0より大きいならオート消しコンポーネント付与
                    if (chieriFootStepSpawn.lFootSpawnObjs[i].autoDelTime > 0)
                    { tmpLfootStepObj.AddComponent<autoObjDestroy>().autoDelTime = chieriFootStepSpawn.lFootSpawnObjs[i].autoDelTime; }
                }
            }


            //GameObject asiatoObj = Instantiate(Resources.Load("_FractureTest02/ChieriFootStepPrefab/Rubble") as GameObject, GameObjectsTrs, false);
            //asiatoObj.transform.localScale = asiatoObj.transform.localScale / GameObjectsTrs.localScale.z;
            //asiatoObj.transform.position = tmpOnFootPos;
            //asiatoObj.name = nameof(asiatoObj);
            //DB.evDelObjList.Add(asiatoObj);

            //GameObject hokoriObj = Instantiate(Resources.Load("_FractureTest02/ChieriFootStepPrefab/new_WhiteSmoke_BillCrash01") as GameObject, GameObjectsTrs, false);
            //hokoriObj.transform.localScale = hokoriObj.transform.localScale / GameObjectsTrs.localScale.z;
            //hokoriObj.transform.position = tmpOnFootPos;
            //hokoriObj.name = nameof(hokoriObj);
            //DB.evDelObjList.Add(hokoriObj);

            #endregion
        }
        if (chieriFootStepSpawn.isFootStepDecal)
        {
            #region 足跡 Decal

            #region 左右判定で、まずArea内か判定
            if (isAnimTriggerLFoot)
            {
                //Area外なら作成自体から抜け
                if (chieriFootstepDecalAreaColl.isLFootStay == false)
                { goto Decal作成抜け; }
            }
            else if (isAnimTriggerRFoot)
            {
                //Area外なら作成自体から抜け
                if (chieriFootstepDecalAreaColl.isRFootStay == false)
                { goto Decal作成抜け; }
            }
            else// 足判定取れないなら、ひとまず左足
            {
                //Area外なら作成自体から抜け
                if (chieriFootstepDecalAreaColl.isLFootStay == false)
                { goto Decal作成抜け; }
            }
            #endregion

            //デカールObj生成
            GameObject ChieriFootstepDecalObjs
                = Instantiate(Resources.Load("EventSystem/ChieriFootStep/ChieriFootstepDecalObjs") as GameObject);
            ChieriFootstepDecalObjs.name = nameof(ChieriFootstepDecalObjs);
            DB.sceneMoveDelObjList.Add(ChieriFootstepDecalObjs);

            #region 左右判定でオブジェクト削除とリネーム カメラ位置変更
            if (isAnimTriggerLFoot)
            {
                #region オブジェクト削除とリネーム
                Destroy(ChieriFootstepDecalObjs.transform.Find("FootPrint_R").gameObject);
                GameObject tmpObj = ChieriFootstepDecalObjs.transform.Find("FootPrint_L").gameObject;
                tmpObj.name = "FootPrint";
                tmpObj.transform.Find("FootPrint_L").name = "FootPrint";
                tmpObj.transform.Find("FootPrintSide_L").name = "FootPrintSide";
                #endregion
            }
            else if (isAnimTriggerRFoot)
            {
                #region オブジェクト削除とリネーム
                Destroy(ChieriFootstepDecalObjs.transform.Find("FootPrint_L").gameObject);
                GameObject tmpObj = ChieriFootstepDecalObjs.transform.Find("FootPrint_R").gameObject;
                tmpObj.name = "FootPrint";
                tmpObj.transform.Find("FootPrint_R").name = "FootPrint";
                tmpObj.transform.Find("FootPrintSide_R").name = "FootPrintSide";
                #endregion
                #region カメラ位置変更
                //カメラ位置をRFoot用撮影位置に（中にPosObj）
                ChieriFootstepDecalObjs.transform.Find("ZimenSatueiCamera").localPosition
                = ChieriFootstepDecalObjs.transform.Find("ZimenSatueiCamera_RFootPos").localPosition;
                #endregion
            }
            else// 足判定取れないなら、ひとまず左足
            {
                #region オブジェクト削除とリネーム
                Destroy(ChieriFootstepDecalObjs.transform.Find("FootPrint_R").gameObject);
                GameObject tmpObj = ChieriFootstepDecalObjs.transform.Find("FootPrint_L").gameObject;
                tmpObj.name = "FootPrint";
                tmpObj.transform.Find("FootPrint_L").name = "FootPrint";
                tmpObj.transform.Find("FootPrintSide_L").name = "FootPrintSide";
                #endregion
            }
            #endregion


            //足にペアレント
            if (isAnimTriggerLFoot)
            { ChieriFootstepDecalObjs.transform.SetParent(GirlLFootTrs, false); Debug.Log("L\nL=" + isAnimTriggerLFoot + "R=" + isAnimTriggerRFoot); }
            else if (isAnimTriggerRFoot)
            { ChieriFootstepDecalObjs.transform.SetParent(GirlRFootTrs, false); Debug.Log("R\nL=" + isAnimTriggerLFoot + "R=" + isAnimTriggerRFoot); }
            else// 足判定取れないなら、ひとまず左足
            { ChieriFootstepDecalObjs.transform.SetParent(GirlLFootTrs, false); }

            //フォルダに設置
            //■↓とLateにしたが、処理が激しいと位置がずれるので、やっぱりLate外し。何か変になったらLateにしてみる。
            ////Lateじゃなくても動くけど、後々IKでやるとダメかもなので埃と同じようにLate
            //LateAction(() =>
            //{

            ChieriFootstepDecalObjs.transform.SetParent(chieriFootStepObjFolder.transform, true);

            //Y位置0
            ChieriFootstepDecalObjs.transform.localPosition
                        = new Vector3(ChieriFootstepDecalObjs.transform.localPosition.x, 0, ChieriFootstepDecalObjs.transform.localPosition.z);
            //Y軸回転のみに
            ChieriFootstepDecalObjs.transform.localEulerAngles
                = new Vector3(0, ChieriFootstepDecalObjs.transform.localEulerAngles.y, 90);//Z90度

            //■■カメラにつけてるスクリプトのコルーチンで撮影設置削除
            StartCoroutine(ChieriFootstepDecalObjs.transform.Find("ZimenSatueiCamera")
                .GetComponent<SaveRenderTextureToPng>().DecalSetDel());
            //});

            Decal作成抜け:;

            #endregion
        }



        //Tweenerがnullではない（現在再生中）場合、Tweener一旦削除
        if (AT_footStepCameraShakeTweener != null)
        {
            AT_footStepCameraShakeTweener.Pause();//キャンセルはポーズで（OnkillはComplete時にも走る）
            AT_footStepCameraShakeTweener.Kill();
            AT_footStepCameraShakeTweener = null;
        }

        ////揺れるまで（+低音）の待ち時間
        //yield return new WaitForSeconds(yureDelayTime);

        #region //低音足音
        ////プレイヤー 一定以上小さくなければ音普通の
        //if (nowPlayerLocalScale.z > DB.playerScale_JougiDeHakariZero.z)
        //{ SEPlay(AsiotoSEObj, FootStepSE(), GirlTrs.gameObject, 3); }
        //else //大きければズーン（暫定）
        //{ SEPlay(AsiotoSEObj, "testFootStep01", GirlTrs.gameObject, 2); }

        #endregion

        #region 揺らしTweener

        float yureTime = 0.5f;

        //まず持ち上げ
        AT_footStepCameraShakeTweener
            = CameraAnchorTrs.DOLocalMove
            (AT_defCameraAnchorLclPos + new Vector3(0, yurePow, 0)
            , 0.05f)
            .SetEase(Ease.OutSine)
            .OnPause(() => { isOnPauseBreak = true; })//キャンセルされた時
            .OnComplete(() =>
            {
                //元の高さに着地 //ここでもTweener代入している
                AT_footStepCameraShakeTweener =
                CameraAnchorTrs.DOLocalMove
                (AT_defCameraAnchorLclPos
                , yureTime)
                .SetEase(Ease.OutBounce)
                .OnPause(() => { isOnPauseBreak = true; })//キャンセルされた時
                .OnComplete(() =>
                {
                    //キャンセルされず完遂
                    isOnCompBreak = true;
                });
            });
        #endregion

        ////高音待ち時間
        //yield return new WaitForSeconds(soundDelayTime - yureDelayTime);

        #region //高音足音
        ////プレイヤー 一定以上小さくなければ音普通の
        //if (nowPlayerLocalScale.z > DB.playerScale_JougiDeHakariZero.z)
        //{ SEPlay(AsiotoSEObj, FootStepSE(), GirlTrs.gameObject, 3); }
        //else //大きければズーン（暫定）
        //{ SEPlay(AsiotoSEObj, "testFootStep01", GirlTrs.gameObject, 2); }
        #endregion



        //Tweener終了まで待機
        while (isOnCompBreak == false
            && isOnPauseBreak == false)
        {
            yield return null;
        }

        #region ■終了処理
        //完遂して終了の場合
        if (isOnCompBreak)
        {
            //自らTweener等も削除
            AT_footStepCameraShakeTweener.Kill();
            AT_footStepCameraShakeTweener = null;
            //カメラアンカー動かしてるBoolオフ
            AT_isCameraAnchorPlaying = false;
        }
        //キャンセルで終了した場合、Tweener削除は追加されたコルーチンに任せる
        else
        {
        }

        #endregion

        #endregion


        yield break;
    }
    float //↑演出調整用
        footHighVolMul = 3,
        footLowVolMul = 1.5f,
        footYurePowMul = 0.05f;

    #endregion




    #endregion
    #region ■サブイベントプレイリストシステム（IEnum追加された順に実行）
    #region 説明
    //ListにIEnumを追加して、頭から順に再生される
    //List操作で途中で入れ替えたり中断が可能
    //・0番目を入れ替えると、今のサブイベント強制中断削除して、入れ替えたのが再生される
    //・リストを空にすると、今のサブイベントが終了するまで待機して追加待ち待機に戻る（空にしてから0番目に追加しても強制中断されない）
    //・システムbool終了させると、今のサブイベント強制中断削除して終了する。

    #endregion

    #region 変数
    bool
        isSubEventPlaylistSystem = false;

    List<IEnumerator> //これに入れたIEnumが順次再生されていく
        subEventIEnumList = new List<IEnumerator>();

    bool //サブイベントの最後でこれをfalseにして終了検知
        isRunSubEventPlayListSystemEvent = false;
    #endregion

    IEnumerator SubEventPlaylistSystemIEnum()
    {
        if (isSubEventPlaylistSystem) { yield break; }
        isSubEventPlaylistSystem = true;

        #region ■■■初期化
        //監視用変数群
        int //実行しているイベントのHash（中断したときに削除や、リストの頭がこのイベントか監視する用）
            tmpNowIEnumHash = 0;
        Coroutine //イベントを中断できるように
            tmpNowCor = null;

        #endregion

        #region ■■■ループ
        while (isSubEventPlaylistSystem)
        {
            //サブイベント追加されるまで待機
            if (subEventIEnumList.Count != 0)
            {
                イベント開始して監視開始://■Addされた or 先頭入れ替わったので、Hashを保持し実行して終わるまで監視待機

                isRunSubEventPlayListSystemEvent = true;
                tmpNowIEnumHash = subEventIEnumList[0].GetHashCode();

                //中断できるようにStartCoroutineで（yield returnだと中断を検知できない）
                tmpNowCor = StartCoroutine(subEventIEnumList[0]);

                //実行中のコルーチン監視しながら待機
                while (isRunSubEventPlayListSystemEvent && isSubEventPlaylistSystem)
                {
                   　//リストは空にされてないか
                    if (subEventIEnumList.Count == 0)
                    {
                        //空にされたら"今のイベント終了まで待機して"、待機へ
                        while (isRunSubEventPlayListSystemEvent) { yield return null; }
                        goto 待機ループ;
                    }
                    //0番目が別ものと入れ替わってないか
                    else if (tmpNowIEnumHash != subEventIEnumList[0].GetHashCode())
                    {
                        #region 入れ替わったら中断し、そっちを実行して再び監視へ
                        StopCoroutine(tmpNowCor);
                        //中断したものを削除しておく（再開したいものがあったら、ここに処理挟む）
                        for (int i = 0; i < subEventIEnumList.Count; i++)
                        {
                            if (tmpNowIEnumHash == subEventIEnumList[i].GetHashCode())
                            { subEventIEnumList.RemoveAt(i); }
                        }
                        #endregion
                        goto イベント開始して監視開始;
                    }
                    yield return null;
                }

                //■終了したので、今のイベントを削除し、待機ループへ
                subEventIEnumList.RemoveAt(0);
            }
            待機ループ:

            yield return null;
        }
        #endregion

        #region ■■■終了処理
        終了処理:
        //コルーチン終了処理
        if (tmpNowCor != null) { StopCoroutine(tmpNowCor); }

        //イベントリストクリア
        subEventIEnumList.Clear();

        isRunSubEventPlayListSystemEvent = false;
        #endregion
        yield break;
    }


    #endregion

    #region ■時計システム
    #region 変数
    bool
        isClockSystem = false;

    Transform
        clockTrs,
        clockShortAdjustTrs,
        clockShortTrs,
        clockLongAdjustTrs,
        clockLongTrs,
        clockSecondHandAdjustTrs,
        clockSecondHandTrs;

    public float
        clockVolume = 0.3f;

    //一発目鳴らないように
    bool isStartClockSE = false;

    #endregion

    IEnumerator ClockSystemIEnum()
    {
        if (isClockSystem) { yield break; }
        isClockSystem = true;
        List<GameObject> exitDestroyObjList = new List<GameObject>();

        #region ■■■初期化
        NullJudgeFind(ref clockTrs, "Clock");
        clockShortAdjustTrs = clockTrs.Find("ShortAdjust");
        clockShortTrs = clockShortAdjustTrs.Find("Short");
        clockLongAdjustTrs = clockTrs.Find("LongAdjust");
        clockLongTrs = clockLongAdjustTrs.Find("Long");
        clockSecondHandAdjustTrs = clockTrs.Find("SecondHandAdjust");
        clockSecondHandTrs = clockSecondHandAdjustTrs.Find("SecondHand");

        ////秒針音取得
        //var tmpSEList = new List<string>();
        //tmpSEList.Add("SecondHand01");
        //tmpSEList.Add("SecondHand02");
        //tmpSEList.Add("SecondHand03");
        //tmpSEList.Add("SecondHand04");
        //tmpSEList.Add("SecondHand05");
        //tmpSEList.Add("SecondHand06");
        //tmpSEList.Add("SecondHand07");
        //tmpSEList.Add("SecondHand08");
        //tmpSEList.Add("SecondHand09");
        //tmpSEList.Add("SecondHand10");

        int //実時刻の秒を比較用
            prevSecond = DateTime.Now.Second;

        #endregion

        #region ■■■ループ
        while (isClockSystem)
        {
            #region 秒針 手動ループ
            //音先 //一発目は鳴らないように
            if (isStartClockSE == false) { isStartClockSE = true; }
            else
            {
                clockSE.SEPlay();//ClockSEObjにスクリプトがあって、Clipは手動取得している
            }
            yield return new WaitForSeconds(0.1f);

            //6度ずつ進み
            clockSecondHandAdjustTrs.DOLocalRotate
                (clockSecondHandAdjustTrs.localEulerAngles + new Vector3(0, 0, -6)
                , 0.1f)
                .SetEase(Ease.OutBack);

            //角度に小数点以下があったら 四捨五入
            if (clockSecondHandAdjustTrs.localEulerAngles.z != Mathf.RoundToInt(clockSecondHandAdjustTrs.localEulerAngles.z))
            {
                clockSecondHandAdjustTrs.localEulerAngles =
                    new Vector3(0, 0, Mathf.RoundToInt(clockSecondHandAdjustTrs.localEulerAngles.z));
            }

            //待機
            yield return new WaitForSeconds(0.8f);

            //まんま1秒でやったら60秒で6秒早かったので、0.1秒足したら
            //今度は僅かに遅かったので0.095
            yield return new WaitForSeconds(0.095f);
            #endregion

            #region //秒針 内部実時刻取得ループ
            //if(prevSecond != DateTime.Now.Second)
            //{
            //    prevSecond = DateTime.Now.Second;

            //    //音
            //SEPlay(ClockSEObj,
            //    tmpSEList[UnityEngine.Random.Range(0, tmpSEList.Count)]
            //    , clockSecondHandAdjustTrs.gameObject
            //    , 0.2f);
            //    //1秒 = 6度
            //    clockSecondHandAdjustTrs.DOLocalRotate
            //        (new Vector3(0, 0, (prevSecond * -6))
            //        , 0.1f)
            //        .SetEase(Ease.OutBack);

            //}
            #endregion

            yield return null;
        }
        #endregion

        #region ■■■終了処理
        for (int i = 0; i < exitDestroyObjList.Count; i++)
        { Destroy(exitDestroyObjList[i]); }
        exitDestroyObjList.Clear();
        #endregion
        yield break;
    }

    //今のコマデータから時間をセットするメソッド
    void SetClockHourMinute()
    {
        //取得
        int hour =
            flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().hour;
        int minute =
            flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().minute;

        //■分針（1分間で6度進む）
        clockLongAdjustTrs.localEulerAngles = new Vector3(0, 0, -(minute * 6));


        //■時針
        //まず時間の角度（1時間で30度進む）
        float tmpHour = hour * 30;
        //分の角度 (1分で0.5度進む)
        float tmpMinute = minute * 0.5f;
        //合算して適用
        clockShortAdjustTrs.localEulerAngles = new Vector3(0, 0, -(tmpHour + tmpMinute));
    }
    #endregion

    #region ■オブジェクトのパーツを接近させるシステム
    GameObject
        CloneIKTargetObj;

    IEnumerator //コルーチン一時停止・終了用
        SekkinSystemLoadIEnum;
    bool //全終了用Bool
        isSekkinSystem;

    void Sekkin(GameObject PivotObj, GameObject IKTargetObj, GameObject CloneIKTargetObjLclPosObj = null)
    {
        //重複キャンセル
        if (isSekkinSystem) { return; }
        isSekkinSystem = true;

        //※ 接近させる部位（指先など）にあらかじめPivotObjを設置しておく
        //CloneIKTargetObj = IKTargetObjをクローンし、PivotObjの子に設置し、ワールド位置をIKTargetObjに代入し続ける
        //PivotObjを動かすと、それに対応した位置にIKRHandTargetが動くという仕組み

        FixedAction(() =>
        {
            //pivotオブジェをGameobjectsに(好きな位置に動かすため)
            PivotObj.transform.SetParent(GameObjectsTrs, true);

            //追従するオブジェを生成、位置を同期する（その後、Pivotの子に入れてPivotの動きに更に同期させる）
            CloneIKTargetObj = new GameObject(nameof(CloneIKTargetObj));
            //クローンをpivotの子に
            CloneIKTargetObj.transform.SetParent(PivotObj.transform, true);

            //位置をIKTargetと同じに
            CloneIKTargetObj.transform.position = IKTargetObj.transform.position;
            CloneIKTargetObj.transform.rotation = IKTargetObj.transform.rotation;

            #region ズレ防止に、CloneIKTargetObj用のPosObjが指定されている場合
            //（※PosObjの取り方　ちゃんと動く状態の、PivotObjの子になっているCloneIKTargetObjのLocal位置を取る）
            if (CloneIKTargetObjLclPosObj != null)
            {
                //位置を直接指定の位置に
                CloneIKTargetObj.transform.localPosition = CloneIKTargetObjLclPosObj.transform.localPosition;
                CloneIKTargetObj.transform.localEulerAngles = CloneIKTargetObjLclPosObj.transform.localEulerAngles;
            }
            #endregion

            //同期するコルーチン始動
            StartCoroutine(SekkinSystemLoadIEnum = SekkinCor(IKTargetObj));
        });
    }

    IEnumerator SekkinCor(GameObject IKTargetObj)
    {
        yield return null;//0位置に飛んだりするので、1フレ待機

        while (isSekkinSystem)
        {
            //nullじゃなければ
            if (IKTargetObj != null && CloneIKTargetObj != null)
            {
                IKTargetObj.transform.position = CloneIKTargetObj.transform.position;
                IKTargetObj.transform.rotation = CloneIKTargetObj.transform.rotation;
            }
            else
            { isSekkinSystem = false; }
            yield return null;
        }

        //終了処理
        //PivotObj削除
        if (CloneIKTargetObj != null)
        {
            if (CloneIKTargetObj.transform.parent.gameObject != null)
            { Destroy(CloneIKTargetObj.transform.parent.gameObject); }
        }

        yield break;
    }

    #endregion



    #region 環境音変更メソッド

    void KankyouBGMVolumer(float vol = 1, float fadeTime = 1, AudioSource audioSource = null)
    {
        //指定があればそれのみ
        if (audioSource != null)
        {
            if (audioSource == aircon.audioSource)
            {
                //エアコン
                if (aircon.volTweener != null) { aircon.volTweener.Kill(); }
                aircon.volTweener
                    = DOTween.To(() => aircon.audioSource.volume, (x) => aircon.audioSource.volume = x
                , vol, fadeTime);
            }
            else if (audioSource == clockSE.audioSource)
            {
                //時計
                if (clockSE.volTweener != null) { clockSE.volTweener.Kill(); }
                clockSE.volTweener
                    = DOTween.To(() => clockSE.audioSource.volume, (x) => clockSE.audioSource.volume = x
                , vol, fadeTime);
            }
            //else if (audioSource = townSE.audioSource)
            //{
            //    //Town　街音
            //    if (townSE.volTweener != null) { townSE.volTweener.Kill(); }
            //    townSE.volTweener
            //        = DOTween.To(() => townSE.audioSource.volume, (x) => townSE.audioSource.volume = x
            //    , vol, fadeTime);
            //}
            else if (audioSource == semiSE.audioSource)
            {
                //Semi　セミ音
                if (semiSE.volTweener != null) { semiSE.volTweener.Kill(); }
                semiSE.volTweener
                    = DOTween.To(() => semiSE.audioSource.volume, (x) => semiSE.audioSource.volume = x
                , vol, fadeTime);
            }
        }
        //audioSource指定が無ければ全部同時に
        else
        {
            //エアコン
            if (aircon.volTweener != null) { aircon.volTweener.Kill(); }
            aircon.volTweener
                = DOTween.To(() => aircon.audioSource.volume, (x) => aircon.audioSource.volume = x
            , vol, fadeTime);

            //時計
            if (clockSE.volTweener != null) { clockSE.volTweener.Kill(); }
            clockSE.volTweener
                = DOTween.To(() => clockSE.audioSource.volume, (x) => clockSE.audioSource.volume = x
            , vol, fadeTime);

            ////Town　街音
            //if (townSE.volTweener != null) { townSE.volTweener.Kill(); }
            //townSE.volTweener
            //    = DOTween.To(() => townSE.audioSource.volume, (x) => townSE.audioSource.volume = x
            //, vol, fadeTime);

            //Semi　セミ音
            if (semiSE.volTweener != null) { semiSE.volTweener.Kill(); }
            semiSE.volTweener
                = DOTween.To(() => semiSE.audioSource.volume, (x) => semiSE.audioSource.volume = x
            , vol, fadeTime);
        }
    }

    void KankyouBGMChanger(AudioSource audioSource, string clipStr = null, AudioClip clip = null, float fadeTime = 0f)
    {
        float defVolume = audioSource.volume;

        //クリップ"名"指定なら
        if (clipStr != null)
        {
            //同じだったら何もしない。
            if (audioSource.clip == ResourceFiles.SE[clipStr]) { return; }

            audioSource.DOFade(0, fadeTime)
                .OnComplete(() =>
                {
                    audioSource.clip = ResourceFiles.SE[clipStr];
                    audioSource.DOFade(defVolume, fadeTime);
                });
        }
        //クリップ指定なら
        else if (clip != null)
        {
            //同じものだったら何もしない。
            if (audioSource.clip == clip) { return; }

            audioSource.DOFade(0, 1f)
                .OnComplete(() =>
                {
                    audioSource.clip = clip;
                    audioSource.DOFade(defVolume, fadeTime);
                });
        }

    }

    #endregion

    #region ■UnityTimeline拡張用メソッド

    #region 変数

    #region ■フラグ処理用初期設定"用の変数を生成"

    //コードに貼っていたが、移動ポイントでのフラグ書き込みをするために、クラス変数化。

    //トラックのフラグ代わり
    List<bool> codeFlagBoolList = new List<bool>();

    //クリップのフラグを取得する用Array
    bool[] clipFlagBoolArray = new bool[0];

    //結果判定用のBool
    bool isThisCodeFlagJudge = false;
    #endregion

    #endregion


    //UnityTimelineでのウェイト系処理
    bool isUTLKeyOrWait = false;
    public IEnumerator UTLKeyOrWait(PlayableDirector PD, float time)
    {
        PD.Pause();
        isUTLKeyOrWait = true;
        yield return new WaitForSeconds(time); yield return KeyOrWait(3);
        isUTLKeyOrWait = false;

        UTLAllWaitCheckdResume(PD);
        yield break;
    }

    bool isUTLNovelSetVisIngWait = false;
    public IEnumerator UTLNovelSetVisIngWait(PlayableDirector PD)
    {
        PD.Pause();
        isUTLNovelSetVisIngWait = true;

        while (isNovelSetVisIng) { yield return null; }
        isUTLNovelSetVisIngWait = false;

        UTLAllWaitCheckdResume(PD);
        yield break;
    }

    //選択肢は今は強制ウェイトで、フラグ書き込み兼ねている
    bool isUTLSentakushiWait = false;
    public IEnumerator UTLSentakushiWait(PlayableDirector PD, TrackAsset track, bool[] a, bool[] b)
    {
        PD.Pause();
        isUTLSentakushiWait = true;

        //選択肢選ばれるまでループ
        while (sentakuListNum == 99) { yield return null; }
        switch (sentakuListNum)
        {
            case 0://選択肢a

                (track as RMEventTrack).flagBoolList = a.ToList();

                break;

            case 1://選択肢b

                (track as RMEventTrack).flagBoolList = b.ToList();

                break;
        }
        sentakuListNum = 99;



        isUTLSentakushiWait = false;

        UTLAllWaitCheckdResume(PD);
        yield break;
    }

    public bool isUTLKO_SimplePointObjWait = false;
    public IEnumerator UTLKO_SimplePointObjWait(PlayableDirector PD)
    {
        PD.Pause();
        isUTLKO_SimplePointObjWait = true;
        while (isKO_SimplePointObj_Enter == false) { yield return null; }
        isKO_SimplePointObj_Enter = false;//移動ポイントEnterフラグ戻し

        isUTLKO_SimplePointObjWait = false;

        //自動で終了しないようにした
        //isKOSystem = false;
        ////直後に移動システム起動には2フレ必要なためあらかじめ2フレ待ち
        //yield return null;
        //yield return null;

        UTLAllWaitCheckdResume(PD);
        yield break;
    }

    bool isUTLMotionWait = false;
    public IEnumerator UTLMotionWait(PlayableDirector PD, string objName, string animClipName, float nomTime)
    {
        PD.Pause();
        isUTLMotionWait = true;

        yield return null;//再生と同時の場合に備えて1フレ待ち

        //obj名未指定ならちえりモーションのウェイト
        if (string.IsNullOrWhiteSpace(objName))
        {
            StartCoroutine(GirlAnimReadSystem());

            while (nowGirlAnimClipName != animClipName) { yield return null; }
            while (girlAnimNomTime <= nomTime) { yield return null; }
        }
        else //obj名指定ありなら、取得してウェイト
        {
            var tmpAnim =
                GameObject.Find(objName).GetComponent<Animator>();

            //■まずクリップ名ウェイト
            string tmpNowClipName = "dummy";
            //現在のアニメーションクリップ名取得
            if (tmpAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
            { tmpNowClipName = tmpAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }

            while (tmpNowClipName != animClipName)
            {
                //現在のアニメーションクリップ名取得
                if (tmpAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
                { tmpNowClipName = tmpAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }
                yield return null;
            }

            //■次にノーマライズタイムウェイト
            //ノーマライズタイム取得
            float tmpNowAnimNomTime = tmpAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;

            while (tmpNowAnimNomTime <= nomTime)
            {
                //ノーマライズタイム取得
                tmpNowAnimNomTime = tmpAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;
                yield return null;
            }

        }


        isUTLMotionWait = false;

        UTLAllWaitCheckdResume(PD);
        yield break;
    }


    //boolで全部のWait終わってるかチェックして、終わってたらリジューム
    void UTLAllWaitCheckdResume(PlayableDirector PD)
    {
        //Debug.Log(isUTLKeyOrWait.ToString() + isUTLNovelSetVisIngWait.ToString() + isUTLKO_SimplePointObjWait.ToString());

        //もし移動モード消えてて、到着待ちだったらオフ（シークやスキップへの対応）
        if (isKOSystem == false)
        {
            isUTLKO_SimplePointObjWait = false;
            isKO_SimplePointObj_Enter = false;//念のため移動ポイントEnterフラグも戻し
        }



        //結果全部Falseなら
        if (
        isUTLKeyOrWait == false
        && isUTLNovelSetVisIngWait == false
        && isUTLKO_SimplePointObjWait == false
        && isUTLSentakushiWait == false
        && isUTLMotionWait == false
        )
        {
            //消えてなければリジューム
            if (PD != null) { PD.Resume(); }
        }
    }

    //＝＝＝Wait系処理ここまで


    //移動ポイント到着でフラグ書き込み
    public IEnumerator UTLKO_SimplePointObjFlagWrite(TrackAsset track, bool[] writeFlagBools)
    {
        //Enterされるまで　もしくは終了するまで待機
        while (
            isKO_SimplePointObj_Enter == false
            && isKOSystem
            )
        { yield return null; }

        //到着しているのなら
        if (isKO_SimplePointObj_Enter)
        {
            //フラグ書き込み
            (track as RMEventTrack).flagBoolList = writeFlagBools.ToList();
        }



        yield break;
    }

    //Frac爆発設定(ちえりコリダー設定前提)
    public void UTLFracImpactSetting(bool isSet = true, GameObject impactPosObj = null, float impactForce = 0, float impactRadius = 0, bool bAlsoImpactFreeChunks = false)
    {
        for (int i = 0; i < ChieriColliderObjs.Length; i++)
        {
            //ちえりコリダーにHitEnergyついてれば処理
            if (ChieriColliderObjs[i].GetComponent<CustomFracturingColliderHitEnergy>() != null)
            {
                var tmpHitEnergy = ChieriColliderObjs[i].GetComponent<CustomFracturingColliderHitEnergy>();

                if (isSet)
                {
                    tmpHitEnergy.isUTLImpactSetting = true;
                    tmpHitEnergy.posObj = impactPosObj;
                    tmpHitEnergy.impactForce = impactForce;
                    tmpHitEnergy.impactRadius = impactRadius;
                    tmpHitEnergy.bAlsoImpactFreeChunks = bAlsoImpactFreeChunks;
                }
                else
                {
                    tmpHitEnergy.isUTLImpactSetting = false;//今まで通りに戻す
                }
            }
        }
    }

    //モーション命令（Obj設置と同時にモーション指定する場合は1フレ遅らせる処理）
    public IEnumerator UTLMotionIEnum(string motionObjName, string stateName, float crossFadeTime, int layer = 0, bool is1FrameWait = false)
    {
        //1フレ待ちなら待つ
        if (is1FrameWait) { yield return null; }

        //オブジェ名からAnimator取得して実行
        GameObject.Find(motionObjName).GetComponent<Animator>()
            .CrossFadeInFixedTime
            (stateName//stateName
            , crossFadeTime//transitionDuration
            , layer        //, 0//レイヤー
                           //, 0.0f//fixedTime
                           //, 0//normalizedTransitionTime
            );

        yield break;
    }

    //カメラ揺れ命令（重複時もとの位置に戻す処理を入れてある）
    bool isUTLDOShake = false;
    Tweener UTLDOShakeTweener;
    Vector3 UTLDOShakeDefLclPos;
    public IEnumerator UTLDOShakePosition(float duration, float strength, int vibrato, float randomness = 90, bool snapping = false, bool fadeOut = false)
    {
        //揺れ中だったら現在の揺れ止めてもとの位置にしてから再生
        if (isUTLDOShake)
        {
            if (UTLDOShakeTweener.IsPlaying()) { UTLDOShakeTweener.Kill(); }
            CameraAnchorTrs.localPosition = UTLDOShakeDefLclPos;
        }

        //■重複チェック用
        isUTLDOShake = true;

        //Def位置取得
        UTLDOShakeDefLclPos = CameraAnchorTrs.localPosition;

        //揺れ実行（Tweenerに入れながら）
        UTLDOShakeTweener =
            CameraAnchorTrs.DOShakePosition
            (duration
            , strength
            , vibrato
            , randomness //Randomness
            , snapping //Snaping
            , fadeOut)
            .OnComplete(() =>
            {
                //オフ
                isUTLDOShake = false;
            });
        yield break;
    }

    #endregion

    #region //■FREEMODE状態システム

    //#region 変数
    //bool
    //    isFreeModeSystem = false;

    //#endregion

    //IEnumerator FreeModeSystemIEnum()
    //{
    //    if (isFreeModeSystem) { yield break; }
    //    isFreeModeSystem = true;
    //    List<GameObject> exitDestroyObjList = new List<GameObject>();

    //    FadeBlack(1, 0);
    //    #region ■■■初期化

    //    //ひとまずデバッグオフ
    //    DB.isDebugMode =
    //    DB.isSkipMode = false;
    //    //顔埋まりオフ
    //    isVRBlockSystem = false;

    //    #region 現在の状態を読み取って終了させる

    //    #region ちえりのアニメなど
    //    //まずアクティブ
    //    var isGirlActive = GirlTrs.gameObject.activeSelf;

    //    //現在のモーションノーマライズタイム取得
    //    var girlAnimNomTime = girlAnim.GetCurrentAnimatorStateInfo(0).normalizedTime;

    //    //■現在のアニメーションクリップ名取得
    //    string girlAnimClipName;
    //    if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
    //    { girlAnimClipName = girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name; }

    //    girlAnim.speed = 0;


    //    #endregion

    //    #region プレイヤーの状態など(登りや移動)
    //    isANSystem = false;
    //    isKOSystem = false;

    //    //カメラデフォルト位置取得
    //    var defCameraObjectsPos = CameraObjectsTrs.position;

    //    #endregion

    //    //SE関係（風とか）

    //    //IK

    //    #endregion

    //    #region ノベルやフキダシ削除

    //    //ノベルウィンドウオフ
    //    isNovelFadeTween = isNovelSetVisIng = false;

    //    //フキダシ削除
    //    DelAll_Hukidashi();

    //    //ログ表示ロック
    //    isNovelLogLock = true;

    //    #endregion


    //    //イベント終了
    //    StopCoroutine(nowRunEvCoroutine);
    //    isEvRun = false;

    //    #endregion

    //    yield return null;
    //    yield return new WaitForSeconds(0.5f);
    //    FadeBlack(0, 2);

    //    #region ローカル変数
    //    //プレイヤー移動用
    //    Vector3 velocity;
    //    #endregion

    //    #region ■■■ループ
    //    while (isFreeModeSystem)
    //    {
    //        if (Input.GetKeyDown(KeyCode.Y) && isMenuSystem == false)
    //        {
    //            //メニュー強制開き
    //            StartCoroutine(MenuSystemIEnum(true, false, true));
    //        }

    //        #region プレイヤー移動

    //        // WASD入力から、XZ平面(水平な地面)を移動する方向(velocity)を得ます
    //        velocity = Vector3.zero;
    //        if (Input.GetKey(KeyCode.W))
    //            velocity.z += 1;
    //        if (Input.GetKey(KeyCode.A))
    //            velocity.x -= 1;
    //        if (Input.GetKey(KeyCode.S))
    //            velocity.z -= 1;
    //        if (Input.GetKey(KeyCode.D))
    //            velocity.x += 1;

    //        #region moveSpeed調整

    //        float moveSpeed = 100f * nowPlayerLocalScale.z;// 移動速度

    //        if (Input.GetKey(KeyCode.LeftShift))
    //        { moveSpeed *= 10; }
    //        else if (Input.GetKey(KeyCode.LeftControl))
    //        { moveSpeed /= 10; }
    //        #endregion

    //        // 速度ベクトルの長さを1秒でmoveSpeedだけ進むように調整します
    //        velocity = velocity.normalized * moveSpeed * Time.deltaTime;

    //        // いずれかの方向に移動している場合
    //        if (velocity.magnitude > 0)
    //        {
    //            //※カメラの水平回転のみをQuaternionで取得 （XとZは0にし、CameraObjectsTrsのEulのY　と　userCameraControlEulのYを足している↓）
    //            var camRotOnlyY = Quaternion.Euler(0, CameraObjectsTrs.localEulerAngles.y + userCameraControlEul.y, 0);
    //            //移動方向(velocity)を足し込みます
    //            CameraObjectsTrs.position += camRotOnlyY * velocity;
    //        }

    //        #endregion

    //        //プレイヤーカメラ位置リセット
    //        if (isCameraResetDown || Input.GetKeyDown(KeyCode.C)) //ひとまずキーボードではC
    //        { CameraObjectsTrs.position = defCameraObjectsPos; }

    //        yield return null;
    //    }
    //    #endregion

    //    #region ■■■終了処理
    //    for (int i = 0; i < exitDestroyObjList.Count; i++)
    //    { Destroy(exitDestroyObjList[i]); }
    //    exitDestroyObjList.Clear();
    //    #endregion
    //    yield break;
    //}


    #endregion


    //ヒエラルキーのGameObjectをエディタ上で事前ロード（"_MJ/リソースファイル事前ロード"で実行）
    public void HierarchyObjLoad()
    {
        //事前ロードのために一旦取得するが、最後に開放（null） （シーン移動時に保持してるとそれを読もうとしてしまうため）
        DB = NullJudgeFind("DataBridging").GetComponent<DataBridging>();

        //Resources.Load()で読み込んだデータは、そのデータを使用していたオブジェクトが削除されても、再利用する時のためにキャッシュに残る仕組みになっているようです。
        //このメソッドは、現在キャッシュに残っていて使用していないアセットを破棄してくれます。
        Resources.UnloadUnusedAssets();

        //フキダシセリフのObj読み込み　ひとまずリソースロード直接（セーブロードイベントでもやってる）
        DB.hukidashiCanvasObj = Resources.Load("EventSystem/Hukidashi/Prefab/HukidashiCanvas") as GameObject;
        DB.novelSystem = Resources.Load("EventSystem/Novel/NovelSystem") as GameObject;

        #region データベース（関数名のリストなど）

        //探索用メソッド名リスト作成（IENumeratorもメソッド扱いだった）
        DB.TansakuMethodNameList.Clear();
        MemberInfo[] tmpDCMemberInfos = typeof(DataCounter).GetMembers
            (BindingFlags.Public
            | BindingFlags.NonPublic
            | BindingFlags.Instance
            | BindingFlags.Static
            | BindingFlags.DeclaredOnly
            );
        foreach (var m in tmpDCMemberInfos)
        {
            if (m.Name.IndexOf("T_") == 0)
            {
                DB.TansakuMethodNameList.Add(m.Name);
            }
        }


        #endregion

        #region ヒエラルキーのObj 小物・UI 探索オブジェクト
        ResourceFiles = NullJudgeFind("Server").transform.Find("ResourceFiles").gameObject.GetComponent<ResourceFiles>();
        EventObjectsTrs = NullJudgeFind("EventObjects").transform;

        NullJudgeFind(ref GameObjectsTrs, "GameObjects");
        NullJudgeFind(ref ServerTrs, "Server");

        NullJudgeFind(ref TargetsTrs, "Targets");
        NullJudgeFind(ref GirlIKTargetsTrs, "GirlIKTargets");
        NullJudgeFind(ref PlayerIKTargetsTrs, "PlayerIKTargets");


        //■Room系
        NullJudgeFind(ref RoomTrs, "Room");
        NullJudgeFind(ref SotoTrs, "Soto");
        NullJudgeFind(ref Particle_DustTrs, "Particle_Dust");
        NullJudgeFind(ref ChairTrs, "Chair");
        NullJudgeFind(ref DoorRootTrs, "DoorRoot");
        NullJudgeFind(ref DoorTrs, "Door");
        NullJudgeFind(ref BedTrs, "Bed");
        NullJudgeFind(ref SchoolBagTrs, "SchoolBag");
        NullJudgeFind(ref CarpetTrs, "Carpet");
        NullJudgeFind(ref BunguTrs, "Bungu");
        NullJudgeFind(ref Eiffel_hiTrs, "Eiffel_hiObj");
        NullJudgeFind(ref JougiTrs, "Jougi");
        NullJudgeFind(ref GrasstableTrs, "Grasstable");
        NullJudgeFind(ref GomibakoTrs, "Gomibako");
        NullJudgeFind(ref YukaTrs, "Yuka");
        NullJudgeFind(ref Drill_chieriTrs, "Drill_chieri");
        NullJudgeFind(ref DrillTrs, "Drill");
        NullJudgeFind(ref PageTrs, "Page");
        NullJudgeFind(ref CalenderTrs, "Calender");
        NullJudgeFind(ref TabletTrs, "TabletObj");
        NullJudgeFind(ref PonyTrs, "BattlePony");
        NullJudgeFind(ref SpeakerTrs, "Speaker");

        #region ■探索オブジェタグで取得
        TansakuObjList.Clear();//まずクリア

        //コリダーObj群Tagでまとめて取得
        TansakuSeeObjColliderObjs = GameObject.FindGameObjectsWithTag("TansakuObj");

        foreach (GameObject primObj in TansakuSeeObjColliderObjs)
        {
            //TansakuObjList内に該当のObjがなければ入れる(コリダーの親の親オブジェ)
            if (TansakuObjList.Contains(primObj.transform.parent.parent.gameObject) == false)
            { TansakuObjList.Add(primObj.transform.parent.parent.gameObject); }
        }
        #endregion

        doorAnim = DoorRootTrs.GetComponent<Animator>();
        chairAnim = ChairTrs.GetComponent<Animator>();

        //■UI
        //ポインター
        NullJudgeFind(ref SeePointTrs, "SeePoint");
        SeePointHitSlider = SeePointTrs.GetChild(0).GetComponent<Slider>();

        //SE・BGMはシーン間でも鳴らすためにStartで取得
        #region 足音SEリストなど

        footStepSEStr_flooring1List.Clear();
        footStepSEStr_flooring1List.Add("walk-flooring1-01");
        footStepSEStr_flooring1List.Add("walk-flooring1-02");
        footStepSEStr_flooring1List.Add("walk-flooring1-03");
        footStepSEStr_flooring1List.Add("walk-flooring1-04");
        footStepSEStr_flooring1List.Add("walk-flooring1-05");
        footStepSEStr_flooring1List.Add("walk-flooring1-06");
        footStepSEStr_flooring1List.Add("walk-flooring1-07");
        footStepSEStr_flooring1List.Add("walk-flooring1-08");
        footStepSEStr_flooring1List.Add("walk-flooring1-09");
        footStepSEStr_flooring1List.Add("walk-flooring1-10");
        footStepSEStr_flooring1List.Add("walk-flooring1-12");
        footStepSEStr_flooring1List.Add("walk-flooring1-13");
        footStepSEStr_flooring1List.Add("walk-flooring1-14");
        footStepSEStr_flooring1List.Add("walk-flooring1-15");
        footStepSEStr_flooring1List.Add("walk-flooring1-16");
        footStepSEStr_flooring1List.Add("walk-flooring1-17");
        footStepSEStr_flooring1List.Add("walk-flooring1-18");
        footStepSEStr_flooring1List.Add("walk-flooring1-19");
        footStepSEStr_flooring1List.Add("walk-flooring1-20");
        footStepSEStr_flooring1List.Add("walk-flooring1-21");

        footStepSEStr_flooring2List.Clear();
        footStepSEStr_flooring2List.Add("walk-flooring2_01");
        footStepSEStr_flooring2List.Add("walk-flooring2_02");
        footStepSEStr_flooring2List.Add("walk-flooring2_03");
        footStepSEStr_flooring2List.Add("walk-flooring2_04");
        footStepSEStr_flooring2List.Add("walk-flooring2_05");
        footStepSEStr_flooring2List.Add("walk-flooring2_06");
        footStepSEStr_flooring2List.Add("walk-flooring2_07");
        footStepSEStr_flooring2List.Add("walk-flooring2_08");
        footStepSEStr_flooring2List.Add("walk-flooring2_09");
        footStepSEStr_flooring2List.Add("walk-flooring2_10");
        footStepSEStr_flooring2List.Add("walk-flooring2_11");

        footStepSEStr_carpet1List.Clear();
        footStepSEStr_carpet1List.Add("walk-carpet1-01");
        footStepSEStr_carpet1List.Add("walk-carpet1-02");
        footStepSEStr_carpet1List.Add("walk-carpet1-03");
        footStepSEStr_carpet1List.Add("walk-carpet1-04");
        footStepSEStr_carpet1List.Add("walk-carpet1-05");
        footStepSEStr_carpet1List.Add("walk-carpet1-06");
        footStepSEStr_carpet1List.Add("walk-carpet1-07");
        footStepSEStr_carpet1List.Add("walk-carpet1-08");
        footStepSEStr_carpet1List.Add("walk-carpet1-09");
        footStepSEStr_carpet1List.Add("walk-carpet1-10");
        footStepSEStr_carpet1List.Add("walk-carpet1-11");
        footStepSEStr_carpet1List.Add("walk-carpet1-12");
        footStepSEStr_carpet1List.Add("walk-carpet1-13");
        footStepSEStr_carpet1List.Add("walk-carpet1-14");
        footStepSEStr_carpet1List.Add("walk-carpet1-15");
        footStepSEStr_carpet1List.Add("walk-carpet1-16");
        footStepSEStr_carpet1List.Add("walk-carpet1-17");
        footStepSEStr_carpet1List.Add("walk-carpet1-18");
        footStepSEStr_carpet1List.Add("walk-carpet1-19");
        footStepSEStr_carpet1List.Add("walk-carpet1-20");
        footStepSEStr_carpet1List.Add("walk-carpet1-21");
        footStepSEStr_carpet1List.Add("walk-carpet1-22");
        footStepSEStr_carpet1List.Add("walk-carpet1-23");
        footStepSEStr_carpet1List.Add("walk-carpet1-24");
        footStepSEStr_carpet1List.Add("walk-carpet1-25");
        footStepSEStr_carpet1List.Add("walk-carpet1-26");
        footStepSEStr_carpet1List.Add("walk-carpet1-27");

        footStepSEStr_BetaAsiList.Clear();
        footStepSEStr_BetaAsiList.Add("足音・べた足-01");
        footStepSEStr_BetaAsiList.Add("足音・べた足-02");
        footStepSEStr_BetaAsiList.Add("足音・べた足-03");
        footStepSEStr_BetaAsiList.Add("足音・べた足-04");
        footStepSEStr_BetaAsiList.Add("足音・べた足-05");
        footStepSEStr_BetaAsiList.Add("足音・べた足-06");
        footStepSEStr_BetaAsiList.Add("足音・べた足-07");
        footStepSEStr_BetaAsiList.Add("足音・べた足-08");
        footStepSEStr_BetaAsiList.Add("足音・べた足-09");
        footStepSEStr_BetaAsiList.Add("足音・べた足-10");
        footStepSEStr_BetaAsiList.Add("足音・べた足-11");
        footStepSEStr_BetaAsiList.Add("足音・べた足-12");

        footStepSEStr_BetaAsiPicthMinus10List.Clear();
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-01-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-02-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-03-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-04-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-05-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-06-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-07-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-08-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-09-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-10-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-11-ピッチ-10");
        footStepSEStr_BetaAsiPicthMinus10List.Add("足音・べた足-12-ピッチ-10");

        footStepSEStr_Low1List.Clear();
        footStepSEStr_Low1List.Add("低音足音0.3イメージ-00");
        footStepSEStr_Low1List.Add("低音足音0.3イメージ-01");
        footStepSEStr_Low1List.Add("低音足音0.3イメージ-02");
        footStepSEStr_Low1List.Add("低音足音0.3イメージ-03");
        footStepSEStr_Low1List.Add("低音足音0.3イメージ-04");

        woodFloorCreakingSEStrList.Clear();
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_00_01");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_00_02");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_00_03");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_00_04");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_00_05");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_00");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_01");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_02");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_03");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_04");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_05");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_06");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_07");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_08");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_09");
        woodFloorCreakingSEStrList.Add("WOOD FLOOR CREAKING_01_10");

        woodFloorCreakingPicthMinus6SEStrList.Clear();
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_01_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_02_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_03_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_04_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_05_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_00_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_01_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_02_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_03_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_04_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_05_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_06_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_07_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_08_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_09_ピッチ-6");
        woodFloorCreakingPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_10_ピッチ-6");

        woodFloorCreakingShortSEStrList.Clear();
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_00_01Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_00_02Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_00_03Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_00_04Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_00_05Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_00Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_01Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_02Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_03Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_04Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_05Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_06Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_07Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_08Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_09Short");
        woodFloorCreakingShortSEStrList.Add("WOOD FLOOR CREAKING_01_10Short");

        woodFloorCreakingShortPicthMinus6SEStrList.Clear();
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_01Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_02Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_03Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_04Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_00_05Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_00Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_01Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_02Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_03Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_04Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_05Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_06Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_07Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_08Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_09Short_ピッチ-6");
        woodFloorCreakingShortPicthMinus6SEStrList.Add("WOOD FLOOR CREAKING_01_10Short_ピッチ-6");

        himoKishimiShortSEStrList.Clear();
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発01");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発02");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発03");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発04");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発05");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発06");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発07");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発08");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発09");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発10");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発11");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発01_短");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発03_短");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発04_短");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発05_短");
        himoKishimiShortSEStrList.Add("紐・ロープ・引っ張る・きしむ02_単発06_短");


        kashibakoSEStrList.Clear();
        kashibakoSEStrList.Add("菓子箱_紙箱・閉める01");
        kashibakoSEStrList.Add("菓子箱_紙箱・閉める02");
        kashibakoSEStrList.Add("菓子箱_ダンボール箱01-01ピッチ+14");
        kashibakoSEStrList.Add("菓子箱_ダンボール箱01-02ピッチ+14");
        kashibakoSEStrList.Add("菓子箱_ダンボール箱02-02ピッチ+14");
        kashibakoSEStrList.Add("菓子箱_紙箱・開ける01");
        kashibakoSEStrList.Add("菓子箱_紙箱・開ける02");
        kashibakoSEStrList.Add("菓子箱_ダンボール箱・開ける01-01");

        KO_PlayerAsioto_DefList.Clear();
        KO_PlayerAsioto_DefList.Add("足音0_bosu36");
        KO_PlayerAsioto_DefList.Add("足音1_footsteps_shoe_grass_walk_03");
        KO_PlayerAsioto_DefList.Add("足音2_footsteps_shoe_grass_walk_04");
        KO_PlayerAsioto_DefList.Add("足音3_footsteps_shoe_grass_walk_05");

        #endregion
        #region 掴み音系
        //メタル系
        grapMetalStrList.Clear();
        grapMetalStrList.Add("GrapMetal_footsteps_shoe_metal_walk_03");
        grapMetalStrList.Add("GrapMetal_footsteps_shoe_metal_walk_04");
        grapMetalStrList.Add("GrapMetal_footsteps_shoe_metal_walk_05");

        //肌系
        grapHadaStrList.Clear();
        grapHadaStrList.Add("GrapHada01");
        grapHadaStrList.Add("GrapHada02");
        grapHadaStrList.Add("GrapHada03");
        grapHadaStrList.Add("GrapHada04");
        grapHadaStrList.Add("GrapHada05");
        grapHadaStrList.Add("GrapHada06");
        grapHadaStrList.Add("GrapHada07");
        grapHadaStrList.Add("GrapHada08");
        grapHadaStrList.Add("GrapHada09");
        grapHadaStrList.Add("GrapHada10");
        grapHadaStrList.Add("GrapHada11");
        grapHadaStrList.Add("GrapHada12");


        #endregion
        //保留

        #endregion □カメラやキャラや小物・UI

        #region ライトフォルダ と ライト一覧タグ取得(スタートでも念のためやる)
        NullJudgeFind(ref LightFolder, "GameObjects/Light");

        //タグでライト取得
        defLightList.Clear();
        defLightONOFFBoolList.Clear();
        var defLightsObjs = GameObject.FindGameObjectsWithTag("DefLight");
        for (int i = 0; i < defLightsObjs.Length; i++)
        {
            defLightList.Add(defLightsObjs[i].GetComponent<Light>());
            defLightONOFFBoolList.Add(defLightsObjs[i].GetComponent<Light>().enabled);
        }

        #endregion

        //PostProcess設定用Obj（起動時に自動でオフにする用）
        NullJudgeFind(ref PostProcessVolume00DirectDataObj, "PostProcessVolume00DirectDataObj");

        #region AudioMixer初期値取得
        audioMixer = Resources.Load("Main/BGM/AudioMixer") as AudioMixer;
        audioMixer.GetFloat("AsiotoVol", out defAsiotoVol);
        #endregion

        #region ■■Assetフォルダから直接読み取る系 (着替え・ポニー発光など）（厳密にはHierarchyではないので一応分け）
#if UNITY_EDITOR
        mat_body_Barefoot = AssetDatabase.LoadAssetAtPath<Material>(
            "Assets/_Aoigai/Model/Chieri/Models/Materials/mat_body_Barefoot_Hiru.mat");

        mat_body_TankTop = AssetDatabase.LoadAssetAtPath<Material>(
            "Assets/_Aoigai/Model/Chieri/Models/Materials/mat_body_TankTop_Hiru.mat");
        mat_body_TankTop_Barefoot = AssetDatabase.LoadAssetAtPath<Material>(
            "Assets/_Aoigai/Model/Chieri/Models/Materials/mat_body_TankTop_Barefoot_Hiru.mat");


        ponyShinyaMat = AssetDatabase.LoadAssetAtPath<Material>(
            "Assets/_Aoigai/BakedMesh/Pony/Pony_Shinya_mat.mat");
#endif

        #endregion

        ////フェードImageオン
        //GameObject.Find("FadeBlackSceneMoveCanvasImage").GetComponent<Image>().enabled = true;

        EvsLoad();
        DB = null;
    }

    void Awake()//DBとフェード色取得
    {
        //シングルトンのDBは事前に取得しておいては駄目（そのシーンに置かれたDBが読み込まれるため）
        //なのでAwakeで取得
        //ただし、evsのロードなどあるので、事前ロードでは取得して最後に開放（null）する。
        DB = NullJudgeFind("DataBridging").GetComponent<DataBridging>();
        staticFlagDict = DB.transform.Find("StaticFlagDictObj").GetComponent<StaticFlagDict>().staticFlagDict;

        //VRカメラを0位置仕様に（Oculus仕様）
        XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);

        //言語システム起動
        StartCoroutine(LanguageSystemIEnum());
    }

    IEnumerator Start()
    {

        #region ■CameraObjectsをPrefabから取り出し取得

        //■Prefab設置
        GameObject CameraObjectsObj;

        //もし編集用に設置されてたらそれ使用
        if (GameObject.Find("CameraObjects") != null)
        { CameraObjectsObj = GameObject.Find("CameraObjects"); }
        else
        {
            CameraObjectsObj = Instantiate(Resources.Load("Main/Prefab/CameraObjects") as GameObject
                , GameObjectsTrs, false);

            //（Cloneがついてるとまずいっぽい）
            CameraObjectsObj.name = "CameraObjects";
        }
        //プレイヤー（ダミー）取得
        NullJudgeFind(ref Player_DummyTrs, "Player_Dummy");
        //プレイヤーアニメーター取得
        playerAnim = Player_DummyTrs.GetComponent<Animator>();

        #region PlayerFinalIKをAddComponent　（ResourceFilesEditorから移植 改変
        if (Player_DummyTrs.GetComponent<FullBodyBipedIK>() == null)
        {
            PlayerFBBIK = Player_DummyTrs.gameObject.AddComponent<FullBodyBipedIK>();

            //■GetAllChildrenを使ってボーン取得
            List<GameObject> PlayerTrsChildObjAddList = GetAllChildren.GetAll(Player_DummyTrs.gameObject);

            PlayerFBBIK.fixTransforms = false;
            PlayerFBBIK.references.spine = new Transform[2];
            //PlayerFBBIK.references.eyes = new Transform[2];

            foreach (GameObject obj in PlayerTrsChildObjAddList)
            {
                //FinalIK Reference
                PlayerFBBIK.references.root = Player_DummyTrs;
                if (obj.name == "Bip002 Pelvis") { PlayerFBBIK.references.pelvis = obj.transform; }
                if (obj.name == "Bip002 L Thigh") { PlayerFBBIK.references.leftThigh = obj.transform; }
                if (obj.name == "Bip002 L Calf") { PlayerFBBIK.references.leftCalf = obj.transform; }
                if (obj.name == "Bip002 L Foot") { PlayerFBBIK.references.leftFoot = obj.transform; }
                if (obj.name == "Bip002 R Thigh") { PlayerFBBIK.references.rightThigh = obj.transform; }
                if (obj.name == "Bip002 R Calf") { PlayerFBBIK.references.rightCalf = obj.transform; }
                if (obj.name == "Bip002 R Foot") { PlayerFBBIK.references.rightFoot = obj.transform; }
                if (obj.name == "Bip002 L UpperArm") { PlayerFBBIK.references.leftUpperArm = obj.transform; }
                if (obj.name == "Bip002 L Forearm") { PlayerFBBIK.references.leftForearm = obj.transform; }
                if (obj.name == "Bip002 L Hand") { PlayerFBBIK.references.leftHand = obj.transform; }
                if (obj.name == "Bip002 R UpperArm") { PlayerFBBIK.references.rightUpperArm = obj.transform; }
                if (obj.name == "Bip002 R Forearm") { PlayerFBBIK.references.rightForearm = obj.transform; }
                if (obj.name == "Bip002 R Hand") { PlayerFBBIK.references.rightHand = obj.transform; }
                if (obj.name == "Bip002 Head") { PlayerFBBIK.references.head = obj.transform; }

                if (obj.name == "Bip002 Spine") { PlayerFBBIK.references.spine[0] = obj.transform; }
                if (obj.name == "Bip002 Spine1") { PlayerFBBIK.references.spine[1] = obj.transform; }
                //if (obj.name == "joint_L_eye00") { PlayerFBBIK.references.eyes[0] = obj.transform; }
                //if (obj.name == "joint_R_eye00") { PlayerFBBIK.references.eyes[1] = obj.transform; }

                if (obj.name == "Bip002 Spine1") { PlayerFBBIK.solver.rootNode = obj.transform; }
            }

            PlayerFBBIK.SetReferences(PlayerFBBIK.references, PlayerFBBIK.solver.rootNode);

        }

        if (Player_DummyTrs.GetComponent<LookAtIK>() == null)
        {
            PlayerLAIKHead = Player_DummyTrs.gameObject.AddComponent<LookAtIK>();
            PlayerLAIKEye = Player_DummyTrs.gameObject.AddComponent<LookAtIK>();
            PlayerLAIKBody = Player_DummyTrs.gameObject.AddComponent<LookAtIK>();
        }

        if (Player_DummyTrs.GetComponent<CCDIK>() == null)
        {
            PlayerCCDIKRHand = Player_DummyTrs.gameObject.AddComponent<CCDIK>();
            PlayerCCDIKLHand = Player_DummyTrs.gameObject.AddComponent<CCDIK>();
        }
        #endregion

        #region HierarchyObjLoadから移植群

        #region カメラ群
        NullJudgeFind(ref CameraObjectsTrs, "CameraObjects");
        NullJudgeFind(ref CameraAnchorTrs, "CameraAnchorObj");
        NullJudgeFind(ref CameraUserControlTrs, "CameraUserControl");
        NullJudgeFind(ref CameraAdjustTrackingTrs, "CameraAdjustTrackingObj");
        NullJudgeFind(ref VRCameraTrs, "VRCameraObj");
        VRCamera = VRCameraTrs.GetComponent<Camera>();
        VRCameraAudioListener = VRCameraTrs.Find("AudioListener").GetComponent<AudioListener>();
        NullJudgeFind(ref VRUICameraTrs, "VRUICameraObj");
        VRUICamera = VRUICameraTrs.GetComponent<Camera>();
        MessageCanvasTrs = VRUICameraTrs.Find("MessageCanvas");

        NullJudgeFind(ref TPSCameraAnchorTrs, "TPSCameraAnchorObj");
        NullJudgeFind(ref TPSCameraTrs, "TPSCameraObj");
        TPSCamera = TPSCameraTrs.GetComponent<Camera>();
        TPSCameraAudioListener = TPSCameraTrs.GetComponent<AudioListener>();
        NullJudgeFind(ref FreeCameraAnchorTrs, "FreeCameraAnchorObj");
        NullJudgeFind(ref FreeCameraTrs, "FreeCameraObj");
        FreeCamera = FreeCameraTrs.GetComponent<Camera>();
        FreeCameraAudioListener = FreeCameraTrs.GetComponent<AudioListener>();

        #endregion

        #region ■Player

        //GetAllChildrenを使ってボーン取得
        List<GameObject> PlayerTrsChildObjList = GetAllChildren.GetAll(Player_DummyTrs.gameObject);
        foreach (GameObject obj in PlayerTrsChildObjList)
        {
            if (obj.name == "Bip002 R Hand") { PlayerRHandTrs = obj.transform; }
            if (obj.name == "Bip002 L Hand") { PlayerLHandTrs = obj.transform; }
            //if (obj.name == "Bip002 R hitosashi02") { PlayerRhitosashi02Trs = obj.transform; }
            //if (obj.name == "Bip002 L hitosashi03") { PlayerLhitosashi03Trs = obj.transform; }
            if (obj.name == "Bip002 L Calf") { PlayerLCalfTrs = obj.transform; }
            if (obj.name == "Bip002 L Foot") { PlayerLFootTrs = obj.transform; }

            #region FinalIK用ボーンTrs取得
            if (obj.name == "Bip002 Head") { Bip002HeadTrs = obj.transform; }
            if (obj.name == "Bip002 Pelvis") { Bip002PelvisTrs = obj.transform; }
            if (obj.name == "Bip002 Spine") { Bip002Spine = obj.transform; }
            if (obj.name == "Bip002 Spine1") { Bip002Spine1 = obj.transform; }
            if (obj.name == "tempLEye") { tempLEyeTrs = obj.transform; }
            if (obj.name == "tempREye") { tempREyeTrs = obj.transform; }

            //BendGoalの取得も
            if (obj.name == "Bip002 R Forearm") { PlayerFBBIK.solver.rightArmChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip002 L Forearm") { PlayerFBBIK.solver.leftArmChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip002 R Calf") { PlayerFBBIK.solver.rightLegChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip002 L Calf") { PlayerFBBIK.solver.leftLegChain.bendConstraint.bendGoal = obj.transform; }

            //CCDIK用（エイムだけど使わない気もする）
            if (obj.name == "Bip002 R UpperArm") { Bip002_R_UpperArmTrs = obj.transform; }
            if (obj.name == "Bip002 R Forearm") { Bip002_R_ForearmTrs = obj.transform; }
            if (obj.name == "Bip002 R Hand") { Bip002_R_HandTrs = obj.transform; }
            if (obj.name == "Bip002 L UpperArm") { Bip002_L_UpperArmTrs = obj.transform; }
            if (obj.name == "Bip002 L Forearm") { Bip002_L_ForearmTrs = obj.transform; }
            if (obj.name == "Bip002 L Hand") { Bip002_L_HandTrs = obj.transform; }

            #endregion FinalIK用ボーンTrs取得

            //衣装チェンジ用
            if (obj.name == "Body") { Dummy_Body = obj; }
            if (obj.name == "Hand") { Dummy_Hand = obj; }

        }

        NullJudgeFind(ref PlayerKubiNekkoPosObjTrs, "PlayerKubiNekkoPosObj");

        #endregion

        #region プレイヤーTargetやPlayerStandFeetCube
        NullJudgeFind(ref PlayerTargetTrs, "PlayerTarget");
        NullJudgeFind(ref PlayerEyeTargetTrs, "PlayerEyeTarget");
        NullJudgeFind(ref PlayerHeadTargetTrs, "PlayerHeadTarget");
        NullJudgeFind(ref PlayerStandFeetCubeTrs, "PlayerStandFeetCube");


        #endregion サイズ・ステータス系(Targetsなど)

        #region PlayerFinalIK用Target

        NullJudgeFind(ref PlayerIKLookAtHeadTargetTrs, "PlayerIKLookAtHeadTarget");
        NullJudgeFind(ref PlayerIKLookAtEyeTargetTrs, "PlayerIKLookAtEyeTarget");
        NullJudgeFind(ref PlayerIKLookAtBodyTargetTrs, "PlayerIKLookAtBodyTarget");
        NullJudgeFind(ref PlayerIKBodyTargetTrs, "PlayerIKBodyTarget");
        NullJudgeFind(ref PlayerIKLHandTargetTrs, "PlayerIKLHandTarget");
        NullJudgeFind(ref PlayerIKLShoulderTargetTrs, "PlayerIKLShoulderTarget");
        NullJudgeFind(ref PlayerIKRHandTargetTrs, "PlayerIKRHandTarget");
        NullJudgeFind(ref PlayerIKRShoulderTargetTrs, "PlayerIKRShoulderTarget");
        NullJudgeFind(ref PlayerIKLFootTargetTrs, "PlayerIKLFootTarget");
        NullJudgeFind(ref PlayerIKLThighTargetTrs, "PlayerIKLThighTarget");
        NullJudgeFind(ref PlayerIKRFootTargetTrs, "PlayerIKRFootTarget");
        NullJudgeFind(ref PlayerIKRThighTargetTrs, "PlayerIKRThighTarget");
        NullJudgeFind(ref PlayerCCDIKRHandTargetTrs, "PlayerCCDIKRHandTarget");
        NullJudgeFind(ref PlayerCCDIKLHandTargetTrs, "PlayerCCDIKLHandTarget");

        #endregion

        //■頭に追従用FinalIKスクリプト の入ったObj（VRカメラにペアレントされている）
        NullJudgeFind(ref PlayerFBBIKHeadEffectorObj, "PlayerFBBIKHeadEffector");
        //↑からの追従情報を受け取って、FBBIKで操作する、PlayerBipedの親Obj（子にPlayerBiped本体がいる）
        NullJudgeFind(ref PlayerFBBIKtoHeadEffectorObj, "PlayerFBBIKtoHeadEffector");


        #endregion


        #endregion

        #region ■ちえりをPrefabから取り出し取得

        //■ChieriとHighLegが入ったPrefab設置（HighLegがChieriのパーツ紐付け取得しているため（こちらで取得しなおせば分離しても良さそう））
        GameObject ChieriAndHighLegObj;

        //もし編集用に設置されてたらそれ使用
        if (GameObject.Find("ChieriAndHighLeg") != null)
        { ChieriAndHighLegObj = GameObject.Find("ChieriAndHighLeg"); }
        else
        {
            ChieriAndHighLegObj = Instantiate(Resources.Load("Main/Prefab/ChieriAndHighLeg") as GameObject
                , GameObjectsTrs, false);
        }

        //ちえり取得
        GirlTrs = ChieriAndHighLegObj.transform.Find("Chieri");

        //ちえりとHighLegをGameobjects直下へペアレント
        GirlTrs.SetParent(GameObjectsTrs, false);
        ChieriAndHighLegObj.transform.Find("HighLeg").SetParent(GameObjectsTrs, false);
        //ChieriAndHighLeg削除
        Destroy(ChieriAndHighLegObj);

        //智恵理アニメーター取得
        girlAnim = GirlTrs.GetComponent<Animator>();


        #region ちえりFinalIKをAddComponent　（ResourceFilesEditorから移植 改変

        if (GirlTrs.GetComponent<FullBodyBipedIK>() == null)
        {
            FBBIK = GirlTrs.gameObject.AddComponent<FullBodyBipedIK>();
            //■GetAllChildrenを使ってボーン取得（chieriがあれば）
            List<GameObject> GirlTrsChildObjAddList = GetAllChildren.GetAll(GirlTrs.gameObject);

            FBBIK.fixTransforms = false;
            FBBIK.references.spine = new Transform[2];
            FBBIK.references.eyes = new Transform[2];

            foreach (GameObject obj in GirlTrsChildObjAddList)
            {
                //FinalIK Reference
                FBBIK.references.root = GirlTrs;
                if (obj.name == "Bip001 Pelvis") { FBBIK.references.pelvis = obj.transform; }
                if (obj.name == "Bip001 L Thigh") { FBBIK.references.leftThigh = obj.transform; }
                if (obj.name == "Bip001 L Calf") { FBBIK.references.leftCalf = obj.transform; }
                if (obj.name == "Bip001 L Foot") { FBBIK.references.leftFoot = obj.transform; }
                if (obj.name == "Bip001 R Thigh") { FBBIK.references.rightThigh = obj.transform; }
                if (obj.name == "Bip001 R Calf") { FBBIK.references.rightCalf = obj.transform; }
                if (obj.name == "Bip001 R Foot") { FBBIK.references.rightFoot = obj.transform; }
                if (obj.name == "Bip001 L UpperArm") { FBBIK.references.leftUpperArm = obj.transform; }
                if (obj.name == "Bip001 L Forearm") { FBBIK.references.leftForearm = obj.transform; }
                if (obj.name == "Bip001 L Hand") { FBBIK.references.leftHand = obj.transform; }
                if (obj.name == "Bip001 R UpperArm") { FBBIK.references.rightUpperArm = obj.transform; }
                if (obj.name == "Bip001 R Forearm") { FBBIK.references.rightForearm = obj.transform; }
                if (obj.name == "Bip001 R Hand") { FBBIK.references.rightHand = obj.transform; }
                if (obj.name == "Bip001 Head") { FBBIK.references.head = obj.transform; }

                if (obj.name == "Bip001 Spine") { FBBIK.references.spine[0] = obj.transform; }
                if (obj.name == "Bip001 Spine1") { FBBIK.references.spine[1] = obj.transform; }
                if (obj.name == "joint_L_eye00") { FBBIK.references.eyes[0] = obj.transform; }
                if (obj.name == "joint_R_eye00") { FBBIK.references.eyes[1] = obj.transform; }

                if (obj.name == "Bip001 Spine1") { FBBIK.solver.rootNode = obj.transform; }
            }

            FBBIK.SetReferences(FBBIK.references, FBBIK.solver.rootNode);
        }

        if (GirlTrs.GetComponent<LookAtIK>() == null)
        {
            LAIKHead = GirlTrs.gameObject.AddComponent<LookAtIK>();
            LAIKEye = GirlTrs.gameObject.AddComponent<LookAtIK>();
            LAIKBody = GirlTrs.gameObject.AddComponent<LookAtIK>();
        }

        if (GirlTrs.GetComponent<CCDIK>() == null)
        {
            CCDIKRHand = GirlTrs.gameObject.AddComponent<CCDIK>();
            CCDIKLHand = GirlTrs.gameObject.AddComponent<CCDIK>();
        }
        #endregion

        #region HierarchyObjLoadから移植群


        #region GetAllChildrenを使ってボーンTrs ブレンドシェイプ FinalIK用のボーンとBendGoalなど取得

        List<GameObject> GirlTrsChildObjList = GetAllChildren.GetAll(GirlTrs.gameObject);
        foreach (GameObject obj in GirlTrsChildObjList)
        {
            if (obj.name == "AnimTriggerBoneObj") { AnimTriggerBoneObj = obj; }
            if (obj.name == "Mesh") { GirlMeshTrs = obj.transform; }
            if (obj.name == "ColBldMeshs") { GirlColBldMeshsTrs = obj.transform; }
            if (obj.name == "Body") { BodyObj = obj; }
            if (obj.name == "Socks") { SocksObj = obj; }
            if (obj.name == "Bip001 R Forearm") { GirlRForearmTrs = obj.transform; }
            if (obj.name == "Bip001 R UpperArm") { GirlRUpperArmTrs = obj.transform; }
            if (obj.name == "Bip001 R Hand") { GirlRHandTrs = obj.transform; }
            if (obj.name == "Bip001 L Forearm") { GirlLForearmTrs = obj.transform; }
            if (obj.name == "Bip001 L UpperArm") { GirlLUpperArmTrs = obj.transform; }
            if (obj.name == "Bip001 L Hand") { GirlLHandTrs = obj.transform; }
            if (obj.name == "Bip001 R hitosashi00") { GirlRhitosashi00Trs = obj.transform; }
            if (obj.name == "Bip001 R hitosashi02") { GirlRhitosashi02Trs = obj.transform; }
            if (obj.name == "Bip001 R ko00") { GirlRko00Trs = obj.transform; }
            if (obj.name == "Bip001 R naka00") { GirlRnaka00Trs = obj.transform; }
            if (obj.name == "Bip001 R oya00") { GirlRoya00Trs = obj.transform; }
            if (obj.name == "Bip001 R oya02") { GirlRoya02Trs = obj.transform; }
            if (obj.name == "Bip001 R kusuri00") { GirlRkusuri00Trs = obj.transform; }
            if (obj.name == "Bip001 L hitosashi00") { GirlLhitosashi00Trs = obj.transform; }
            if (obj.name == "Bip001 L hitosashi02") { GirlLhitosashi02Trs = obj.transform; }
            if (obj.name == "Bip001 L ko00") { GirlLko00Trs = obj.transform; }
            if (obj.name == "Bip001 L kusuri00") { GirlLkusuri00Trs = obj.transform; }
            if (obj.name == "Bip001 L naka00") { GirlLnaka00Trs = obj.transform; }
            if (obj.name == "Bip001 L oya00") { GirlLoya00Trs = obj.transform; }
            if (obj.name == "Bip001 R Thigh") { GirlRThighTrs = obj.transform; }
            if (obj.name == "Bip001 L Thigh") { GirlLThighTrs = obj.transform; }
            if (obj.name == "Bip001 R Calf") { GirlRCalfTrs = obj.transform; }
            if (obj.name == "Bip001 L Calf") { GirlLCalfTrs = obj.transform; }
            if (obj.name == "sub_knee_R") { Girlsub_knee_RTrs = obj.transform; }
            if (obj.name == "sub_knee_L") { Girlsub_knee_LTrs = obj.transform; }
            if (obj.name == "Bip001 R Foot") { GirlRFootTrs = obj.transform; }
            if (obj.name == "Bip001 L Foot") { GirlLFootTrs = obj.transform; }
            if (obj.name == "Bip001 R Toe4") { GirlRToe4Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe41") { GirlRToe41Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe3") { GirlRToe3Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe31") { GirlRToe31Trs = obj.transform; }
            if (obj.name == "Tang0000") { GirlTang0000Trs = obj.transform; }
            if (obj.name == "Tang0001") { GirlTang0001Trs = obj.transform; }
            if (obj.name == "Tang0002") { GirlTang0002Trs = obj.transform; }
            if (obj.name == "Tang0003") { GirlTang0003Trs = obj.transform; }
            if (obj.name == "Tooth_Bone00") { GirlTooth00Trs = obj.transform; }
            if (obj.name == "Tooth_Bone01") { GirlTooth01Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe2") { GirlRToe2Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe1") { GirlRToe1Trs = obj.transform; }
            if (obj.name == "Bip001 R Toe0") { GirlRToe0Trs = obj.transform; }
            if (obj.name == "Bip001 L Toe4") { GirlLToe4Trs = obj.transform; }
            if (obj.name == "Bip001 L Toe3") { GirlLToe3Trs = obj.transform; }
            if (obj.name == "Bip001 L Toe2") { GirlLToe2Trs = obj.transform; }
            if (obj.name == "Bip001 L Toe1") { GirlLToe1Trs = obj.transform; }
            if (obj.name == "Bip001 L Toe0") { GirlLToe0Trs = obj.transform; }
            if (obj.name == "Bip001 Pelvis") { GirlPelvisTrs = obj.transform; }
            if (obj.name == "Bip001 Spine") { GirlSpineTrs = obj.transform; }
            if (obj.name == "Bip001 Spine1") { GirlSpine1Trs = obj.transform; }
            if (obj.name == "Bip001 Head") { GirlHeadTrs = obj.transform; }
            if (obj.name == "sk_root") { sk_rootTrs = obj.transform; }

            #region 表情 girl SkinnedMeshRendererブレンドシェイプ群
            //顎咥内飛び出し防ぎ用
            if (obj.name == "Kounai_def") { Kounai_def = obj.GetComponent<SkinnedMeshRenderer>(); }
            if (obj.name == "Mouth_def") { Mouth_def = obj.GetComponent<SkinnedMeshRenderer>(); }

            //笑顔時ハイライト消し　＋　まばたきキャンセル判定用SkinnesMeshRender
            if (obj.name == "EYE_def") { EYE_def = obj.GetComponent<SkinnedMeshRenderer>(); }
            //if (obj.name == "Eye_high_def") { Eye_high_def = obj.GetComponent<SkinnedMeshRenderer>(); }

            //汗
            if (obj.name == "Ase") { Ase = obj.GetComponent<SkinnedMeshRenderer>(); }

            //照れ スマイルに合わせたモーフ（照れ表示ではない。Smileと同期させる）//照れはメッシュのフェードインアウトで
            if (obj.name == "Tere") { Tere = obj.GetComponent<SkinnedMeshRenderer>(); }
            #endregion　表情 girl SkinnedMeshRendererブレンドシェイプ群

            #region FinalIK用ボーンTrs取得

            if (obj.name == "Bip001") { Bip001Trs = obj.transform; }
            if (obj.name == "Bip001 Neck") { Bip001NeckTrs = obj.transform; }
            if (obj.name == "Bip001 Head") { Bip001HeadTrs = obj.transform; }
            if (obj.name == "Bip001 Pelvis") { Bip001PelvisTrs = obj.transform; }
            if (obj.name == "Bip001 Spine") { Bip001Spine = obj.transform; }
            if (obj.name == "Bip001 Spine1") { Bip001Spine1 = obj.transform; }
            if (obj.name == "joint_L_eye00") { joint_L_eye00Trs = obj.transform; }
            if (obj.name == "joint_R_eye00") { joint_R_eye00Trs = obj.transform; }

            //BendGoalの取得も
            if (obj.name == "Bip001 R Forearm") { FBBIK.solver.rightArmChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip001 L Forearm") { FBBIK.solver.leftArmChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip001 R Calf") { FBBIK.solver.rightLegChain.bendConstraint.bendGoal = obj.transform; }
            if (obj.name == "Bip001 L Calf") { FBBIK.solver.leftLegChain.bendConstraint.bendGoal = obj.transform; }

            //CCDIK用（エイムだけど使わない気もする）
            if (obj.name == "Bip001 R UpperArm") { Bip001_R_UpperArmTrs = obj.transform; }
            if (obj.name == "Bip001 R Forearm") { Bip001_R_ForearmTrs = obj.transform; }
            if (obj.name == "Bip001 R Hand") { Bip001_R_HandTrs = obj.transform; }
            if (obj.name == "Bip001 L UpperArm") { Bip001_L_UpperArmTrs = obj.transform; }
            if (obj.name == "Bip001 L Forearm") { Bip001_L_ForearmTrs = obj.transform; }
            if (obj.name == "Bip001 L Hand") { Bip001_L_HandTrs = obj.transform; }

            #endregion FinalIK用ボーンTrs取得

            //Mesh群
            if (obj.name == "Body") { Body = obj; }
            if (obj.name == "Body02") { Body02 = obj; }
            if (obj.name == "Mae_hair") { Mae_hair = obj; }
            if (obj.name == "Naka_hair") { Naka_hair = obj; }
            if (obj.name == "Ushiro_hair") { Ushiro_hair = obj; }
            if (obj.name == "Pony") { PonyTail = obj; }
            if (obj.name == "Hair_Basic_FrontShadowOnly") { Hair_Basic_FrontShadowOnlyTrs = obj.transform; }

            //FaceLight
            if (obj.name == "Face Light") { GirlFaceLightTrs = obj.transform; }


        }

        #endregion

        //智恵理小物取得
        NullJudgeFind(ref SharpenObj, "Sharpen", "Main/KomonoObj/Sharpen/Sharpen");
        NullJudgeFind(ref KeshigomuObj, "Keshigomu");


        #region ちえりSphereTrs群
        NullJudgeFind(ref HeadSphereTrs, "HeadSphere");
        NullJudgeFind(ref BreastSphereTrs, "BreastSphere");
        NullJudgeFind(ref SpineSphereTrs, "SpineSphere");
        NullJudgeFind(ref PantsSphereTrs, "PantsSphere");
        NullJudgeFind(ref RHandSphereTrs, "RHandSphere");
        NullJudgeFind(ref LHandSphereTrs, "LHandSphere");
        NullJudgeFind(ref RFootSphereTrs, "RFootSphere");
        NullJudgeFind(ref LFootSphereTrs, "LFootSphere");
        #endregion

        #region ちえりFinalIK用ターゲット

        NullJudgeFind(ref IKLookAtHeadTargetTrs, "IKLookAtHeadTarget");
        NullJudgeFind(ref IKLookAtEyeTargetTrs, "IKLookAtEyeTarget");
        NullJudgeFind(ref IKLookAtBodyTargetTrs, "IKLookAtBodyTarget");
        NullJudgeFind(ref IKBodyTargetTrs, "IKBodyTarget");
        NullJudgeFind(ref IKLHandTargetTrs, "IKLHandTarget");
        NullJudgeFind(ref IKLShoulderTargetTrs, "IKLShoulderTarget");
        NullJudgeFind(ref IKRHandTargetTrs, "IKRHandTarget");
        NullJudgeFind(ref IKRShoulderTargetTrs, "IKRShoulderTarget");
        NullJudgeFind(ref IKLFootTargetTrs, "IKLFootTarget");
        NullJudgeFind(ref IKLThighTargetTrs, "IKLThighTarget");
        NullJudgeFind(ref IKRFootTargetTrs, "IKRFootTarget");
        NullJudgeFind(ref IKRThighTargetTrs, "IKRThighTarget");
        NullJudgeFind(ref CCDIKRHandTargetTrs, "CCDIKRHandTarget");
        NullJudgeFind(ref CCDIKLHandTargetTrs, "CCDIKLHandTarget");

        #endregion

        #endregion

        #endregion


        #region カメラやキャラや小物・UI サウンド  表情の汗と照れはマテリアル操作があるので透明に初期化　元Awakeにあったもの（Awakeの必要なさそうなので試しに移設20171121）

        defPlayerLocalPos = CameraObjectsTrs.localPosition;

        //表情の汗と照れはマテリアル操作があるので透明に初期化
        Ase.material.color = new Color(1, 1, 1, 0);

        tereMaterial = Tere.material;
        tereDefOnColor = tereMaterial.color;
        tereOnColor = tereDefOnColor;
        tereDefOffColor = new Color(tereDefOnColor.r, tereDefOnColor.g, tereDefOnColor.b, 0);

        #region 小物
        //ペン机に置く
        SharpenObj.transform.SetParent(RoomTrs);
        SharpenObj.transform.localPosition = Sharpen_table_Room_ParameterTrs.localPosition;
        SharpenObj.transform.localEulerAngles = Sharpen_table_Room_ParameterTrs.localEulerAngles;
        SharpenObj.transform.localScale = Vector3.one;

        //消しゴム置く
        KeshigomuObj.transform.SetParent(RoomTrs);
        KeshigomuObj.transform.localPosition = Keshigomu_table_Room_ParameterTrs.localPosition;
        KeshigomuObj.transform.localEulerAngles = Keshigomu_table_Room_ParameterTrs.localEulerAngles;
        KeshigomuObj.transform.localScale = Vector3.one;

        //文具位置取得
        bunguDefPos = BunguTrs.position;
        bunguDefEul = BunguTrs.eulerAngles;

        //エッフェル位置取得
        eiffel_hiObjDefPos = Eiffel_hiTrs.position;
        eiffel_hiObjDefEul = Eiffel_hiTrs.eulerAngles;

        //ポニー位置取得
        ponyDefPos = PonyTrs.position;
        ponyDefEul = PonyTrs.eulerAngles;

        //スクールバッグ位置取得
        schoolBagDefPos = SchoolBagTrs.position;
        schoolBagDefEul = SchoolBagTrs.eulerAngles;
        //夕方なら机横に
        if (SceneManager.GetActiveScene().name == "TH_Yugata")
        {
            GameObject SchoolBagTsukueYokoPosObj
                = Resources.Load("_PosObj/SchoolBagTsukueYokoPosObj") as GameObject;
            SchoolBagTrs.localPosition = SchoolBagTsukueYokoPosObj.transform.localPosition;
            SchoolBagTrs.localEulerAngles = SchoolBagTsukueYokoPosObj.transform.localEulerAngles;
        }

        #endregion 智恵理小物


        //■UI_SE・BGM
        //ポインターレイヤーを変更
        SeePointTrs.GetComponent<MeshRenderer>().sortingLayerName = "seePoint";
        #endregion カメラやキャラや小物・UI サウンド
        //FinalIKのスクリプト付与はResourceFilesEditorで行ってる（事前にインスペクター設定が仕様っぽい？）

        //DontDestroyなフォルダ取得（スタートで取得しないとシーン移動時に外れる）
        NullJudgeFind(ref DontDestroySoundObjsTrs, "DontDestroySoundObjs");


        enabled = false;//コンポーネントOFFにすることでStart終わるまでUpdate開始しない（最後でONにしてる）

        ////PCOculusかSteamVRかで カメラアンカーの高さDefを設定
        ////■ひとまずVR時はSteam前提とす
        //if (UnityEngine.XR.XRSettings.enabled)
        //{
        //    DB.cameraSitAnchorDefLocalPos = DB.steamVRcameraSitAnchorDefLocalPos;
        //    DB.cameraStandAnchorDefLocalPos = DB.steamVRcameraStandAnchorDefLocalPos;
        //}

        #region メニュー系 音量ロード
        audioMixer.SetFloat("MasterVol", (volumeCurve.Evaluate(DB.userMasterVolume / 80) * 80) - 80);
        audioMixer.SetFloat("BGMVol", (volumeCurve.Evaluate(DB.userBGMVolume / 80) * 80) - 80);
        audioMixer.SetFloat("SEVol", (volumeCurve.Evaluate(DB.userSEVolume / 80) * 80) - 80);
        #endregion

        #region SE・BGMはシーン間でも鳴らすためにStartで取得

        speaker = NullJudgeFind("speaker_sound").GetComponent<Speaker>();
        speakerHighPass = NullJudgeFind("speaker_sound").GetComponent<AudioHighPassFilter>();
        aircon = NullJudgeFind("aircon_sound").GetComponent<Aircon>();
        clockSE = NullJudgeFind("ClockSEObj").GetComponent<ClockSE>();
        townSE = NullJudgeFind("TownSEObj").GetComponent<TownSE>();
        semiSE = NullJudgeFind("SemiSEObj").GetComponent<SemiSE>();

        #region ■BGM SE再生用Obj群
        NullJudgeFind(ref DirectBGMObj, "DirectBGMObj");
        NullJudgeFind(ref OtherSEObj, "OtherSEObj");
        NullJudgeFind(ref Other3DSEObj, "Other3DSEObj");
        NullJudgeFind(ref AsiotoSEObj, "AsiotoSEObj");
        NullJudgeFind(ref KashibakoSEObj, "KashibakoSEObj");
        NullJudgeFind(ref UISEObj, "UISEObj");
        NullJudgeFind(ref HukidashiSEObj, "HukidashiSEObj");
        NullJudgeFind(ref ChairSEObj, "ChairSEObj");
        NullJudgeFind(ref ClockSEObj, "ClockSEObj");
        NullJudgeFind(ref DoorSEObj, "DoorSEObj");
        NullJudgeFind(ref ChimeSEObj, "ChimeSEObj");
        NullJudgeFind(ref FracturedSEObj, "FracturedSEObj");
        NullJudgeFind(ref SocksSEObj, "SocksSEObj");
        NullJudgeFind(ref KO_IdouPoint3DSEObj, "KO_IdouPoint3DSEObj");

        #endregion

        #region AudioMixer導入
        audioMixer = Resources.Load("Main/BGM/AudioMixer") as AudioMixer;

        NullJudgeFind(ref SounderTrs, "Sounder");

        sounderBGMAudioSource = DirectBGMObj.GetComponent<AudioSource>();
        sounderSEAudioSource = OtherSEObj.GetComponent<AudioSource>();

        //outputに割り当て
        sounderBGMAudioSource.outputAudioMixerGroup = audioMixer.FindMatchingGroups("DirectBGM")[0];
        sounderSEAudioSource.outputAudioMixerGroup = audioMixer.FindMatchingGroups("OtherSE")[0];

        #endregion
        //AudioMixer初期値を割り当て
        audioMixer.SetFloat("AsiotoVol", defAsiotoVol);

        //AudioMixerの初期値取得は事前ロードで（ここでやると変更された値を読むため意味無し）

        #endregion

        #region FadeCanvas系（シングルトン化したため、事前取得やめてStart取得）

        #region NewFadeBlack用
        newFadeBlackMat = VRCameraTrs.GetComponent<CameraFadeBlack>().material;
        newFadeBlackUIFrontMat = VRUICameraTrs.GetComponent<CameraFadeBlack>().material;
        #endregion

        NullJudgeFind(ref FadeCanvasObj, "FadeCanvas");
        fadeImage = FadeCanvasObj.GetComponent<FadeImage>();
        fadeBlackQuadMeshRenderer = NullJudgeFind("FadeBlackQuad").GetComponent<MeshRenderer>();
        fadeWhiteQuadMeshRenderer = NullJudgeFind("FadeWhiteQuad").GetComponent<MeshRenderer>();
        fadeBlackUIQuadMeshRenderer = NullJudgeFind("FadeBlackUIQuad").GetComponent<MeshRenderer>();
        fadeWhiteUIQuadMeshRenderer = NullJudgeFind("FadeWhiteUIQuad").GetComponent<MeshRenderer>();
        fadeBlackSmartPhoneQuadMeshRenderer = NullJudgeFind("FadeBlackSmartPhoneQuad").GetComponent<MeshRenderer>();
        fadeColorQuadMeshRenderer = FadeCanvasObj.transform.Find("FadeColorQuad").GetComponent<MeshRenderer>();

        //CanvasフェードオブジェHiru更新できないので一時的にnullチェック
        if (GameObject.Find("FadeBlackCanvasImage") != null)
        { fadeBlackCanvasImage = NullJudgeFind("FadeBlackCanvasImage").GetComponent<Image>(); }

        NullJudgeFind(ref VRFadeCameraTrs, "VRFadeCameraObj");
        VRFadeCamera = VRFadeCameraTrs.GetComponent<Camera>();
        #endregion

        #region ライト一覧取得（事前ロードでもやってるが、一応）

        //タグでライト取得
        defLightList.Clear();
        defLightONOFFBoolList.Clear();
        var defLightsObjs = GameObject.FindGameObjectsWithTag("DefLight");
        for (int i = 0; i < defLightsObjs.Length; i++)
        {
            defLightList.Add(defLightsObjs[i].GetComponent<Light>());
            defLightONOFFBoolList.Add(defLightsObjs[i].GetComponent<Light>().enabled);
        }

        #endregion

        //智恵理コリダーFixed処理システム
        SetChieriColliders();

        //ちえりColBldMeshsアクティブオフ
        GirlColBldMeshsTrs.gameObject.SetActive(false);

        //プレイヤー位置宿題デフォルトにしてトラッキングリセット（今のままではここで座ってないといけない）
        CameraReset(Vector3.zero
            , DB.cameraSitAnchorDefLocalPos
            , true);

        //PPv1
        StartCoroutine(PostProcessingEffectSystemCor());
        //PPv2
        StartCoroutine(PostProcessingV2SystemIEnum());

        //■オプションで設定されたユーザー変更ロード（boolと値）
        PPUserLoad();

        //身長表示
        if (DB.isUserFixityMakotoHeightVis)
        {
            isInfoMakotoHeightVis = true;
        }


        #region TPSモードBool読み取って起動
        if (DB.isUserTPSMode)
        {
            //TPSCameraシステム起動
            StartCoroutine(TPSCameraSystemIEnum());
        }
        else //オフの場合はTPSMode=0と同じ処理
        {
            TPSCamera.enabled = false;
            //VR時はカメラリセット挟む
            if (XRSettings.enabled) { CameraReset(null, null, true); }

            //FreeCamera時はFreeCameraのONOFF
            if (isFreeCameraModeSystem) { FreeCamera.enabled = true; }
            else { VRCamera.enabled = true; }
            //モデル非表示
            if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }

            //通常時にONかOFFか
            if (isDummyHandVis) { Dummy_Hand.SetActive(true); }
            else { Dummy_Hand.SetActive(false); }

            //登り時にONかOFFか
            if (isANSystem == false)
            { if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }

        }
        #endregion
        //↓いらなそうだけど、一応参考の為に
        #region //起動時はTPSオフ状態（TPSモードがONでもオフでもMode=0状態（太一を消すため））
        //TPSCamera.enabled = false;
        ////VR時はカメラリセット挟む
        //if (XRSettings.enabled) { CameraReset(); }

        //VRCamera.enabled = true;
        ////モデル非表示
        //if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }
        //if (isANSystem == false)
        //{ if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }
        #endregion

        #region 着替え系
        //デフォルトのマテリアル読み込み
        #region シーン別マテリアル読み込み
        if (SceneManager.GetActiveScene().name == "TH_Asa")
        {
            mat_body = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().AsaMat;
            mat_body_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().barefoot_Asa;
            mat_body_TankTop = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_Asa;
            mat_body_TankTop_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_barefoot_Asa;
            mat_body_Bikini = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().bikini_Asa;
        }
        else if (SceneManager.GetActiveScene().name == "TH_Hiru")
        {
            mat_body = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().HiruMat;
            mat_body_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().barefoot_Hiru;
            mat_body_TankTop = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_Hiru;
            mat_body_TankTop_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_barefoot_Hiru;
            mat_body_Bikini = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().bikini_Hiru;
        }
        else if (SceneManager.GetActiveScene().name == "TH_Yugata")
        {
            mat_body = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().YugataMat;
            mat_body_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().barefoot_Yugata;
            mat_body_TankTop = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_Yugata;
            mat_body_TankTop_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_barefoot_Yugata;
            mat_body_Bikini = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().bikini_Yugata;
        }
        else if (SceneManager.GetActiveScene().name == "TH_Yoru")
        {
            mat_body = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().YoruMat;
            mat_body_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().barefoot_Yoru;
            mat_body_TankTop = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_Yoru;
            mat_body_TankTop_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_barefoot_Yoru;
            mat_body_Bikini = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().bikini_Yoru;
        }
        else if (SceneManager.GetActiveScene().name == "TH_Shinya")
        {
            mat_body = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().ShinyaMat;
            mat_body_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().barefoot_Shinya;
            mat_body_TankTop = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_Shinya;
            mat_body_TankTop_Barefoot = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().tankTop_barefoot_Shinya;
            mat_body_Bikini = BodyObj.GetComponent<MatResources_bodyBarefootTanktop>().bikini_Shinya;
        }
        else //それ以外のシーンでは、現在ついてるMaterial
        {
            mat_body =
            mat_body_Barefoot =
            mat_body_TankTop =
            mat_body_TankTop_Barefoot =
            mat_body_Bikini =
            BodyObj.GetComponent<Renderer>().material;
        }
        #endregion

        #region 朝シーン前髪シャドウObjオフ　深夜FaceLight Int0.5
        if (SceneManager.GetActiveScene().name == "TH_Asa")
        {
            Hair_Basic_FrontShadowOnlyTrs.gameObject.SetActive(false);
        }
        else if (SceneManager.GetActiveScene().name == "TH_Shinya")
        {
            GirlFaceLightTrs.GetComponent<Light>().intensity = 0.5f;
        }
        #endregion

        #region ユーザーの着替え設定を読み込まない場合
        if (DB.isUserFixityOutfit == false)
        {
            //朝と深夜を一旦タンクトップ素足強制に
            if (SceneManager.GetActiveScene().name == "TH_Asa" || SceneManager.GetActiveScene().name == "TH_Shinya")
            {
                DB.isUserClothsBarefoot = DB.isUserClothsTankTop = true;
                DB.isUserClothsBikini = false;
            }
            else//朝と深夜以外はデフォルト靴下強制に
            {
                DB.isUserClothsBarefoot = DB.isUserClothsTankTop = false;
                DB.isUserClothsBikini = false;
            }
        }

        #endregion
        //メソッドで処理
        ClothsApply();

        #endregion

        #region マテリアル系（ポニー発光など）（ひとまず着替えとは別regionに）
        ponyDefMat = PonyTrs.GetComponent<Renderer>().material;

        #endregion

        //アニメトリガー読み取りシステム起動（足音やエフェクトなど）
        StartCoroutine(AnimEventSystemIEnum());

        ////宿題システムスタート
        //StartCoroutine(HomeworkSystem());

        #region デバッグモード判定
        //デバッグついてたら起動しておく
        if (DB.isDebugMode) { StartCoroutine(DebugModeSystem()); }
        //デバッグOFFかつDebugObjects存在してたら消し
        else if (GameObject.Find("DebugObjects") != null) { Destroy(GameObject.Find("DebugObjects")); }
        #endregion

        //ノベルシステムスタート（Dict読み込んでおきたいため）
        StartCoroutine(NovelSystemLoad());

        //スマホシステムスタート
        StartCoroutine(PlayerSumahoSystemCor());

        //フキダシシステムスタート
        StartCoroutine(HukidashiSystem());

        //プレイヤー体力ゲージスタート
        StartCoroutine(PlayerHPSystemCor());

        //情報表示システムスタート（身長FPSなど）
        StartCoroutine(InfoVisSystemIEnum());

        //智恵理肩ボーンツイスト自動切りシステムスタート
        StartCoroutine(TwistAutoOffSystemIEnum());

        //時計システムスタート
        StartCoroutine(ClockSystemIEnum());

        //かくれおに歩きスピードと足音スピードデフォルトに（走り）
        playerMoveSpeed = 4f;
        KO_AsiotoTimeCountMaxFloat = 0.35f;


        #region XR状況判定で処理変更（Fadeカメラのパースペクティブなど）

        //FadeCameraのProjectionがパースペクティブ状態 で PostProcessingを使うと
        //VR時に描画がおかしくなる（左端に更新されない1ドットが出たりする。（深夜のスマホシーンで白がBloomで滲んだりする））
        //ので、VR時にはOrthograficにする。（これだとなぜか防げる）
        //VRじゃなければパースペクティブに。

        if (XRSettings.enabled)
        {
            VRFadeCamera.orthographic = true;
        }
        else
        {
            VRFadeCamera.orthographic = false;//パースペクティブに
        }


        #endregion


        #region モーション 表情 OriBreathController
        #region モーションディレイ実行キャンセル用にレイヤー数だけコルーチンリスト用意
        //■智恵理
        //まずクリア
        chieriMotionDelayCorList.Clear();
        //追加
        for (int i = 0; i < girlAnim.layerCount; i++)
        { chieriMotionDelayCorList.Add(null); }

        //■プレイヤー
        //まずクリア
        playerMotionDelayCorList.Clear();
        //追加
        for (int i = 0; i < playerAnim.layerCount; i++)
        { playerMotionDelayCorList.Add(null); }

        #endregion

        #region 表情の値、歯以外全部0に初期化
        SkinnedMeshRenderer[] renderers = GirlTrs.GetComponentsInChildren<SkinnedMeshRenderer>();
        for (int i = 0; i < renderers.Length; i++)
        {
            if (renderers[i].name == "Tooth_def")//歯だけは84
            { renderers[i].SetBlendShapeWeight(0, 84); }

            else
            {
                for (int k = 0; k < renderers[i].sharedMesh.blendShapeCount; k++)
                { renderers[i].SetBlendShapeWeight(k, 0); }
            }
        }
        #endregion

        OriBreathController = GirlTrs.GetComponent<Mebiustos.BreathController.OriBreathController>();

        #endregion

        #region サイズ・ステータス系(Targetsなど)

        // C#ではスケールやポジションを直接数値入力することができない。一度Vector3の一時変数を作って代入するとできる。
        //DBから取得
        nowPlayerLocalScale = DB.cameraObjectsResetLocalScl;
        CameraObjectsTrs.localEulerAngles = nowPlayerLocalEur;


        //■初期ローカル座標を保持してペアレント
        PlayerTargetTrs.SetParent(VRCameraTrs, false);
        PlayerEyeTargetTrs.SetParent(VRCameraTrs, false);
        PlayerHeadTargetTrs.SetParent(VRCameraTrs, false);
        PlayerStandFeetCubeTrs.SetParent(CameraObjectsTrs, false);

        //智恵理のターゲット当てはめは智恵理がいれば
        if (GirlTrs != null)
        {
            HeadSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head"), false);
            BreastSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1"), false);
            SpineSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis"), false);
            PantsSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis"), false);
            RHandSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R naka00/Bip001 R naka01/Bip001 R naka02"), false);
            LHandSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L naka00/Bip001 L naka01/Bip001 L naka02"), false);
            RFootSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot"), false);
            LFootSphereTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot"), false);

            //LFootColTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot"), false);
            //RFootColTrs.SetParent(GirlTrs.Find("Bip001/Bip001 Pelvis/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot"), false);
        }




        #endregion

        #region Ray関係

        //プレイヤーのRay（Updateにもあるが、空だと最初のフレームでエラー出るので）
        playerSeeRay = new Ray(VRCameraTrs.position, VRCameraTrs.forward);

        //レイヤーマスク作成（ビット演算で指定は複雑なので名前で指定）
        seeRayBlockLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock"));
        seeRaySentakushiLayerMask =
            (1 << LayerMask.NameToLayer("seeRaySentakushi"));
        AN_GrapLayerMask =
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("GrapSupportCollider")) +
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));
        AN_GrapSupportLayerMask = //GrapSuppotを抜いて、サポートサーチ時にサポートを掴まないように
            (1 << LayerMask.NameToLayer("seeRayBlock")) +
            (1 << LayerMask.NameToLayer("SeeGirlIgnoreCollider"));

        #endregion

        #region Final IK

        //目と頭のLookAtWeight初期値（TimeLineでの命令での話でここでWeightを直接いじってるわけではない）
        LAIKSEyesDefWeight = 0.8f;
        LAIKSHeadDefWeight = 0.82f;

        #region 略群
        //FBBIK
        IKBodyEf = FBBIK.solver.bodyEffector;
        IKLHandEf = FBBIK.solver.leftHandEffector;
        IKLShoulderEf = FBBIK.solver.leftShoulderEffector;
        IKRHandEf = FBBIK.solver.rightHandEffector;
        IKRShoulderEf = FBBIK.solver.rightShoulderEffector;
        IKLFootEf = FBBIK.solver.leftFootEffector;
        IKLThighEf = FBBIK.solver.leftThighEffector;
        IKRFootEf = FBBIK.solver.rightFootEffector;
        IKRThighEf = FBBIK.solver.rightThighEffector;

        //LAIK
        LAIKHeadS = LAIKHead.solver;
        LAIKEyeS = LAIKEye.solver;
        LAIKBodyS = LAIKBody.solver;
        #endregion

        //ターゲット群をFinalIKに当てはめ
        LAIKHead.solver.target = IKLookAtHeadTargetTrs;
        LAIKEye.solver.target = IKLookAtEyeTargetTrs;
        LAIKBody.solver.target = IKLookAtBodyTargetTrs;
        FBBIK.solver.bodyEffector.target = IKBodyTargetTrs;
        FBBIK.solver.leftHandEffector.target = IKLHandTargetTrs;
        FBBIK.solver.leftShoulderEffector.target = IKLShoulderTargetTrs;
        FBBIK.solver.rightHandEffector.target = IKRHandTargetTrs;
        FBBIK.solver.rightShoulderEffector.target = IKRShoulderTargetTrs;
        FBBIK.solver.leftFootEffector.target = IKLFootTargetTrs;
        FBBIK.solver.leftThighEffector.target = IKLThighTargetTrs;
        FBBIK.solver.rightFootEffector.target = IKRFootTargetTrs;
        FBBIK.solver.rightThighEffector.target = IKRThighTargetTrs;
        CCDIKRHand.solver.target = CCDIKRHandTargetTrs;
        CCDIKLHand.solver.target = CCDIKLHandTargetTrs;

        //IKさせるBoneのtransform取得はchieriの取得の所に移動
        //BendGoalの取得も
        //CCDIK用ボーンも

        //肩ツイストねじれ、マッピングウェイト（MappingWeight）を0.9999999で解決できるかもしれない
        FBBIK.solver.GetLimbMapping(FullBodyBipedChain.LeftArm).weight = 0.9999999f;
        FBBIK.solver.GetLimbMapping(FullBodyBipedChain.RightArm).weight = 0.9999999f;


        //ArmBendGoal1
        FBBIK.solver.rightArmChain.bendConstraint.weight =
        FBBIK.solver.leftArmChain.bendConstraint.weight = 1;

        //LegBendGoalやその他0
        FBBIK.solver.rightLegChain.bendConstraint.weight =
        FBBIK.solver.rightLegChain.pull =
        FBBIK.solver.rightLegChain.push =
        FBBIK.solver.rightLegChain.reach =
        FBBIK.solver.leftLegChain.bendConstraint.weight =
        FBBIK.solver.leftLegChain.pull =
        FBBIK.solver.leftLegChain.push =
        FBBIK.solver.leftLegChain.reach = 0;

        //FinalIKのLookAtBoneの指定は、FinalIK独自の型でtransformを割り当てる必要がある
        //Head Eye Bodyそれぞれ別々にも動かせるように、また、同時にも動かせるように3コンポーネント全部に割り当て
        LAIKHead.solver.head = new IKSolverLookAt.LookAtBone(Bip001HeadTrs);
        LAIKHead.solver.spine = new IKSolverLookAt.LookAtBone[2];
        LAIKHead.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip001Spine);
        LAIKHead.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip001Spine1);
        LAIKHead.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        LAIKHead.solver.eyes[0] = new IKSolverLookAt.LookAtBone(joint_L_eye00Trs);
        LAIKHead.solver.eyes[1] = new IKSolverLookAt.LookAtBone(joint_R_eye00Trs);

        LAIKEye.solver.head = new IKSolverLookAt.LookAtBone(Bip001HeadTrs);
        LAIKEye.solver.spine = new IKSolverLookAt.LookAtBone[2];
        LAIKEye.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip001Spine);
        LAIKEye.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip001Spine1);
        LAIKEye.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        LAIKEye.solver.eyes[0] = new IKSolverLookAt.LookAtBone(joint_L_eye00Trs);
        LAIKEye.solver.eyes[1] = new IKSolverLookAt.LookAtBone(joint_R_eye00Trs);

        LAIKBody.solver.head = new IKSolverLookAt.LookAtBone(Bip001HeadTrs);
        LAIKBody.solver.spine = new IKSolverLookAt.LookAtBone[2];
        LAIKBody.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip001Spine);
        LAIKBody.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip001Spine1);
        LAIKBody.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        LAIKBody.solver.eyes[0] = new IKSolverLookAt.LookAtBone(joint_L_eye00Trs);
        LAIKBody.solver.eyes[1] = new IKSolverLookAt.LookAtBone(joint_R_eye00Trs);

        ////CCDIKは早すぎるとエラー出るので0.1秒遅延取得の方に同じものがある。
        //CCDIKRHand.solver.AddBone(Bip001_R_UpperArmTrs);
        //CCDIKRHand.solver.AddBone(Bip001_R_ForearmTrs);
        //CCDIKRHand.solver.AddBone(Bip001_R_HandTrs);
        //CCDIKLHand.solver.AddBone(Bip001_L_UpperArmTrs);
        //CCDIKLHand.solver.AddBone(Bip001_L_ForearmTrs);
        //CCDIKLHand.solver.AddBone(Bip001_L_HandTrs);
        ////略群
        //CCDIKRUpperArmSBone = CCDIKRHand.solver.bones[0];
        //CCDIKRForearmSBone = CCDIKRHand.solver.bones[1];
        //CCDIKRHandSBone = CCDIKRHand.solver.bones[2];
        //CCDIKLUpperArmSBone = CCDIKLHand.solver.bones[0];
        //CCDIKLForearmSBone = CCDIKLHand.solver.bones[1];
        //CCDIKLHandSBone = CCDIKLHand.solver.bones[2];


        //EyeClamp数値初期化(前から0.95だった)
        LAIKHead.solver.clampWeightEyes =
        LAIKEye.solver.clampWeightEyes =
        LAIKBody.solver.clampWeightEyes =
        DB.defLAIKEyeClamp = 0.95f;

        //HeadClamp数値初期化（0.85にしていたが、変更すること多いので下げた）
        LAIKHead.solver.clampWeightHead =
        LAIKEye.solver.clampWeightHead =
        LAIKBody.solver.clampWeightHead =
        DB.defLAIKHeadClamp = 0.65f;


        LAIKHead.solver.headWeight = 0f;

        LAIKEye.solver.headWeight = 0f;
        LAIKEye.solver.eyesWeight = 0f;
        LAIKEye.solver.bodyWeight = 0f;

        LAIKBody.solver.bodyWeight = 0f;


        //IKで手足が引っ張られた時に、頭の回転を体の回転に合わせない（デフォの0だとLookAtしてても頭が体の向きになってしまう）
        FBBIK.solver.headMapping.maintainRotationWeight = 1;


        #endregion

        #region PlayerFinal IK

        //目と頭のLookAtWeight初期値（TimeLineでの命令での話でここでWeightを直接いじってるわけではない）
        PlayerLAIKSEyesDefWeight = 0.8f;
        PlayerLAIKSHeadDefWeight = 0.82f;

        #region 略群
        //FBBIK
        PlayerIKBodyEf = PlayerFBBIK.solver.bodyEffector;
        PlayerIKLHandEf = PlayerFBBIK.solver.leftHandEffector;
        PlayerIKLShoulderEf = PlayerFBBIK.solver.leftShoulderEffector;
        PlayerIKRHandEf = PlayerFBBIK.solver.rightHandEffector;
        PlayerIKRShoulderEf = PlayerFBBIK.solver.rightShoulderEffector;
        PlayerIKLFootEf = PlayerFBBIK.solver.leftFootEffector;
        PlayerIKLThighEf = PlayerFBBIK.solver.leftThighEffector;
        PlayerIKRFootEf = PlayerFBBIK.solver.rightFootEffector;
        PlayerIKRThighEf = PlayerFBBIK.solver.rightThighEffector;

        //LAIK
        PlayerLAIKHeadS = PlayerLAIKHead.solver;
        PlayerLAIKEyeS = PlayerLAIKEye.solver;
        PlayerLAIKBodyS = PlayerLAIKBody.solver;
        #endregion

        //ターゲット群をFinalIKに当てはめ
        PlayerLAIKHead.solver.target = PlayerIKLookAtHeadTargetTrs;
        PlayerLAIKEye.solver.target = PlayerIKLookAtEyeTargetTrs;
        PlayerLAIKBody.solver.target = PlayerIKLookAtBodyTargetTrs;
        PlayerFBBIK.solver.bodyEffector.target = PlayerIKBodyTargetTrs;
        PlayerFBBIK.solver.leftHandEffector.target = PlayerIKLHandTargetTrs;
        PlayerFBBIK.solver.leftShoulderEffector.target = PlayerIKLShoulderTargetTrs;
        PlayerFBBIK.solver.rightHandEffector.target = PlayerIKRHandTargetTrs;
        PlayerFBBIK.solver.rightShoulderEffector.target = PlayerIKRShoulderTargetTrs;
        PlayerFBBIK.solver.leftFootEffector.target = PlayerIKLFootTargetTrs;
        PlayerFBBIK.solver.leftThighEffector.target = PlayerIKLThighTargetTrs;
        PlayerFBBIK.solver.rightFootEffector.target = PlayerIKRFootTargetTrs;
        PlayerFBBIK.solver.rightThighEffector.target = PlayerIKRThighTargetTrs;
        PlayerCCDIKRHand.solver.target = PlayerCCDIKRHandTargetTrs;
        PlayerCCDIKLHand.solver.target = PlayerCCDIKLHandTargetTrs;

        //IKさせるBoneのtransform取得はPlayerの取得の所に移動
        //BendGoalの取得も
        //CCDIK用ボーンも


        ////BendGoal最初0
        PlayerFBBIK.solver.rightArmChain.bendConstraint.weight = 0;
        PlayerFBBIK.solver.leftArmChain.bendConstraint.weight = 0;
        PlayerFBBIK.solver.rightLegChain.bendConstraint.weight = 0;
        PlayerFBBIK.solver.leftLegChain.bendConstraint.weight = 0;


        //FinalIKのLookAtBoneの指定は、FinalIK独自の型でtransformを割り当てる必要がある
        //Head Eye Bodyそれぞれ別々にも動かせるように、また、同時にも動かせるように3コンポーネント全部に割り当て
        PlayerLAIKHead.solver.head = new IKSolverLookAt.LookAtBone(Bip002HeadTrs);
        PlayerLAIKHead.solver.spine = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKHead.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip002Spine);
        PlayerLAIKHead.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip002Spine1);
        PlayerLAIKHead.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKHead.solver.eyes[0] = new IKSolverLookAt.LookAtBone(tempREyeTrs);
        PlayerLAIKHead.solver.eyes[1] = new IKSolverLookAt.LookAtBone(tempLEyeTrs);

        PlayerLAIKEye.solver.head = new IKSolverLookAt.LookAtBone(Bip002HeadTrs);
        PlayerLAIKEye.solver.spine = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKEye.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip002Spine);
        PlayerLAIKEye.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip002Spine1);
        PlayerLAIKEye.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKEye.solver.eyes[0] = new IKSolverLookAt.LookAtBone(tempLEyeTrs);
        PlayerLAIKEye.solver.eyes[1] = new IKSolverLookAt.LookAtBone(tempREyeTrs);

        PlayerLAIKBody.solver.head = new IKSolverLookAt.LookAtBone(Bip002HeadTrs);
        PlayerLAIKBody.solver.spine = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKBody.solver.spine[0] = new IKSolverLookAt.LookAtBone(Bip002Spine);
        PlayerLAIKBody.solver.spine[1] = new IKSolverLookAt.LookAtBone(Bip002Spine1);
        PlayerLAIKBody.solver.eyes = new IKSolverLookAt.LookAtBone[2];
        PlayerLAIKBody.solver.eyes[0] = new IKSolverLookAt.LookAtBone(tempLEyeTrs);
        PlayerLAIKBody.solver.eyes[1] = new IKSolverLookAt.LookAtBone(tempREyeTrs);

        ////CCDIKは早すぎるとエラー出るので0.1秒遅延取得の方に

        //数値初期化
        PlayerLAIKHead.solver.clampWeightEyes = 0.95f;
        PlayerLAIKEye.solver.clampWeightEyes = 0.95f;
        PlayerLAIKBody.solver.clampWeightEyes = 0.95f;

        PlayerLAIKHead.solver.headWeight = 0f;

        PlayerLAIKEye.solver.headWeight = 0f;
        PlayerLAIKEye.solver.eyesWeight = 0f;
        PlayerLAIKEye.solver.bodyWeight = 0f;

        PlayerLAIKBody.solver.bodyWeight = 0f;


        //IKで手足が引っ張られた時に、頭の回転を体の回転に合わせない（デフォの0だとLookAtしてても頭が体の向きになってしまう）
        PlayerFBBIK.solver.headMapping.maintainRotationWeight = 1;


        #endregion

        #region TimeLine■■■イベント群■■■■■■

        //タイムスケール初期化
        timeScale = 1;
        //物理の方も FixedTimeStep
        Time.fixedDeltaTime = 0.02f;

        EvsLoad();

        //ゲーム開始時デバッグ移動でイベント開始
        yield return null;
        EventMove(DB.nowEventNum, true);

        #endregion

        //ポーズ時スカートのスプリングもポーズする用にスプリングマネージャー取得
        skirtSpringManager = sk_rootTrs.GetComponent<UTJ.SpringManager>();

        //プレイヤーモーション
        StartCoroutine(PlayerMotionSystemIEnum());

        //VRBlock暗転システム■EvsLoad後前提
        VRBlockSystem();

        ////■かくれおに移動システム事前ロード（初期化が重いので事前ロード）（終了は一部解放とアクティブオフの一時終了）
        //KO_KakurePointSerchCorCoroutine = StartCoroutine(KakureOniSystemLoad());
        ////一時終了
        //isKOSystem = false;

        //UTL拡張書き出しコードでの移動ポイントフラグ発動命令をOFF
        isMovePointFlagReserve = false;

        enabled = true;//コンポーネントONにすることでUpdate開始（先頭でOFFにしてる）

        #region 0.1秒 遅延（同時に初期化できない物や、AddComponent後の数値弄り、オブジェクトオフなど　余裕を持った初期化）
        yield return new WaitForSeconds(0.1f);

        #region FinalIK
        //CCDIK
        CCDIKRHand.solver.AddBone(Bip001_R_UpperArmTrs);
        CCDIKRHand.solver.AddBone(Bip001_R_ForearmTrs);
        CCDIKRHand.solver.AddBone(Bip001_R_HandTrs);
        CCDIKLHand.solver.AddBone(Bip001_L_UpperArmTrs);
        CCDIKLHand.solver.AddBone(Bip001_L_ForearmTrs);
        CCDIKLHand.solver.AddBone(Bip001_L_HandTrs);
        //略群
        CCDIKRUpperArmSBone = CCDIKRHand.solver.bones[0];
        CCDIKRForearmSBone = CCDIKRHand.solver.bones[1];
        CCDIKRHandSBone = CCDIKRHand.solver.bones[2];
        CCDIKLUpperArmSBone = CCDIKLHand.solver.bones[0];
        CCDIKLForearmSBone = CCDIKLHand.solver.bones[1];
        CCDIKLHandSBone = CCDIKLHand.solver.bones[2];
        //開始ウェイトゼロ
        CCDIKRUpperArmSBone.weight =
        CCDIKRForearmSBone.weight =
        CCDIKRHandSBone.weight =
        CCDIKLUpperArmSBone.weight =
        CCDIKLForearmSBone.weight =
        CCDIKLHandSBone.weight = 0;

        #endregion FinalIK
        #region PlayerFinalIK
        //CCDIK (PlayerなのにBip001だった　なにか意味があったのかどうか)
        //PlayerCCDIKRHand.solver.AddBone(Bip001_R_UpperArmTrs);
        //PlayerCCDIKRHand.solver.AddBone(Bip001_R_ForearmTrs);
        //PlayerCCDIKRHand.solver.AddBone(Bip001_R_HandTrs);
        //PlayerCCDIKLHand.solver.AddBone(Bip001_L_UpperArmTrs);
        //PlayerCCDIKLHand.solver.AddBone(Bip001_L_ForearmTrs);
        //PlayerCCDIKLHand.solver.AddBone(Bip001_L_HandTrs);
        PlayerCCDIKRHand.solver.AddBone(Bip002_R_UpperArmTrs);
        PlayerCCDIKRHand.solver.AddBone(Bip002_R_ForearmTrs);
        PlayerCCDIKRHand.solver.AddBone(Bip002_R_HandTrs);
        PlayerCCDIKLHand.solver.AddBone(Bip002_L_UpperArmTrs);
        PlayerCCDIKLHand.solver.AddBone(Bip002_L_ForearmTrs);
        PlayerCCDIKLHand.solver.AddBone(Bip002_L_HandTrs);

        //略群
        PlayerCCDIKRUpperArmSBone = CCDIKRHand.solver.bones[0];
        PlayerCCDIKRForearmSBone = CCDIKRHand.solver.bones[1];
        PlayerCCDIKRHandSBone = CCDIKRHand.solver.bones[2];
        PlayerCCDIKLUpperArmSBone = CCDIKLHand.solver.bones[0];
        PlayerCCDIKLForearmSBone = CCDIKLHand.solver.bones[1];
        PlayerCCDIKLHandSBone = CCDIKLHand.solver.bones[2];
        //開始ウェイトゼロ
        PlayerCCDIKRUpperArmSBone.weight =
        PlayerCCDIKRForearmSBone.weight =
        PlayerCCDIKRHandSBone.weight =
        PlayerCCDIKLUpperArmSBone.weight =
        PlayerCCDIKLForearmSBone.weight =
        PlayerCCDIKLHandSBone.weight = 0;

        #endregion PlayerFinalIK

        #endregion




        yield return null;
    }

    #region デバッグ起動コマンド用
    float debugCoomandWaitTime;
    bool isComma, isPeriod;
    #endregion
    void Update()
    {

        #region デバッグ デバッグシステム ONOFF
        //if (Input.GetKeyDown(KeyCode.U) && DB.isDebugMode == false)
        //{ StartCoroutine(DebugModeSystem()); }
        //else if (Input.GetKeyDown(KeyCode.U) && DB.isDebugMode == true)
        //{ DB.isDebugMode = false; }

        if (Input.GetKeyDown(KeyCode.Comma) && (Input.GetKey(KeyCode.RightShift) || Input.GetKey(KeyCode.LeftShift)))
        {
            isComma = true; isPeriod = false;
            debugCoomandWaitTime = 0;
        }
        else if (isComma)
        {
            debugCoomandWaitTime += 1 * Time.deltaTime;
            Debug.Log(debugCoomandWaitTime);
            if (debugCoomandWaitTime < 3)
            {
                if (Input.GetKeyDown(KeyCode.Period) && isPeriod == false && (Input.GetKey(KeyCode.RightShift) || Input.GetKey(KeyCode.LeftShift)))
                {
                    isPeriod = true;
                }
                else if (isPeriod)
                {
                    if (Input.GetKeyDown(KeyCode.Slash) && DB.isDebugMode == false && (Input.GetKey(KeyCode.RightShift) || Input.GetKey(KeyCode.LeftShift)))
                    {
                        //デバッグ起動
                        StartCoroutine(DebugModeSystem());
                        isComma = isPeriod = false;
                        debugCoomandWaitTime = 0;
                    }
                    else if (Input.GetKeyDown(KeyCode.Slash) && DB.isDebugMode == true)
                    {
                        DB.isDebugMode = false;
                        isComma = isPeriod = false;
                        debugCoomandWaitTime = 0;
                    }
                }
                else if (Input.anyKeyDown)
                {
                    isComma = isPeriod = false;
                    debugCoomandWaitTime = 0;
                }
            }
            else
            {
                isComma = isPeriod = false;
                debugCoomandWaitTime = 0;
            }
        }

        #endregion
        #region //デバッグ　LキーでLanguageデバッグキャンバス表示
        //if (DB.isDebugMode && Input.GetKeyDown(KeyCode.L))
        //{
        //    if (DB.isLanguageDebug) { DB.isLanguageDebug = false; }
        //    else { DB.isLanguageDebug = true; }
        //}
        #endregion
        #region デバッグ　UキーでちえりのIKTarget位置を現在のPosに
        if (DB.isDebugMode && Input.GetKeyDown(KeyCode.U))
        {
            GirlPosToIKTargetPosRot();
            Debug.Log("IKTargetを現在Bip位置に");
        }
        #endregion

        #region Iキーで情報テキスト出力（コントローラーやVR）
        if (Input.GetKeyDown(KeyCode.I) && DB.isDebugMode)
        {
            #region 情報出力処理
            string tmpStr = "スペック\n";
            tmpStr += string.Format("OS: {0}", SystemInfo.operatingSystem);
            tmpStr += "\n";
            tmpStr += string.Format("CPU: {0} / {1}cores", SystemInfo.processorType, SystemInfo.processorCount);
            tmpStr += "\n";
            tmpStr += string.Format("GPU: {0} / {1}MB API: {2}", SystemInfo.graphicsDeviceName, SystemInfo.graphicsMemorySize, SystemInfo.graphicsDeviceType);
            tmpStr += "\n";

            const uint mega = 1024 * 1024;
            tmpStr += string.Format("Memory: {0:####.0} / {1}.0MB GCCount: {2}", Profiler.usedHeapSizeLong / (float)mega, SystemInfo.systemMemorySize, System.GC.CollectionCount(0));
            tmpStr += "\n";

            //tmpStr += string.Format("Performance: {0:#0.#}fps", m_fps);
            //tmpStr += "\n";

            Resolution reso = Screen.currentResolution;
            tmpStr += string.Format("Resolution: {0} x {1} RefreshRate: {2}Hz", reso.width, reso.height, reso.refreshRate);
            tmpStr += "\n";

            //コントローラー
            tmpStr += "\nコントローラー\n";
            for (int i = 0; i < Input.GetJoystickNames().Length; i++)
            {
                tmpStr += Input.GetJoystickNames()[i] + "\n";
            }

            //VR情報　一部
            tmpStr += "\n\nVR接続 " + XRSettings.enabled;
            tmpStr += "\nXRDevice.model " + XRDevice.model;
            tmpStr += "\nXRSettings.loadedDeviceName " + XRSettings.loadedDeviceName;
            tmpStr += "\nXRSettings.eyeTextureDesc " + XRSettings.eyeTextureDesc;
            tmpStr += "\nXRSettings.eyeTextureHeight " + XRSettings.eyeTextureHeight;
            tmpStr += "\nXRSettings.eyeTextureResolutionScale " + XRSettings.eyeTextureResolutionScale;
            tmpStr += "\nXRSettings.eyeTextureWidth " + XRSettings.eyeTextureWidth;
            tmpStr += "\nXRSettings.gameViewRenderMode " + XRSettings.gameViewRenderMode;
            tmpStr += "\nXRSettings.isDeviceActive " + XRSettings.isDeviceActive;
            tmpStr += "\nXRSettings.showDeviceView " + XRSettings.showDeviceView;
            for (int i = 0; i < XRSettings.supportedDevices.Length; i++)
            { tmpStr += "\nXRSettings.supportedDevices " + "i " + XRSettings.supportedDevices[i]; }


            #region ファイル名用に時間取得
            var tmpTimeStr = System.DateTime.Now.Year.ToString("D4");
            tmpTimeStr += System.DateTime.Now.Month.ToString("D2");
            tmpTimeStr += System.DateTime.Now.Day.ToString("D2");
            tmpTimeStr += System.DateTime.Now.Hour.ToString("D2");
            tmpTimeStr += System.DateTime.Now.Minute.ToString("D2");
            tmpTimeStr += System.DateTime.Now.Second.ToString("D2");
            #endregion

            //ファイルに書き出し
            using (StreamWriter
                writer = new StreamWriter(Application.streamingAssetsPath + "/DebugInfo" + tmpTimeStr + ".json"
                , false
                , Encoding.GetEncoding("utf-8")))
            {
                writer.WriteLine(tmpStr);
            }


            Debug.Log(tmpStr);
            SubTitleVis(true, "デバッグ用情報出力しました");

            #endregion
        }


        #endregion

        #region Vキーでスクリーンショット DBでONなら
        if (DB.isScreenShotVkey && Input.GetKeyDown(KeyCode.V))
        {
            SEPlay("camera-shutter1");
            ScreenCapture.CaptureScreenshot(Application.streamingAssetsPath + "/ScreenShot/"
                + flowChartKomaDataObjList[DB.nowEventNum].name
                + Time.realtimeSinceStartup
                + ".png"
                );
        }
        #endregion

        #region Mキーで身長表示（処理はInfoVisSystemIEnum()コルーチン）
        if (DB.isUserInfoVisMakotoHeightUnlock || DB.isDebugMode)
        {
            if (Input.GetKeyDown(KeyCode.M))
            {
                if (isInfoMakotoHeightVis) { isInfoMakotoHeightVis = false; }
                else { isInfoMakotoHeightVis = true; }
            }
        }
        #endregion

        ////手動でSpringManager更新メソッド
        //skirtSpringManager.UpdateDynamics();


        #region FreeCameraMODEへの移行テスト
        //メニューあいてたら機能しない
        if (Input.GetKeyDown(KeyCode.F) && isMenuSystem == false && isFreeCameraSetumeiWait == false)
        {
            if (isFreeCameraModeSystem) { isFreeCameraModeSystem = false; }
            else
            { StartCoroutine(FreeCameraModeSystemIEnum()); }
        }

        #endregion

        #region メニューON・OFFとポーズ (メニューONと同時でなければユーザーポーズにならないようにして、バグ防ぎ)
        #region まず ユーザーポーズ中なら大体何押してもユーザーポーズきる
        if (isUserGamePause)
        {
            if (
            #region //ankeyDownと例外系
                //(
                //Input.anyKeyDown
                //&& Input.GetKeyDown(KeyCode.C) == false//カメラリセット例外
                //&& Input.GetKeyDown(KeyCode.T) == false//カメラ切り替え例外
                //&& Input.GetKeyDown(KeyCode.Q) == false//カメラ左例外
                //&& Input.GetKeyDown(KeyCode.E) == false//カメラ右例外
                //&& Input.GetKeyDown(KeyCode.V) == false//スクリーンショット例外
                //&& Input.GetKeyDown(KeyCode.Print) == false//スクリーンショット例外
                //&& Input.GetKeyDown(KeyCode.SysReq) == false//スクリーンショット例外
                //&& Input.GetKeyDown(KeyCode.LeftAlt) == false//スクリーンショット例外
                //&& Input.GetKeyDown(KeyCode.RightAlt) == false//スクリーンショット例外
                //&& Input.GetKeyDown(KeyCode.Tab) == false//ウィンドウ変更例外
                //&& Input.GetKeyDown(KeyCode.Escape) == false//ウィンドウ変更例外
                //&& Input.GetKeyDown(KeyCode.LeftShift) == false//ウィンドウ変更例外
                //&& Input.GetKeyDown(KeyCode.RightShift) == false//ウィンドウ変更例外
                //)
            #endregion
                //|| Input.GetAxis("Mouse X") != 0
                //|| Input.GetAxis("Mouse Y") != 0
                isKetteiDown
                //|| isCameraResetDown
                || isBackDown
                //|| Input.GetButtonDown(DB.inputDict["カメラ切り替え"])
                || Input.GetButtonDown(DB.inputDict["ノベルログ"])
                //|| isMenuPauseDown
                //|| Input.GetButtonDown(DB.inputDict["セレクト"])
                || Input.GetButtonDown(DB.inputDict["右手"])
                || Input.GetButtonDown(DB.inputDict["左手"])
                || Input.GetButtonDown(DB.inputDict["移動ポイント前進デジタル"])
                || Input.GetButtonDown(DB.inputDict["移動ポイント後退デジタル"])

                //|| Input.GetButtonDown(DB.inputDict["移動ポイント前進後退アナログ"])
                //|| Input.GetAxisRaw(DB.inputDict["選択左右"]) != 0
                //|| sentakuAxisY != 0
                //|| cameraStickAxisX != 0
                //|| cameraStickAxisY != 0
                //|| Input.GetButtonDown(DB.inputDict["移動・手・カーソルスティック移動X"])
                //|| Input.GetButtonDown(DB.inputDict["移動・手・カーソルスティック移動Y"])
                )
            {
                isUserGamePause = false;
                MenuFolder.SetActive(true);
            }
        }
        #endregion

        if (isMenuPauseDown
            || Input.GetKeyDown(KeyCode.Return)
            || (DB.isDebugMode == false && Input.GetKeyDown(KeyCode.R))//Rはユーザーポーズ
            || (DB.isDebugMode == false && Input.GetButtonDown(DB.inputDict["セレクト"])))//セレクトもユーザーポーズ
        {
            if (isMenuSystem == false
                && isMenuLock == false//ロックは開くことだけできない（閉じれる）
                || (isMenuSystem == false && DB.isDebugMode))//デバッグなら開ける
            {
                //メニューシステム起動
                StartCoroutine(MenuSystemIEnum());

                #region ユーザーポーズ (同時にメニュー表示消すだけ)
                if (isUserGamePause == false)
                {
                    if ((DB.isDebugMode == false && Input.GetKeyDown(KeyCode.R)) || isKettei || (DB.isDebugMode == false && Input.GetButtonDown(DB.inputDict["セレクト"])))
                    {
                        isUserGamePause = true;
                        MenuFolder.SetActive(false);
                    }
                }
                #endregion

            }
            else if (isMenuSystem
                && DB.isUserInitialSetting //初期設定は閉じれない
                || (isMenuSystem && DB.isDebugMode))//デバッグなら閉じれる
            {
                isMouseCursorSystem =
                isMenuSystem = false;

                //ユーザーポーズも一応切る
                isUserGamePause = false;
                MenuFolder.SetActive(true);
            }
        }

        #endregion

        //スティックでのカメラアングル操作(VR時に動かすため今はアンカーを操作)
        UserControlCameraAngle();

        //マウス占有 + NoVR時カメラ操作
        MouseLockControl();

        #region//XBOXコントローラー設定確認 群
        /*
        if (Input.GetKey(KeyCode.Joystick1Button0))
        {
            Debug.Log("Button A Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button1))
        {
            Debug.Log("Button B Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button2))
        {
            Debug.Log("Button X Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button3))
        {
            Debug.Log("Button Y Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button4))
        {
            Debug.Log("Button LB Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button5))
        {
            Debug.Log("Button RB Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button6))
        {
            Debug.Log("Button Back Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button7))
        {
            Debug.Log("Button START Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button8))
        {
            Debug.Log("L Stick Push");
        }

        if (Input.GetKey(KeyCode.Joystick1Button9))
        {
            Debug.Log("R Stick Push");
        }

        float XBOXTrigerInput = Input.GetAxis("XBOXTrigger");
        if (XBOXTrigerInput > 0.5f)
        {
            Debug.Log("L Triger");
        }
        else if (XBOXTrigerInput < -0.5f)
        {
            Debug.Log("R Triger");
        }

        float XBOXHorizontalKeyInput = Input.GetAxis("XBOX十字左右");
        if (XBOXHorizontalKeyInput < -0.5f)
        {
            Debug.Log("Left Key");
        }
        else if (XBOXHorizontalKeyInput > 0.5f)
        {
            Debug.Log("Right Key");
        }

        float XBOXVerticalKeyInput = Input.GetAxis("XBOX十字上下");
        if (XBOXVerticalKeyInput > 0.5f)
        {
            Debug.Log("Up Key");
        }
        else if (XBOXVerticalKeyInput < -0.5f)
        {
            Debug.Log("Down Key");
        }

        float XBOXLeftHorizontalInput = Input.GetAxis("XBOX左アナログ左右");
        if (XBOXLeftHorizontalInput < -0.5f)
        {
            Debug.Log("Left Analog Left");
        }
        else if (XBOXLeftHorizontalInput > 0.5f)
        {
            Debug.Log("Left Analog Right");
        }

        float XBOXLeftVerticalInput = Input.GetAxis("XBOX左アナログ上下");
        if (XBOXLeftVerticalInput < -0.5f)
        {
            Debug.Log("Left Analog Up");
        }
        else if (XBOXLeftVerticalInput > 0.5f)
        {
            Debug.Log("Left Analog Down");
        }

        float XBOXRightHorizontalInput = Input.GetAxis("XBOX右アナログ左右");
        if (XBOXRightHorizontalInput < -0.5f)
        {
            Debug.Log("Right Analog Left");
        }
        else if (XBOXRightHorizontalInput > 0.5f)
        {
            Debug.Log("Right Analog Right");
        }

        float XBOXRightVerticalInput = Input.GetAxis("XBOX右アナログ上下");
        if (XBOXRightVerticalInput < -0.5f)
        {
            Debug.Log("Right Analog Up");
        }
        else if (XBOXRightVerticalInput > 0.5f)
        {
            Debug.Log("Right Analog Down");
        }
        */
        #endregion


        #region 智恵理が0位置から移動することがあれば0位置へ戻す
        //モーション中なぜか勝手に位置移動することがあるので
        //動かすためにboolでONOFF
        if (DB.isChieriPosLock == true)
        {
            if (GirlTrs.position != new Vector3(0, 0, 0))
            { GirlTrs.position = new Vector3(0, 0, 0); }
            if (GirlTrs.localEulerAngles != new Vector3(0, 0, 0))
            { GirlTrs.localEulerAngles = new Vector3(0, 0, 0); }

        }
        #endregion

        #region 表情・口パク 呼吸速度
        //智恵理ONが前提
        if (GirlTrs.gameObject.activeSelf)
        { Kutipaku(); }

        //呼吸速度が アニメスピードで割った数になってなければ　割った数にする
        if (OriBreathController.durationRate != 1 / girlAnim.speed)
        { OriBreathController.durationRate = 1 / girlAnim.speed; }

        #endregion 表情・口パク

        #region サイズ・ステータス系(元orig_sizechange)
        //身長出し
        nowPlayerSintyouFloat = nowPlayerLocalScale.y * DB.sintyouFloat;

        // メソッドでtemp～に数値を出した後に数値を書き込む命令が必要
        // デバッグで変更させたいのでUpdateに持ってきた（＝関数でtempに書き込んだ次のフレームで実数を書き換えるので1フレーム遅くなる？）
        CameraObjectsTrs.localScale = nowPlayerLocalScale;

        //　ONOFFスイッチで大きさ変更
        if (isSeeShrink == true) { SeeShrink(); }

        //大きさがマイナスにならないように
        if (nowPlayerLocalScale.y < 0)
        { nowPlayerLocalScale = new Vector3(0.00001f, 0.00001f, 0.00001f); }


        #endregion

        #region Ray関係
        //プレイヤーから真正面へのRay
        playerSeeRay = new Ray(VRCameraTrs.position, VRCameraTrs.forward);

        #endregion

        #region FinalIK　不使用時はオフ

        ////■■trueの時ウェイトが0だったらfalse 
        //if (FBBIK.enabled == true &&
        //    IKBodyEf.positionWeight == 0 &&
        //    IKLHandEf.positionWeight == 0 && IKLShoulderEf.positionWeight == 0 &&
        //    IKRHandEf.positionWeight == 0 && IKRShoulderEf.positionWeight == 0 &&
        //    IKLFootEf.positionWeight == 0 && IKLThighEf.positionWeight == 0 &&
        //    IKRFootEf.positionWeight == 0 && IKRThighEf.positionWeight == 0 &&
        //    IKBodyEf.rotationWeight == 0 &&
        //    IKLHandEf.rotationWeight == 0 && IKLShoulderEf.rotationWeight == 0 &&
        //    IKRHandEf.rotationWeight == 0 && IKRShoulderEf.rotationWeight == 0 &&
        //    IKLFootEf.rotationWeight == 0 && IKLThighEf.rotationWeight == 0 &&
        //    IKRFootEf.rotationWeight == 0 && IKRThighEf.rotationWeight == 0)
        //{ FBBIK.enabled = false; }
        ////■■falseで一つでも0じゃなかったらtrue
        //else if (FBBIK.enabled == false &&
        //    IKBodyEf.positionWeight != 0 ||
        //    IKLHandEf.positionWeight != 0 || IKLShoulderEf.positionWeight != 0 ||
        //    IKRHandEf.positionWeight != 0 || IKRShoulderEf.positionWeight != 0 ||
        //    IKLFootEf.positionWeight != 0 || IKLThighEf.positionWeight != 0 ||
        //    IKRFootEf.positionWeight != 0 || IKRThighEf.positionWeight != 0 ||
        //    IKBodyEf.rotationWeight != 0 ||
        //    IKLHandEf.rotationWeight != 0 || IKLShoulderEf.rotationWeight != 0 ||
        //    IKRHandEf.rotationWeight != 0 || IKRShoulderEf.rotationWeight != 0 ||
        //    IKLFootEf.rotationWeight != 0 || IKLThighEf.rotationWeight != 0 ||
        //    IKRFootEf.rotationWeight != 0 || IKRThighEf.rotationWeight != 0)
        //{ FBBIK.enabled = true; }

        //同じくLAIKでも
        if (LAIKHead.enabled == true && LAIKHeadS.headWeight == 0 && LAIKHeadS.eyesWeight == 0 && LAIKHeadS.bodyWeight == 0)
        { LAIKHead.enabled = false; }
        else if (LAIKHead.enabled == false && LAIKHeadS.headWeight != 0 || LAIKHeadS.eyesWeight != 0 || LAIKHeadS.bodyWeight != 0)
        { LAIKHead.enabled = true; }

        if (LAIKEye.enabled == true && LAIKEyeS.headWeight == 0 && LAIKEyeS.eyesWeight == 0 && LAIKEyeS.bodyWeight == 0)
        { LAIKEye.enabled = false; }
        else if (LAIKEye.enabled == false && LAIKEyeS.headWeight != 0 || LAIKEyeS.eyesWeight != 0 || LAIKEyeS.bodyWeight != 0)
        { LAIKEye.enabled = true; }

        if (LAIKBody.enabled == true && LAIKBodyS.headWeight == 0 && LAIKBodyS.eyesWeight == 0 && LAIKBodyS.bodyWeight == 0)
        { LAIKBody.enabled = false; }
        else if (LAIKBody.enabled == false && LAIKBodyS.headWeight != 0 || LAIKBodyS.eyesWeight != 0 || LAIKBodyS.bodyWeight != 0)
        { LAIKBody.enabled = true; }

        //CCDIK(0.1秒後の取得なので、仕方なくif判定)
        if (CCDIKRHandSBone != null)
        {
            if (CCDIKRHand.enabled == true &&
                CCDIKRUpperArmSBone.weight == 0 && CCDIKRForearmSBone.weight == 0 && CCDIKRHandSBone.weight == 0)
            { CCDIKRHand.enabled = false; }
            else if (CCDIKRHand.enabled == false &&
                CCDIKRUpperArmSBone.weight != 0 || CCDIKRForearmSBone.weight != 0 || CCDIKRHandSBone.weight != 0)
            { CCDIKRHand.enabled = true; }
        }

        if (CCDIKLHandSBone != null)
        {
            if (CCDIKLHand.enabled == true &&
                CCDIKLUpperArmSBone.weight == 0 && CCDIKLForearmSBone.weight == 0 && CCDIKLHandSBone.weight == 0)
            { CCDIKLHand.enabled = false; }
            else if (CCDIKLHand.enabled == false &&
                CCDIKLUpperArmSBone.weight != 0 || CCDIKLForearmSBone.weight != 0 || CCDIKLHandSBone.weight != 0)
            { CCDIKLHand.enabled = true; }
        }
        #endregion

        #region PlayerFinalIK　不使用時はオフ

        //■■trueの時ウェイトが0だったらfalse 
        if (PlayerFBBIK.enabled == true &&
            PlayerIKBodyEf.positionWeight == 0 &&
            PlayerIKLHandEf.positionWeight == 0 && PlayerIKLShoulderEf.positionWeight == 0 &&
            PlayerIKRHandEf.positionWeight == 0 && PlayerIKRShoulderEf.positionWeight == 0 &&
            PlayerIKLFootEf.positionWeight == 0 && PlayerIKLThighEf.positionWeight == 0 &&
            PlayerIKRFootEf.positionWeight == 0 && PlayerIKRThighEf.positionWeight == 0 &&
            PlayerIKBodyEf.rotationWeight == 0 &&
            PlayerIKLHandEf.rotationWeight == 0 && PlayerIKLShoulderEf.rotationWeight == 0 &&
            PlayerIKRHandEf.rotationWeight == 0 && PlayerIKRShoulderEf.rotationWeight == 0 &&
            PlayerIKLFootEf.rotationWeight == 0 && PlayerIKLThighEf.rotationWeight == 0 &&
            PlayerIKRFootEf.rotationWeight == 0 && PlayerIKRThighEf.rotationWeight == 0)
        { PlayerFBBIK.enabled = false; }
        //■■falseで一つでも0じゃなかったらtrue
        else if (PlayerFBBIK.enabled == false &&
            PlayerIKBodyEf.positionWeight != 0 ||
            PlayerIKLHandEf.positionWeight != 0 || PlayerIKLShoulderEf.positionWeight != 0 ||
            PlayerIKRHandEf.positionWeight != 0 || PlayerIKRShoulderEf.positionWeight != 0 ||
            PlayerIKLFootEf.positionWeight != 0 || PlayerIKLThighEf.positionWeight != 0 ||
            PlayerIKRFootEf.positionWeight != 0 || PlayerIKRThighEf.positionWeight != 0 ||
            PlayerIKBodyEf.rotationWeight != 0 ||
            PlayerIKLHandEf.rotationWeight != 0 || PlayerIKLShoulderEf.rotationWeight != 0 ||
            PlayerIKRHandEf.rotationWeight != 0 || PlayerIKRShoulderEf.rotationWeight != 0 ||
            PlayerIKLFootEf.rotationWeight != 0 || PlayerIKLThighEf.rotationWeight != 0 ||
            PlayerIKRFootEf.rotationWeight != 0 || PlayerIKRThighEf.rotationWeight != 0)
        { PlayerFBBIK.enabled = true; }

        //同じくPlayerLAIKでも
        if (PlayerLAIKHead.enabled == true && PlayerLAIKHeadS.headWeight == 0 && PlayerLAIKHeadS.eyesWeight == 0 && PlayerLAIKHeadS.bodyWeight == 0)
        { PlayerLAIKHead.enabled = false; }
        else if (PlayerLAIKHead.enabled == false && PlayerLAIKHeadS.headWeight != 0 || PlayerLAIKHeadS.eyesWeight != 0 || PlayerLAIKHeadS.bodyWeight != 0)
        { PlayerLAIKHead.enabled = true; }

        if (PlayerLAIKEye.enabled == true && PlayerLAIKEyeS.headWeight == 0 && PlayerLAIKEyeS.eyesWeight == 0 && PlayerLAIKEyeS.bodyWeight == 0)
        { PlayerLAIKEye.enabled = false; }
        else if (PlayerLAIKEye.enabled == false && PlayerLAIKEyeS.headWeight != 0 || PlayerLAIKEyeS.eyesWeight != 0 || PlayerLAIKEyeS.bodyWeight != 0)
        { PlayerLAIKEye.enabled = true; }

        if (PlayerLAIKBody.enabled == true && PlayerLAIKBodyS.headWeight == 0 && PlayerLAIKBodyS.eyesWeight == 0 && PlayerLAIKBodyS.bodyWeight == 0)
        { PlayerLAIKBody.enabled = false; }
        else if (PlayerLAIKBody.enabled == false && PlayerLAIKBodyS.headWeight != 0 || PlayerLAIKBodyS.eyesWeight != 0 || PlayerLAIKBodyS.bodyWeight != 0)
        { PlayerLAIKBody.enabled = true; }

        //CCDIK(0.1秒後の取得なので、仕方なくif判定)
        if (PlayerCCDIKRHandSBone != null)
        {
            if (PlayerCCDIKRHand.enabled == true &&
                PlayerCCDIKRUpperArmSBone.weight == 0 && PlayerCCDIKRForearmSBone.weight == 0 && PlayerCCDIKRHandSBone.weight == 0)
            { PlayerCCDIKRHand.enabled = false; }
            else if (PlayerCCDIKRHand.enabled == false &&
                PlayerCCDIKRUpperArmSBone.weight != 0 || PlayerCCDIKRForearmSBone.weight != 0 || PlayerCCDIKRHandSBone.weight != 0)
            { PlayerCCDIKRHand.enabled = true; }
        }

        if (PlayerCCDIKLHandSBone != null)
        {
            if (PlayerCCDIKLHand.enabled == true &&
                PlayerCCDIKLUpperArmSBone.weight == 0 && PlayerCCDIKLForearmSBone.weight == 0 && PlayerCCDIKLHandSBone.weight == 0)
            { PlayerCCDIKLHand.enabled = false; }
            else if (PlayerCCDIKLHand.enabled == false &&
                PlayerCCDIKLUpperArmSBone.weight != 0 || PlayerCCDIKLForearmSBone.weight != 0 || PlayerCCDIKLHandSBone.weight != 0)
            { PlayerCCDIKLHand.enabled = true; }
        }
        #endregion

        #region TimeLine

        //スキップ・ストップシステム
        TimeControlSystem();


        //boolがtrueならイベント実行
        if (isEvRun == true)
        {
            evs[DB.nowEventNum].Value();

            //智恵理ONが前提
            if (GirlTrs.gameObject.activeSelf)
            {
                //まばたきスタート //AutoがTrueなら（強制でまばたき止めたい場合は両方falseにする）
                if (isEyeBlink == false && isEyeBlinkAuto)
                { StartCoroutine(EyeBlinkIEnum = EyeBlinkCor()); }
            }
            else
            {
                //まばたき止め
                if (isEyeBlink == true &&
                    EyeBlinkIEnum != null)
                { isEyeBlink = false; }
            }
        }
        #endregion

    }

    #region ■LateUpdateでAction処理するシステム
    bool isLateAction = false;
    List<Action> lateActionList = new List<Action>();
    public void LateAction(Action action)
    {
        //ListにAddしたのを実行して消す。 （以前はただ実行するだけだったが、同時に2つ以上来たら駄目なのでList化）
        lateActionList.Add(action);
        isLateAction = true;
    }


    #region 登りシステムLateUpdateでAction処理するシステム
    public bool isAN_LateAction = false;
    List<Action> AN_LateActionList = new List<Action>();
    void AN_LateAction(Action action)
    {
        AN_LateActionList.Add(action);
        isAN_LateAction = true;
    }
    #endregion
    #endregion
    void LateUpdate()//フレーム最後に処理。アニメ処理後にすべき処理用・モーフ連動操作用に(アニメーション中マスクかけてもなぜかロックされてる)
    {
        #region LateUpdateでActionするシステム用
        if (isLateAction)
        {
            //ListにAddしたのを実行して消す。 （以前はただ実行するだけだったが、同時に2つ以上来たら駄目なのでList化）
            for (int i = 0; i < lateActionList.Count; i++)
            {
                lateActionList[i]();
                lateActionList.Remove(lateActionList[i]);
            }
            //Debug.Log(lateActionList.Count);

            if (lateActionList.Count == 0)
            { isLateAction = false; }

        }
        #endregion
        #region 脚登り用LateUpdateでActionするシステム用
        if (isAN_LateAction)
        {
            //ListにAddしたのを実行して消す。 （以前はただ実行するだけだったが、同時に2つ以上来たら駄目なのでList化）
            for (int i = 0; i < AN_LateActionList.Count; i++)
            {
                AN_LateActionList[i]();
                AN_LateActionList.Remove(AN_LateActionList[i]);
            }

            if (AN_LateActionList.Count == 0)
            { isAN_LateAction = false; }

        }
        #endregion

        #region 表情 girl SkinnedMeshRendererブレンドシェイプ群
        #region kounaiをMouthと同期
        //kounai_A
        if (Kounai_def.GetBlendShapeWeight(0) != Mouth_def.GetBlendShapeWeight(4))
        {
            Kounai_def.SetBlendShapeWeight(0, Mouth_def.GetBlendShapeWeight(4));
        }
        //kounai_I
        if (Kounai_def.GetBlendShapeWeight(1) != Mouth_def.GetBlendShapeWeight(5))
        {
            Kounai_def.SetBlendShapeWeight(1, Mouth_def.GetBlendShapeWeight(5));
        }
        //kounai_U
        if (Kounai_def.GetBlendShapeWeight(2) != Mouth_def.GetBlendShapeWeight(6))
        {
            Kounai_def.SetBlendShapeWeight(2, Mouth_def.GetBlendShapeWeight(6));
        }
        //kounai_E
        if (Kounai_def.GetBlendShapeWeight(3) != Mouth_def.GetBlendShapeWeight(7))
        {
            Kounai_def.SetBlendShapeWeight(3, Mouth_def.GetBlendShapeWeight(7));
        }
        //kounai_O
        if (Kounai_def.GetBlendShapeWeight(4) != Mouth_def.GetBlendShapeWeight(8))
        {
            Kounai_def.SetBlendShapeWeight(4, Mouth_def.GetBlendShapeWeight(8));
        }
        //kounai_WA
        if (Kounai_def.GetBlendShapeWeight(5) != Mouth_def.GetBlendShapeWeight(3))
        {
            Kounai_def.SetBlendShapeWeight(5, Mouth_def.GetBlendShapeWeight(3));
        }
        //kounai_smile
        if (Kounai_def.GetBlendShapeWeight(6) != Mouth_def.GetBlendShapeWeight(0))
        {
            Kounai_def.SetBlendShapeWeight(6, Mouth_def.GetBlendShapeWeight(0));
        }
        //kounai_angry
        if (Kounai_def.GetBlendShapeWeight(7) != Mouth_def.GetBlendShapeWeight(1))
        {
            Kounai_def.SetBlendShapeWeight(7, Mouth_def.GetBlendShapeWeight(1));
        }
        //kounai_yokohiroge
        if (Kounai_def.GetBlendShapeWeight(8) != Mouth_def.GetBlendShapeWeight(2))
        {
            Kounai_def.SetBlendShapeWeight(8, Mouth_def.GetBlendShapeWeight(2));
        }
        #endregion

        #region //（ハイライト消しモーフ撤去）smile・sleepとEye_high同期（目閉じ時のハイライト消し）
        ////笑顔と目ハイライト数値同期
        //if (Eye_high_def.GetBlendShapeWeight(0) != EYE_def.GetBlendShapeWeight(0))
        //{ Eye_high_def.SetBlendShapeWeight(0, EYE_def.GetBlendShapeWeight(0)); }
        #endregion

        #region Tere_SmileとEYE_def_Smile同期（Tereが目の下にくっきりなくなるので）
        if (Tere.GetBlendShapeWeight(0) != EYE_def.GetBlendShapeWeight(0))
        { Tere.SetBlendShapeWeight(0, EYE_def.GetBlendShapeWeight(0)); }
        //Tere_SleepとEYE_def_Sleepも同期
        if (Tere.GetBlendShapeWeight(1) != EYE_def.GetBlendShapeWeight(4))
        { Tere.SetBlendShapeWeight(1, EYE_def.GetBlendShapeWeight(4)); }
        #endregion


        //まばたきなど、目を現状値以上開かないようにする


        //汗 コルーチンで動いた値を代入
        if (aseLateUpdateBool)
        { Ase.SetBlendShapeWeight(0, aseWeightFloat); }

        #endregion
    }

    #region ■FixedUpdateでAction処理するシステム
    public bool isFixedAction = false;
    List<Action> fixedActionList = new List<Action>();
    void FixedAction(Action action)
    {
        //fixedAction = action;

        //ListにAddしたのを実行して消す。 （以前はただ実行するだけだったが、同時に2つ以上来たら駄目なのでList化）
        fixedActionList.Add(action);
        isFixedAction = true;
    }
    #endregion

    void FixedUpdate()//Updateとは別の周期（時間で一定）で呼ばれる。コリジョン・物理演算用Update
    {
        #region FixedUpdateでActionするシステム用
        if (isFixedAction)
        {
            //fixedAction();

            //ListにAddしたのを実行して消す。 （以前はただ実行するだけだったが、同時に2つ以上来たら駄目なのでList化）
            for (int i = 0; i < fixedActionList.Count; i++)
            {
                fixedActionList[i]();
                fixedActionList.Remove(fixedActionList[i]);
            }
            //Debug.Log(fixedActionList.Count);

            if (fixedActionList.Count == 0)
            { isFixedAction = false; }

        }
        #endregion

        #region FolloeDOMoveのTrsPosをFixedで読み取る

        //Dictにデータがある場合のみ
        if (FollowDOMoveFixedPosDict.Count != 0)
        {
            for (int i = 0; i < FollowDOMoveFixedPosDict.Count; i++)
            {
                //Value（Vector3）にKey（Transform）のPosを
                FollowDOMoveFixedPosDict[FollowDOMoveFixedPosDict[i].Key]
                    = FollowDOMoveFixedPosDict[i].Key.position;
            }
        }

        #endregion

        #region かくれおに智恵理目Ray
        if (KO_isChieriEyeRayColSystem)
        {
            //■プレイヤーが視界に入ってる時
            if (KO_isChieriSightColOnTriggerStay == true)
            {
                //智恵理の頭からプレイヤーへのRay
                // ターゲットオブジェクトとの差分を求め
                Vector3
                    rTemp = KO_ChieriREyeSphereTrs.position - PlayerTargetTrs.position,
                    lTemp = KO_ChieriLEyeSphereTrs.position - PlayerTargetTrs.position;
                // 正規化して方向ベクトルを求める(Rayはターゲットへの場所ではなく"方向"を指定するため)
                Vector3
                    rNormal = rTemp.normalized,
                    lNormal = lTemp.normalized;
                // Rayの作成
                KO_chieriREyeRay = new Ray(KO_ChieriREyeSphereTrs.position, rNormal * -1);
                KO_chieriLEyeRay = new Ray(KO_ChieriLEyeSphereTrs.position, lNormal * -1);

                //■右目
                if (Physics.Raycast(KO_chieriREyeRay, out KO_ChieriREyeRayHit, Mathf.Infinity, KO_chieriEyeRayLayerMask))
                {
                    if (KO_ChieriREyeRayHit.collider.tag == "Player")
                    {
                        Debug.DrawRay(KO_chieriREyeRay.origin, KO_chieriREyeRay.direction * 10000, Color.cyan);

                        if (KO_isEyeRHit == false) { KO_isEyeRHit = true; }
                    }
                    else
                    {
                        Debug.DrawRay(KO_chieriREyeRay.origin, KO_chieriREyeRay.direction * 10000, Color.red);
                        if (KO_isEyeRHit == true) { KO_isEyeRHit = false; }
                    }
                }
                //■左目
                if (Physics.Raycast(KO_chieriLEyeRay, out KO_ChieriLEyeRayHit, Mathf.Infinity, KO_chieriEyeRayLayerMask))
                {
                    //■左目
                    if (KO_ChieriLEyeRayHit.collider.tag == "Player")
                    {
                        Debug.DrawRay(KO_chieriLEyeRay.origin, KO_chieriLEyeRay.direction * 10000, Color.cyan);
                        if (KO_isEyeLHit == false) { KO_isEyeLHit = true; }
                    }
                    else
                    {
                        Debug.DrawRay(KO_chieriLEyeRay.origin, KO_chieriLEyeRay.direction * 10000, Color.red);
                        if (KO_isEyeLHit == true) { KO_isEyeLHit = false; }
                    }
                }
            }
            else //視界に入ってない時
            { if (KO_isEyeLHit || KO_isEyeRHit) { KO_isEyeLHit = KO_isEyeRHit = false; } }

            #region ↑を踏まえてEyeHit判定、DownUpつき
            //■片目でも当たってたらHitをtrue
            //先にDown処理
            if (KO_isEyeHit == true && KO_isEyeHitDown == true)
            { KO_isEyeHitDown = false; }

            //"片目でも"(先に&&があっても、||があったら後の条件は判断されてしまう。ので、二回EyeHitを判断している)
            if (KO_isEyeHit == false && KO_isEyeRHit
                || KO_isEyeHit == false && KO_isEyeLHit)
            { KO_isEyeHit = KO_isEyeHitDown = true; }


            //■両目とも外れたらHitをFalse
            //先にUp処理
            if (KO_isEyeHit == false && KO_isEyeHitUp == true)
            { KO_isEyeHitUp = false; }

            //"両目とも"
            if (KO_isEyeRHit == false && KO_isEyeLHit == false
                && KO_isEyeHit == true)
            { KO_isEyeHit = false; KO_isEyeHitUp = true; }
            #endregion

        }




        #endregion

        #region ■智恵理見てる量計測システム
        if (isSeeGirlSystem)
        {
            #region 智恵理見るシステム
            //■全Float合算値
            seeAllFloat = seeHeadFloat + seeBreastFloat + seeSpineFloat + seePantsFloat + seeRHandFloat + seeLHandFloat + seeRFootFloat + seeLFootFloat;

            //サークルレイ全部にnearSizeAjustとLookAt　//視界ギリギリの大きさでプレイヤーを向き続けるという動作
            for (int i = 0; i < HitCircleObjList.Count; i++)
            {
                nearSizeAjust(HitCircleObjList[i].transform, 0.03f * GameObjectsTrs.localScale.z);
                HitCircleObjList[i].transform.LookAt(PlayerTargetTrs, Vector3.forward);
            }


            // playerSeeRayが頭（サークル）と衝突したら(プレイヤーからは障害物判定取らないので当たったら即メソッド実行)
            if (hitCircleHeadCollider.Raycast(playerSeeRay, out playerSeeHeadRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeHeadRayHit, ref seeHeadFloat, ref hitCircleHeadMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleHeadMeshrenderer.material.color = Color.green;
                seeHeadFloat = 0;
                seeHeadNomFlt = 0;
            }

            // 胸（サークル）
            if (hitCircleBreastCollider.Raycast(playerSeeRay, out playerSeeBreastRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeBreastRayHit, ref seeBreastFloat, ref hitCircleBreastMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleBreastMeshrenderer.material.color = Color.green;
                seeBreastFloat = 0;
            }

            //腰
            if (hitCircleSpineCollider.Raycast(playerSeeRay, out playerSeeSpineRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeSpineRayHit, ref seeSpineFloat, ref hitCircleSpineMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleSpineMeshrenderer.material.color = Color.green;
                seeSpineFloat = 0;
                seeSpineNomFlt = 0;
            }

            //パンツ
            if (hitCirclePantsCollider.Raycast(playerSeeRay, out playerSeePantsRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeePantsRayHit, ref seePantsFloat, ref hitCirclePantsMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCirclePantsMeshrenderer.material.color = Color.green;
                seePantsFloat =
                seePantsNomFlt = 0;
            }

            //右手
            if (hitCircleRHandCollider.Raycast(playerSeeRay, out playerSeeRHandRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeRHandRayHit, ref seeRHandFloat, ref hitCircleRHandMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleRHandMeshrenderer.material.color = Color.green;
                seeRHandFloat = 0;
            }

            //左手
            if (hitCircleLHandCollider.Raycast(playerSeeRay, out playerSeeLHandRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeLHandRayHit, ref seeLHandFloat, ref hitCircleLHandMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleLHandMeshrenderer.material.color = Color.green;
                seeLHandFloat = 0;
            }

            //右足
            if (hitCircleRFootCollider.Raycast(playerSeeRay, out playerSeeRFootRayHit, Mathf.Infinity))
            {
                SeeCircleHit(playerSeeRFootRayHit, ref seeRFootFloat, ref hitCircleRFootMeshrenderer);
            }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleRFootMeshrenderer.material.color = Color.green;
                seeRFootFloat = 0;
                seeRFootNomFlt = 0;
            }

            //左足
            if (hitCircleLFootCollider.Raycast(playerSeeRay, out playerSeeLFootRayHit, Mathf.Infinity))
            { SeeCircleHit(playerSeeLFootRayHit, ref seeLFootFloat, ref hitCircleLFootMeshrenderer); }
            else
            {
                //デバッグ用に外れてたら色緑
                hitCircleLFootMeshrenderer.material.color = Color.green;
                seeLFootFloat = 0;
            }
            #endregion
        }

        #endregion

        #region 登り物理挙動
        if (AN_GravitiDragBool)
        {
            //// 空気抵抗を与える
            //playerRigidbody.AddForce(-asinoboriDrag * playerRigidbody.velocity);
            //// 重力加速度を与える
            //playerRigidbody.AddForce(asinoboriGravity, ForceMode.Acceleration);

            //■体重計算してRigidBodyに
            if (nowPlayerTaizyuuFloat != DB.taizyuuFloat * (float)Math.Pow(nowPlayerLocalScale.x, 3))
            {
                nowPlayerTaizyuuFloat = DB.taizyuuFloat * (float)Math.Pow(nowPlayerLocalScale.x, 3);
                AN_PlayerRigidbody.mass = nowPlayerTaizyuuFloat;
            }

            //■オリジナル重力と空気抵抗を大きさから計算（tmpで直接数値を調整）
            if (AN_Drag != (dragAdjust * (100f / GameObjectsTrs.localScale.x)) * (float)Math.Pow(nowPlayerLocalScale.x, 3))
            { AN_Drag = (dragAdjust * (100f / GameObjectsTrs.localScale.x)) * (float)Math.Pow(nowPlayerLocalScale.x, 3); }
            if (AN_Gravity.y != (gravityAdjust * -9.81f) * nowPlayerLocalScale.x)
            { AN_Gravity = new Vector3(0, (gravityAdjust * -9.81f) * nowPlayerLocalScale.x, 0); }


            // 空気抵抗を与える
            AN_PlayerRigidbody.AddForce((-AN_Drag * GameObjectsTrs.localScale.x) * AN_PlayerRigidbody.velocity);
            // 重力加速度を与える
            AN_PlayerRigidbody.AddForce(AN_Gravity * GameObjectsTrs.localScale.x, ForceMode.Acceleration);

        }

        //ジャンプ
        if (AN_GrapJumpBool)
        {
            AN_PlayerRigidbody.velocity += (VRCameraTrs.forward) * nowPlayerLocalScale.x * AN_GrapJumpVelocity;
            AN_GrapJumpBool = false;
        }

        #endregion

        #region バトル用
        //（1フレーム中の複雑なモーション処理後のオブジェの位置を取らないといけないため）（でないと智恵理の手にペアレントしてるオブジェのコリダーのRayHitは位置がズレる）
        if (isKBSystem)
        {
            #region デバッグ
            //位置読み取り
            if (tmpFixedObjPosCopy)
            {
                tmpPasteObj.transform.position = tmpCopyObj.transform.position;
                tmpPasteObj.transform.rotation = tmpCopyObj.transform.rotation;
                tmpFixedObjPosCopy = false;
            }

            #endregion

            #region プレイヤー視点
            if (KB_seeRayBool)
            { Physics.Raycast(playerSeeRay, out KB_seeRayHit, Mathf.Infinity, seeRayBlockLayerMask); }
            #endregion

            #region パンチ用
            if (KB_punchRayBool)
            {
                //ボックスキャストでだいたい手の大きさのRay
                Physics.BoxCast(KB_PlayerPunchPaths00_StartHand_R_RootTrs.position,
                    KB_PlayerPunchPaths010100_BoxCastScaleTrs.lossyScale * 0.5f,
                    KB_punchDir,
                    out KB_punchRayHit,
                    KB_PlayerPunchPaths010100_BoxCastScaleTrs.rotation,
                    Vector3.Distance(KB_PlayerPunchPaths00_StartHand_R_RootTrs.position, KB_PlayerPunchPaths0101_PunchHitPosTrs.position),
                    seeRayOshiaiLayerMask);

                KB_punchRayBool = false;
            }
            #endregion

            #region 押し合い用

            //当たったコリジョンを取得しているのでどちらもRでもLでもよい
            if (KB_OshiHandAreaRayBool)
            {
                KB_ROshiEnterCollision.collider.Raycast(KB_OshiRHandAreaRay, out KB_OshiRHandAreaRayHit, Mathf.Infinity);
                KB_ROshiEnterCollision.collider.Raycast(KB_OshiLHandAreaRay, out KB_OshiLHandAreaRayHit, Mathf.Infinity);

                KB_OshiHand_R_RootObj.transform.position = KB_OshiRHandAreaRayHit.point;
                KB_OshiHand_L_RootObj.transform.position = KB_OshiLHandAreaRayHit.point;
                //手首を肩に向け、コリジョンの面から正面を頭上とする
                KB_OshiHand_R_RootObj.transform.LookAt(KB_PlayerRHandAreaCollisionSphereTrs, KB_OshiRHandAreaRayHit.normal);
                KB_OshiHand_L_RootObj.transform.LookAt(KB_PlayerLHandAreaCollisionSphereTrs, KB_OshiLHandAreaRayHit.normal);

                KB_OshiHandAreaRayBool = false;
            }


            #endregion

            #region 怪獣ペアレントオフ（位置の維持のため）
            if (KB_KaijuTebanashiBool)
            {
                //バトル用コライダーオフ
                KB_KaijuObj.transform.GetChild(0).GetComponent<MeshCollider>().enabled = false;
                //バトル用自由落下用コライダーON
                KB_KaijuObj.transform.GetComponent<BoxCollider>().enabled = true;
                //自由落下リジッドオン
                KB_KaijuObj.transform.GetComponent<Rigidbody>().isKinematic = false;

                KB_KaijuObj.transform.SetParent(GameObjectsTrs, true);
                KB_KaijuTebanashiBool = false;
            }
            #endregion

        }


        #endregion

        #region VRカメラブロック用
        if (isVRBlockSystem)
        {
            //■VRトラッキングの値をObjに入れ続ける（VRトラッキングはローカル値なのでカメラアンカーの子にある）
            if (InputTracking.disablePositionalTracking == false)
            { VRTrackingPosObj.transform.localPosition = InputTracking.GetLocalPosition(XRNode.CenterEye); }
            else //トラッキングdisableの場合は0
            { VRTrackingPosObj.transform.localPosition = Vector3.zero; }


            #region ■壁ぶつかりでトラッキングキャンセル
            //ぶつかっているときは、突っ込んでる分だけ親カメラを逆方向へ移動(CameraAdjustTrackingObj)
            if (isVRBlockStay)
            {
                //一旦やめ
                //CameraAdjustTrackingTrs.position =
                //    CameraAdjustTrackingTrs.position - (VRCameraTrs.position - VRBlockAreaPlayerStayPrevPos);
            }
            //ぶつかってない時はVRカメラ位置取得し続ける（強制トラッキングキャンセルでなければ）
            else if (isVRBlockStay == false && isVRTrackingCancelMode == false)
            { VRBlockAreaPlayerStayPrevPos = VRCameraTrs.position; }

            #endregion //壁ぶつかりでトラッキングキャンセル
        }

        #region boolで 強制その場でトラッキングキャンセル（VRBlockシステム動いてると競合するので、Unloadされる）
        if (isVRTrackingCancelMode)
        {
            if (isVRBlockSystem) { isVRBlockSystem = false; }
            CameraAdjustTrackingTrs.position =
                CameraAdjustTrackingTrs.position - (VRCameraTrs.position - VRBlockAreaPlayerStayPrevPos);
        }
        //システム動いてないなら、現在VRカメラ位置取得しておく。 アジャスト（VRカメラひとつ上の親）は0位置に固定
        else if (isVRTrackingCancelMode == false && isVRBlockSystem == false)
        {
            VRBlockAreaPlayerStayPrevPos = VRCameraTrs.position;
            CameraAdjustTrackingTrs.localPosition = Vector3.zero;
        }
        #endregion

        #endregion


        #region ■智恵理コリダーFixed処理システム （現在はStartで始動）智恵理のコリダーをGameobjectsTrsに置いて位置をコピー更新し続ける
        //アニメの更新に判定がついてこないのと、
        //階層のスケールズレによる登りバグを防ぐため
        //Fixedで位置をコピーし続ける
        for (int i = 0; i < FixedMoveChieriCollObjList.Count; i++)
        {
            FixedMoveChieriCollObjList[i].transform.position
                = ChieriColliderObjRootObjList[i].transform.position;

            FixedMoveChieriCollObjList[i].transform.rotation
                = ChieriColliderObjRootObjList[i].transform.rotation;
        }



        #endregion

        #region ■その他コリダーFixed処理システム（智恵理手にペアレントされたペットボトルなど）GameobjectsTrsに置いて位置をコピー更新し続ける
        //クローンリストに存在すれば
        if (fixedMoveColliderCloneParentObjList.Count > 0)
        {
            #region まず本元消えてないかどうか判定処理（消えてたらクローン消す）
            for (int i = 0; i < fixedMoveColliderDefParentObjList.Count; i++)
            {
                //nullだったら削除
                if (fixedMoveColliderDefParentObjList[i] == null)
                {
                    fixedMoveColliderDefParentObjList.RemoveAt(i);

                    //cloneを削除
                    Destroy(fixedMoveColliderCloneParentObjList[i]);
                    fixedMoveColliderCloneParentObjList.RemoveAt(i);
                }
            }
            #endregion

            //本元から動きを読み取ってクローンが動く
            for (int i = 0; i < fixedMoveColliderCloneParentObjList.Count; i++)
            {
                fixedMoveColliderCloneParentObjList[i].transform.position
                    = fixedMoveColliderDefParentObjList[i].transform.position;

                fixedMoveColliderCloneParentObjList[i].transform.rotation
                    = fixedMoveColliderDefParentObjList[i].transform.rotation;
            }
        }

        #endregion
        #region ■その他コリダーFixed処理システムRigidbodyのMovePosition仕様（移動が物理に伴ったものになるらしい）
        //クローンリストに存在すれば
        if (fixedRigidMoveColliderCloneParentObjList.Count > 0)
        {
            #region まず本元消えてないかどうか判定処理（消えてたらクローン消す）
            for (int i = 0; i < fixedRigidMoveColliderDefParentObjList.Count; i++)
            {
                //nullだったら削除
                if (fixedRigidMoveColliderDefParentObjList[i] == null)
                {
                    fixedRigidMoveColliderDefParentObjList.RemoveAt(i);

                    //cloneを削除
                    Destroy(fixedRigidMoveColliderCloneParentObjList[i]);
                    fixedRigidMoveColliderCloneParentObjList.RemoveAt(i);
                    fixedRigidMoveColliderCloneParentObjRigidbodyList.RemoveAt(i);
                }
            }
            #endregion

            //大元と同じ位置にMovePosition
            for (int i = 0; i < fixedRigidMoveColliderCloneParentObjList.Count; i++)
            {
                fixedRigidMoveColliderCloneParentObjRigidbodyList[i].MovePosition
                    (fixedRigidMoveColliderDefParentObjList[i].transform.position);

                fixedRigidMoveColliderCloneParentObjRigidbodyList[i].MoveRotation
                    (fixedRigidMoveColliderDefParentObjList[i].transform.rotation);

            }
        }



        #endregion

        #region ■智恵理スキンメッシュコリダー ReloadSkinMeshColliderSystem更新用（IKなどの動きに対応するためにFixed）
        if (isFixedRSMCReload)
        {
            for (int i = 0; i < RSMC_ObjList.Count; i++)
            {
                //リロードが許可されてるもののみ
                if (RSMC_isMeshReloadList[i])
                {
                    //大元スキンメッシュレンダラーの現状メッシュを生成
                    ChieriSkinMeshColliderSkinnedMeshRendList[i].BakeMesh
                        (RSMC_MeshList[i]);

                    //メッシュコリダーからメッシュを一旦外して
                    RSMC_MeshColliderList[i].sharedMesh = null;

                    //生成したメッシュを当てはめ
                    RSMC_MeshColliderList[i].sharedMesh = RSMC_MeshList[i];
                }
            }
        }
        #endregion

    }



    [HeaderAttribute("■ここからイベント用変数群")]
    #region イベント用変数群
    public GameObject subTitleTextObj;
    Text subTitleText;
    Tweener subTitleTween;
    #endregion イベント用変数群
    [HeaderAttribute("■ここからメソッド用変数群")]
    public GameObject Method_Dummy;
    #region メソッド群

    #region  GameObject事前取得用メソッド
    public GameObject NullJudgeFind(string objName)
    {
        //シーンにあれば取得 //Resources指定も無ければログ出して終了
        if (GameObject.Find(objName) != null)
        {
            return GameObject.Find(objName);
        }
        else
        {
            Debug.Log(objName + "オブジェクトがオフまたは無い");
            return null;
        }
    }
    public GameObject NullJudgeFind(ref GameObject obj, string objName, string resourcesAddress = null)
    {
        //シーンにあれば取得 //無ければログ出して終了
        if (GameObject.Find(objName) != null)
        { obj = GameObject.Find(objName); }
        ////Resourcesはクローンして設置する必要があるので一旦保留（ペアレントや設置場所、メモリ食いをどうするか）
        //else if (resourcesAddress != null)
        //{ obj = Resources.Load(resourcesAddress) as GameObject; }
        else
        { Debug.Log(objName + "オブジェクトがオフまたはシーンに無い"); }
        return obj;
    }
    public Transform NullJudgeFind(ref Transform trs, string objName)
    {
        //シーンにあれば取得 //無ければログ出して終了
        if (GameObject.Find(objName) == null) { Debug.Log(objName + "オブジェクトがオフまたは無い"); }
        else
        {
            trs = GameObject.Find(objName).transform;
        }
        return trs;
    }

    //既に取得されていればなにもせず、なければシーンから、それでもなければリソースからクローン
    void ObjSceneOrResouceLoad(ref GameObject Obj, String ObjName, String resourceAddress)
    {
        //すでに取得されていたら何もしない
        if (Obj != null) { return; }

        //シーンに置かれていたら取得、なければリソースから取得
        if (GameObject.Find(ObjName) != null)
        { Obj = GameObject.Find(ObjName); }
        else
        {
            Obj = Instantiate(Resources.Load(resourceAddress) as GameObject);
        }

    }

    #endregion  GameObject取得用メソッド

    #region シーン移動 画面フェード カメラ制御
    //現在情報を保存してシーン移動（今のシーンだったら何もしない）
    public void MoveScene(string sceneName, bool isForceLoad = false)
    {
        //シーンチェンジがTrueなら行う
        if (DB.isSceneChange)
        {
            //■現在シーンが読み込むシーンと別 または強制ロードなら読み込む
            if (SceneManager.GetActiveScene().name != sceneName
                || isForceLoad)
            {
                //■シーン移動前にDBデータ渡し

                //宿題データ保存(宿題がONだったら)
                if (isHomeworkSystem) { HwDataSave(); }


                ////UI消し
                //DB.evMoveDelObjList.Clear();

                //Resources.Load()で読み込んだデータは、そのデータを使用していたオブジェクトが削除されても、再利用する時のためにキャッシュに残る仕組みになっているようです。
                //このメソッドは、現在キャッシュに残っていて使用していないアセットを破棄してくれます。
                Resources.UnloadUnusedAssets();

                //シーン移動
                SceneManager.LoadScene(sceneName);
            }
        }
    }
    //カメラリセット
    public void CameraReset
        (Vector3? newResetLocalEul = null
        , Vector3? newResetAnchorLocalPos = null
        , bool TrackingRecenter = false
        , Vector3? newResetAnchorLocalRot = null
        , bool cameraObjectsPosScaleReset = false
        , bool userControlCameraReset = true
        )
    {
        //シーンに合わせての配置と回転 → CameraObjects
        //VRプレイヤーのボタン回転 → Ancohr
        //VRのトラッキング回転 → VRカメラ
        //PCプレイヤーの回転 → VRカメラ
        //PCプレイヤーVRカメラ一定以上回転したら、Ancohrに回転値渡してVRカメラ0？（振り向きなどの対応）

        //CameraObjectsの位置のリセットはない（ゲーム内で移動するので）
        //カメラリセットでリセットされるのは
        //・CameraObjectsの回転
        //・Anchorの位置（高さ）
        //・Anchorの回転（転んだときなど）
        //・VRcameraの位置と回転

        //■カメラリセット値変更引数あれば書き換え(デフォルト引数が定数でないため、キャストが必要)（Vectorは定数が用意できない）
        if (newResetLocalEul != null)
        { DB.cameraObjectsResetLocalEul = (Vector3)newResetLocalEul; }
        if (newResetAnchorLocalPos != null)
        { DB.cameraAnchorResetLocalPos = (Vector3)newResetAnchorLocalPos; }
        if (newResetAnchorLocalRot != null)
        { DB.cameraAnchorResetLocalRot = (Vector3)newResetAnchorLocalRot; }
        //else { DB.cameraAnchorResetLocalRot = Vector3.zero; }//アンカーの回転は稀（倒れ時など）なので、指定なければゼロに


        //ここで代入する値が、そのシーンのデフォルトカメラ値
        CameraObjectsTrs.localEulerAngles = DB.cameraObjectsResetLocalEul;
        CameraAnchorTrs.localPosition = DB.cameraAnchorResetLocalPos;
        CameraAnchorTrs.localEulerAngles = DB.cameraAnchorResetLocalRot;

        //ゼロに戻す系
        VRCameraTrs.localPosition
        = VRUICameraTrs.localPosition
        = VRFadeCameraTrs.localPosition
        = VRCameraTrs.localEulerAngles
        = VRUICameraTrs.localEulerAngles
        = VRFadeCameraTrs.localEulerAngles
        = Vector3.zero;
        //倒れ演出時などはユーザーカメラリセットしない用の引数Bool設定（デフォルトがtrue）
        if (userControlCameraReset)
        {
            userCameraControlEul
                = CameraUserControlTrs.localEulerAngles
                = Vector3.zero;

            //マウスでのカメラ縦回転制限値リセット
            nowMouseDragAngleXLimitFloat = 0;

            //スティックでのカメラ回転リセット
            nowCameraXLimitFloat = 0;
            nowCameraXFloat = 0;
        }


        //VRのトラッキング位置リセット
        if (TrackingRecenter)
        { InputTracking.Recenter(); }

        //デバッグ的なポジションリセット
        if (cameraObjectsPosScaleReset)
        {
            CameraObjectsTrs.localPosition = DB.cameraObjectsResetLocalPos;
            nowPlayerLocalScale = DB.cameraObjectsResetLocalScl;
        }

    }

    #region フェードをDOTweenで
    private float defFadeTime = 2;
    private Ease defFadeEase = Ease.OutQuad;

    //ホワイト
    public void FadeWhite(float endDepth)
    { FadeWhite(endDepth, defFadeTime, false, defFadeEase, false); }
    public void FadeWhite(float endDepth, float time)
    { FadeWhite(endDepth, time, false, defFadeEase, false); }
    public void FadeWhite(float endDepth, float time, bool isUIFront)
    { { FadeWhite(endDepth, time, isUIFront, defFadeEase, false); } }
    public void FadeWhite(float endDepth, float time, Ease ease)
    { { FadeWhite(endDepth, time, false, ease, false); } }
    public void FadeWhite(float endDepth, float time, bool isUIFront, bool setUpdate)
    { { FadeWhite(endDepth, time, isUIFront, defFadeEase, false); } }
    public void FadeWhite(float endDepth, float time, bool isUIFront, Ease ease)
    { { FadeWhite(endDepth, time, isUIFront, ease, false); } }

    Tweener fadeWhiteTweener;//キャンセル用
    public void FadeWhite(float endDepth, float time, bool isUIFront, Ease ease, bool setUpdate)
    {
        nowFadeEndDepthFloat = endDepth;

        //フェードレイヤー最前面か否か（スマホやUIなどを前面表示するため）
        if (isUIFront == true)
        {
            //fadeWhiteQuadMeshRenderer.sortingLayerName = "fadeFront";
            fadeWhiteQuadMeshRenderer.enabled = false;
            fadeWhiteUIQuadMeshRenderer.enabled = true;
        }
        else
        {
            //fadeWhiteQuadMeshRenderer.sortingLayerName = "fadeBack";
            fadeWhiteQuadMeshRenderer.enabled = true;
            fadeWhiteUIQuadMeshRenderer.enabled = false;
        }

        //重複時キャンセル
        if (fadeWhiteTweener != null) { fadeWhiteTweener.Kill(); }

        fadeWhiteTweener =
        DOTween.To(() => fadeWhiteQuadMeshRenderer.material.color, (x) => fadeWhiteQuadMeshRenderer.material.color
             = x, new Color(0, 0, 0,
             endDepth),
             time)
             .SetEase(ease)
             .SetUpdate(setUpdate)
             .OnUpdate(() => { fadeWhiteUIQuadMeshRenderer.material.color = fadeWhiteQuadMeshRenderer.material.color; });//UIFrontのも同時に

    }

    //ブラック
    public void FadeBlack(float endDepth)
    { FadeBlack(endDepth, defFadeTime, false, defFadeEase, false); }
    public void FadeBlack(float endDepth, float time)
    { FadeBlack(endDepth, time, false, defFadeEase, false); }
    public void FadeBlack(float endDepth, float time, bool isUIFront)
    { { FadeBlack(endDepth, time, isUIFront, defFadeEase, false); } }
    public void FadeBlack(float endDepth, float time, Ease ease)
    { { FadeBlack(endDepth, time, false, ease, false); } }
    public void FadeBlack(float endDepth, float time, bool isUIFront, bool setUpdate)
    { { FadeBlack(endDepth, time, isUIFront, defFadeEase, setUpdate); } }
    public void FadeBlack(float endDepth, float time, bool isUIFront, Ease ease)
    { { FadeBlack(endDepth, time, isUIFront, ease, false); } }

    Tweener fadeBlackTweener;//キャンセル用
    private void FadeBlack(float endDepth, float time, bool isUIFront, Ease ease, bool setUpdate)
    {
        nowFadeEndDepthFloat = endDepth;

        //フェードレイヤー最前面か否か（スマホやUIなどを前面表示するため）
        if (isUIFront == true)
        {
            //fadeBlackQuadMeshRenderer.sortingLayerName = "fadeFront";
            fadeBlackQuadMeshRenderer.enabled = false;
            fadeBlackUIQuadMeshRenderer.enabled = true;
            if (fadeBlackCanvasImage != null) { fadeBlackCanvasImage.enabled = true; }//Hiru更新できないのでif処理

        }
        else
        {
            //fadeBlackQuadMeshRenderer.sortingLayerName = "fadeBack";
            fadeBlackQuadMeshRenderer.enabled = true;
            fadeBlackUIQuadMeshRenderer.enabled = false;
            if (fadeBlackCanvasImage != null) { fadeBlackCanvasImage.enabled = false; }//Hiru更新できないのでif処理
        }
        //重複時キャンセル
        if (fadeBlackTweener != null) { fadeBlackTweener.Kill(); }

        fadeBlackTweener =
        DOTween.To(() => fadeBlackQuadMeshRenderer.material.color, (x) => fadeBlackQuadMeshRenderer.material.color
             = x, new Color(0, 0, 0
             , endDepth)
             , time)
             .SetEase(ease)
             .SetUpdate(setUpdate)
             .OnUpdate(() =>
             {
                 fadeBlackUIQuadMeshRenderer.material.color = fadeBlackQuadMeshRenderer.material.color;
                 if (fadeBlackCanvasImage != null)//Hiru更新できないのでif処理
                 { fadeBlackCanvasImage.color = fadeBlackQuadMeshRenderer.material.color; }

             });//UIFrontのも同時に
    }

    //カメラにフェードさせるスクリプトがついていて、それにマテリアルがついている、それをいじる
    public Material
        newFadeBlackMat,
        newFadeBlackUIFrontMat;
    Tweener //重複キャンセル用
        newFadeBlackTweener,
        newFadeBlackUIFrontTweener;
    void NewFadeBlack(float endDepth = 1, float time = 2, bool isUIFront = false, Ease ease = Ease.OutQuad, bool setUpdate = false)
    {
        //今まで1=黒で作っていたので、逆にする
        endDepth = 1 - endDepth;


        if (isUIFront)
        {
            //重複時キャンセル
            if (newFadeBlackUIFrontTweener != null) { newFadeBlackUIFrontTweener.Kill(); }
            newFadeBlackUIFrontTweener =
                newFadeBlackUIFrontMat.DOColor(new Color(endDepth, endDepth, endDepth), time)
                .SetEase(ease)
                .SetUpdate(setUpdate);
        }
        else
        {
            //重複時キャンセル
            if (newFadeBlackTweener != null) { newFadeBlackTweener.Kill(); }
            newFadeBlackTweener =
                newFadeBlackMat.DOColor(new Color(endDepth, endDepth, endDepth), time)
                .SetEase(ease)
                .SetUpdate(setUpdate);
        }

    }

    //スマホ専用フェードQuad
    private void FadeBlackSmartPhone(float endDepth, float time, bool sortingLayerFront, Ease ease, bool setUpdate)
    {
        //フェードレイヤー最前面か否か（スマホやUIなどを前面表示するため）
        if (sortingLayerFront == true) { fadeBlackSmartPhoneQuadMeshRenderer.sortingLayerName = "fadeFront"; }
        else { fadeBlackSmartPhoneQuadMeshRenderer.sortingLayerName = "fadeBack"; }

        DOTween.To(() => fadeBlackSmartPhoneQuadMeshRenderer.material.color, (x) => fadeBlackSmartPhoneQuadMeshRenderer.material.color
             = x, new Color(0, 0, 0, endDepth), time).SetEase(ease).SetUpdate(setUpdate);
    }

    //カラー(エミッション変更方法がわかったので追加した)
    private void FadeColor(Color color, float endDepth)
    { FadeColor(color, endDepth, defFadeTime, false, defFadeEase, false); }
    private void FadeColor(Color color, float endDepth, float time)
    { FadeColor(color, endDepth, time, false, defFadeEase, false); }
    private void FadeColor(Color color, float endDepth, float time, bool sortingLayerFront)
    { { FadeColor(color, endDepth, time, sortingLayerFront, defFadeEase, false); } }
    private void FadeColor(Color color, float endDepth, float time, Ease ease)
    { { FadeColor(color, endDepth, time, false, ease, false); } }
    private void FadeColor(Color color, float endDepth, float time, bool sortingLayerFront, bool setUpdate)
    { { FadeColor(color, endDepth, time, sortingLayerFront, defFadeEase, false); } }
    private void FadeColor(Color color, float endDepth, float time, bool sortingLayerFront, Ease ease, bool setUpdate)
    {
        nowFadeEndDepthFloat = endDepth;

        //カラー指定
        //fadeColorQuadMeshRenderer.material.EnableKeyword("_EMISSION"); //キーワードの有効化を忘れずに //いらないっぽい
        fadeColorQuadMeshRenderer.material.SetColor("_EmissionColor", color);

        //フェードレイヤー最前面か否か（スマホやUIなどを前面表示するため）
        if (sortingLayerFront == true) { fadeColorQuadMeshRenderer.sortingLayerName = "fadeFront"; }
        else { fadeColorQuadMeshRenderer.sortingLayerName = "fadeBack"; }

        DOTween.To(() => fadeColorQuadMeshRenderer.material.color, (x) => fadeColorQuadMeshRenderer.material.color
             = x, new Color(0, 0, 0,
             endDepth),
             time)
             .SetEase(ease)
             .SetUpdate(setUpdate);

    }


    #endregion


    #endregion



    #region PlayerTargetのコリダートリガー
    //判定取る用だが、複数接触を考えるとLIST化した方がよいかも
    bool
        playerTargetOnTriggerEnterBool,
        playerTargetOnTriggerExitBool,
        playerTargetOnTriggerStayBool;
    Collider
        playerTargetOnTriggerEnterCol,
        playerTargetOnTriggerExitCol,
        playerTargetOnTriggerStayCol;

    public IEnumerator PlayerTargetOnTriggerEnter(Collider coll)
    {
        playerTargetOnTriggerEnterCol = coll;
        playerTargetOnTriggerEnterBool = true;
        yield return null;
        playerTargetOnTriggerEnterBool = false;
        playerTargetOnTriggerEnterCol = null;
        yield break;
    }
    public IEnumerator PlayerTargetOnTriggerExit(Collider coll)
    {
        playerTargetOnTriggerExitCol = coll;
        playerTargetOnTriggerExitBool = true;
        yield return null;
        playerTargetOnTriggerExitBool = false;
        playerTargetOnTriggerExitCol = null;
        yield break;
    }
    public void PlayerTargetOnTriggerStay(Collider coll)
    {
        //やり方思いつかないので後回し
    }

    #endregion 

    #region サイズ・ステータス系メソッド(元orig_sizechange)

    #region 体力、満腹度、ダメージメソッド
    //体力　試しにプロパティ化（書き込み時に0を下回らないMaxを上回らない）
    int tairyokuInt = 100;
    public int tairyokuMaxInt = 100;
    public int TairyokuIntP
    {
        get { return tairyokuInt; }
        set { tairyokuInt = Mathf.Clamp(value, 0, tairyokuMaxInt); }
    }
    //腹
    int haraInt = 100;
    public int haraMaxInt = 100;
    public int HaraIntP
    {
        get { return haraInt; }
        set { haraInt = Mathf.Clamp(value, 0, haraMaxInt); }
    }

    void Damage(int damage, bool isEnsyutu = true)
    {
        TairyokuIntP -= damage;

        if (isEnsyutu)
        {
            SEPlay(UISEObj, "ui_laser_shoot_02");
        }

    }

    #endregion


    //巨大化メソッド
    public void grow()
    {
        nowPlayerLocalScale *= sizechangeRateFloat;

        //以前Jukesさんが作った身長も一緒に下がるメソッド　今はカメラアンカーが親にあるのでいらなそう
        /*
        jukes_b = tempPlayerPos.y - tempPlayerScl.y * jukes_a;
        tempPlayerScl *= sizechangeRateFloat;
        tempPlayerPos.y = tempPlayerScl.y * jukes_a + jukes_b;
        */
    }
    //縮小化メソッド
    public void SeeShrink()
    {
        nowPlayerLocalScale /= sizechangeRateFloat;

        //以前Jukesさんが作った身長も一緒に下がるメソッド　今はカメラアンカーが親にあるのでいらなそう
        /*
        jukes_b = tempPlayerPos.y - tempPlayerScl.y * jukes_a;
        tempPlayerScl /= sizechangeRateFloat;
        tempPlayerPos.y = tempPlayerScl.y * jukes_a + jukes_b;
        */
    }

    #endregion

    #region BGM SE
    public void SEPlay(string audioClipName)
    { StartCoroutine(SEPlayCor(null, null, null, audioClipName, null, 1)); }
    public void SEPlay(string audioClipName, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(null, null, null, audioClipName, null, volume, delayTime = 0)); }
    public void SEPlay(string audioClipName, GameObject onObj)
    { StartCoroutine(SEPlayCor(null, null, null, audioClipName, onObj, 1)); }
    public void SEPlay(string audioClipName, GameObject onObj, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(null, null, null, audioClipName, onObj, volume, delayTime)); }
    public void SEPlay(GameObject SEObj, string audioClipName)
    { StartCoroutine(SEPlayCor(null, SEObj, null, audioClipName, null, 1)); }
    public void SEPlay(GameObject SEObj, string audioClipName, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(null, SEObj, null, audioClipName, null, volume, delayTime)); }
    public void SEPlay(GameObject SEObj, string audioClipName, GameObject onObj)
    { StartCoroutine(SEPlayCor(null, SEObj, null, audioClipName, onObj)); }
    public void SEPlay(GameObject SEObj, string audioClipName, GameObject onObj, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(null, SEObj, null, audioClipName, onObj, volume, delayTime)); }
    public void SEPlay(Vector3 pos, GameObject SEObj, string audioClipName, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(pos, SEObj, null, audioClipName, null, volume, delayTime)); }
    public void SEPlay(GameObject SEObj, AudioClip aClip, Vector3 onPos)
    {
        StartCoroutine(SEPlayCor(onPos, SEObj, aClip));
    }
    public void SEPlay(GameObject SEObj, AudioClip aClip, GameObject onObj, float volume, float delayTime = 0)
    { StartCoroutine(SEPlayCor(null, SEObj, aClip, null, onObj, volume, delayTime)); }
    IEnumerator SEPlayCor(Vector3? pos = null, GameObject SEObj = null, AudioClip aClip = null, string audioClipName = "UI_pin", GameObject onObj = null, float volume = 1, float delayTime = 0)
    {
        //ディレイ
        yield return new WaitForSeconds(delayTime);

        //■onObjが指定されてなければ
        if (onObj == null)
        {
            //更に位置も指定されてなければ
            if (pos == null)
            {
                //ただ再生
                //PlayOneShotはCilpを直接読み込み重ねて再生してくれる（毎回読み込むので重いのかも？）
                if (aClip) { sounderSEAudioSource.PlayOneShot(aClip, volume); }
                else { sounderSEAudioSource.PlayOneShot(ResourceFiles.SE[audioClipName], volume); }

            }
            else //■位置が指定されていたら
            {
                GameObject tempSEObj;
                //SEObjが指定されているかどうか
                if (SEObj == null)
                { tempSEObj = Instantiate(OtherSEObj); }
                else
                { tempSEObj = Instantiate(SEObj); }

                //Volume設定
                AudioSource tempAudSource = tempSEObj.GetComponent<AudioSource>();
                tempSEObj.transform.position = (Vector3)pos;
                if (aClip) { tempAudSource.PlayOneShot(aClip, volume); }
                else { tempAudSource.PlayOneShot(ResourceFiles.SE[audioClipName], volume); }

                //再生終了待ち
                while (true)
                {
                    if (tempAudSource != null)//再生中に消滅した場合のエラー防ぎ
                    {
                        if (tempAudSource.isPlaying == false)
                        { goto 抜け; }
                    }
                    else
                    { goto 抜け; }
                    yield return null;
                }

                抜け:
                if (tempSEObj != null) { Destroy(tempSEObj); }

            }
        }
        //■onObj指定されてればそのObjの子にサウンド再生Obj生成して再生して消去
        else
        {
            GameObject tempSEObj;
            //SEObjが指定されているかどうか
            if (SEObj == null)
            { tempSEObj = Instantiate(OtherSEObj); }
            else
            {
                //    Debug.Log(SEObj);
                tempSEObj = Instantiate(SEObj);
            }

            //Volume設定
            AudioSource tempAudSource = tempSEObj.GetComponent<AudioSource>();
            tempSEObj.transform.SetParent(onObj.transform, false);
            if (aClip) { tempAudSource.PlayOneShot(aClip, volume); }
            else { tempAudSource.PlayOneShot(ResourceFiles.SE[audioClipName], volume); }

            //再生終了待ち
            while (true)
            {
                if (tempAudSource != null)//再生中に消滅した場合のエラー防ぎ
                {
                    if (tempAudSource.isPlaying == false)
                    { goto 抜け; }
                }
                else
                { goto 抜け; }
                yield return null;
            }

            抜け:
            if (tempSEObj != null) { Destroy(tempSEObj); }

        }
        yield break;
    }

    public AudioMixer
        audioMixer;
    public float
        defAsiotoVol;

    public AnimationCurve //音量減増のカーブ（リニアだとー20くらいでほぼ聴こえなくなってしまうので）
        volumeCurve;

    //■※保存したカーブを読み込む方法が欲しい所


    //スライダーからAudioMixerの音量を変更をするメソッド
    //Curve.Evaluate（カーブの現在地（0~1））
    //現在ボリュームがカーブにとってどこで（0～1）、それに80をかけて
    //スライダーの0 = -80にするため-80付与（スライダーを0～正数に限っている）
    public void SetMasterVolume(float volume)
    {
        audioMixer.SetFloat("MasterVol", (volumeCurve.Evaluate(volume / 80) * 80) - 80);
        DB.userMasterVolume = volume;
    }
    public void SetBGMVolume(float volume)
    {
        audioMixer.SetFloat("BGMVol", (volumeCurve.Evaluate(volume / 80) * 80) - 80);
        DB.userBGMVolume = volume;
    }
    public void SetSEVolume(float volume)
    {
        audioMixer.SetFloat("SEVol", (volumeCurve.Evaluate(volume / 80) * 80) - 80);
        DB.userSEVolume = volume;
    }

    Tweener bGMPlayTweener;
    public void BGMPlay
        (
        bool isPlay = true
        , string clipName = null
        , float volume = 1
        , float fadeInTime = 1.5f
        , float fadeOutTime = 1.5f
        , AudioClip audioClip = null
        )
    {
        if (bGMPlayTweener != null) { bGMPlayTweener.Kill(); }
        //AudioSource指定
        AudioSource playSource = sounderBGMAudioSource;

        #region BGM用AudioClip設定
        //まずは現在の取得
        AudioClip playClip = playSource.clip;

        //指定があれば当てはめ
        if (audioClip != null)
        {
            //同じのなら抜け
            if (playClip == audioClip) { goto AudioClip設定抜け; }

            playClip = audioClip;
        }
        else if (clipName != null)
        {
            //同じのなら抜け
            if (playClip == Resources.Load("Main/BGM/" + clipName) as AudioClip) { goto AudioClip設定抜け; }
            playClip = Resources.Load("Main/BGM/" + clipName) as AudioClip;
        }

        //指定がなければ、フローチャートから
        else
        {
            FlowChartKoma tmpKomaData =
                flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>();
            if (tmpKomaData.BGMAudioClip != null)
            {
                //同じのなら抜け
                if (playClip == tmpKomaData.BGMAudioClip) { goto AudioClip設定抜け; }

                playClip = tmpKomaData.BGMAudioClip;
            }
            //していなければ無音
            if (tmpKomaData.BGMAudioClip == null)
            {
                playClip = null;
            }
        }

        AudioClip設定抜け:
        #endregion

        //既に再生中の場合
        if (playSource.isPlaying)
        {
            //同じClipなら
            if (playSource.clip == playClip)
            {
                //isPlayがtrueならVolume変更のみ
                if (isPlay)
                {
                    bGMPlayTweener =
                    DOTween.To(() => playSource.volume, (x) => playSource.volume = x
                    , volume
                    , fadeInTime);
                }
                else//falseならフェードアウトしてストップ
                {
                    bGMPlayTweener =
                    DOTween.To(() => playSource.volume, (x) => playSource.volume = x
                    , volume
                    , fadeOutTime)
                    .OnComplete(() =>
                    { playSource.Stop(); });
                }

            }
            //違うClipなら
            else
            {
                //フェードアウト
                bGMPlayTweener =
                DOTween.To(() => playSource.volume, (x) => playSource.volume = x
                , 0f
                , fadeOutTime)
                .OnComplete(() =>
                {
                    if (playClip != null)
                    {
                        #region ■音楽スタート
                        playSource.volume = 0f;
                        if (playSource == speaker.audioSource)//スピーカーならエフェクト
                        {
                            speakerHighPass.cutoffFrequency = 2500;
                            speakerHighPass.highpassResonanceQ = 1;
                        }
                        playSource.clip = playClip;
                        playSource.Play();

                        bGMPlayTweener =
                        DOTween.To(() => playSource.volume, (x) => playSource.volume = x
                        , volume
                        , fadeInTime);
                        #endregion
                    }
                    //ストップか、audioClip指定nullならストップ
                    else if (isPlay == false || playClip == null)
                    { playSource.Stop(); }
                });
            }
        }
        else
        {
            #region ■音楽スタート
            playSource.volume = 0f;
            if (playSource == speaker.audioSource)//スピーカーならエフェクト
            {
                speakerHighPass.cutoffFrequency = 2500;
                speakerHighPass.highpassResonanceQ = 1;
            }
            playSource.clip = playClip;
            playSource.Play();

            bGMPlayTweener =
            DOTween.To(() => playSource.volume, (x) => playSource.volume = x
            , volume
            , fadeInTime);
            #endregion
        }



    }


    #endregion

    #region 表情・animator系メソッド

    #region ■CrossFadeInFixedTimeを改造

    #region ■■智恵理用
    List<IEnumerator> //ディレイ中にディレイモーション命令来たら前のキャンセル用
        chieriMotionDelayCorList = new List<IEnumerator>();
    //※↑はStartでレイヤー数分の初期化（コルーチンはpublicで事前インスペクター保持できないので）

    //■CrossFadeInFixedTimeを改造（ディレイ中に移行命令があった場合、ディレイをキャンセル）
    public void ChieriMotion(string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        girlAnim.CrossFadeInFixedTime(stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime);//実行

        //もしこのレイヤーにディレイ予約が入っていたらキャンセル
        if (chieriMotionDelayCorList[layer] != null)
        {
            StopCoroutine(chieriMotionDelayCorList[layer]);
            chieriMotionDelayCorList[layer] = null;
        }
    }

    //■遅延して表情移行
    void ChieriMotionDelay(float waitTimeSeconds, string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        //既に別のディレイが予約中だったらそれはキャンセル
        if (chieriMotionDelayCorList[layer] != null) { StopCoroutine(chieriMotionDelayCorList[layer]); }
        //入れ替えして実行
        StartCoroutine(chieriMotionDelayCorList[layer] = ChieriMotionDelayCor(waitTimeSeconds, stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime));
    }
    public IEnumerator ChieriMotionDelayCor(float delayTimeSeconds, string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        yield return new WaitForSeconds(delayTimeSeconds);//ウェイト
        if (chieriMotionDelayCorList[layer] != null)//ウェイト中キャンセルされてなければ
        {
            girlAnim.CrossFadeInFixedTime(stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime);//実行
        }
        chieriMotionDelayCorList[layer] = null; //コルーチンnull
    }

    #endregion

    #region ■■プレイヤー用
    List<IEnumerator> //ディレイ中にディレイモーション命令来たら前のキャンセル用
        playerMotionDelayCorList = new List<IEnumerator>();

    //■CrossFadeInFixedTimeを改造（ディレイ中に移行命令があった場合、ディレイをキャンセル）
    public void PlayerMotion(string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        //実行
        playerAnim.CrossFadeInFixedTime(stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime);

        //もしこのレイヤーにディレイ予約が入っていたらキャンセル
        if (playerMotionDelayCorList[layer] != null)
        {
            StopCoroutine(playerMotionDelayCorList[layer]);
            playerMotionDelayCorList[layer] = null;
        }
    }

    //■遅延して表情移行
    void PlayerMotionDelay(float waitTimeSeconds, string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        //既に別のディレイが予約中だったらそれはキャンセル
        if (playerMotionDelayCorList[layer] != null) { StopCoroutine(playerMotionDelayCorList[layer]); }
        //入れ替えして実行
        StartCoroutine(playerMotionDelayCorList[layer] = PlayerMotionDelayCor(waitTimeSeconds, stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime));
    }
    public IEnumerator PlayerMotionDelayCor(float delayTimeSeconds, string stateName, float transitionDuration, int layer = -1, float fixedTime = 0.0f, float normalizedTransitionTime = 0)
    {
        yield return new WaitForSeconds(delayTimeSeconds);//ウェイト
        if (playerMotionDelayCorList[layer] != null)//ウェイト中キャンセルされてなければ
        {
            playerAnim.CrossFadeInFixedTime(stateName, transitionDuration, layer, fixedTime, normalizedTransitionTime);//実行
        }
        playerMotionDelayCorList[layer] = null; //コルーチンnull
    }
    #endregion



    #endregion

    #region ■汗垂れ
    bool//BlendShapeを操作するためLateUpdateで処理する用
        aseLateUpdateBool;
    float//LateUpdateで代入する用
        aseWeightFloat;
    Tweener
        aseFadeinTweener,
        aseMoveTweener,
        aseVisTimeWaitTweener,
        aseFadeoutTweener;
    void AseTare()
    { AseTare(2, true); }
    void AseTare(bool aseOn)
    { AseTare(2, aseOn); }
    void AseTare(float visTime)
    { AseTare(visTime, true); }
    void AseTare(float visTime, bool aseOn)
    {
        #region aseOnがfalseなら強制停止
        if (aseOn == false)
        {
            //全切り
            aseFadeinTweener.Kill();
            aseMoveTweener.Kill();
            aseVisTimeWaitTweener.Kill();
            aseFadeoutTweener.Kill();
            //汗位置ウェイト0
            aseWeightFloat = 0;
            //透明
            Ase.material.color = new Color(1, 1, 1, 0);
            aseLateUpdateBool = false;
            return;
        }
        #endregion

        //初回
        if (aseLateUpdateBool == false)
        {
            aseLateUpdateBool = true;

            //汗位置ウェイト0
            aseWeightFloat = 0;
            //透明
            Ase.material.color = new Color(1, 1, 1, 0);
            //フェードイン
            aseFadeinTweener =
            DOTween.To(() => Ase.material.color, (x) => Ase.material.color = x
            , new Color(1, 1, 1, 1)
            , 2)
            .SetEase(Ease.OutExpo)
            .SetAutoKill(false);

            aseMoveTweener =
            DOTween.To(() => aseWeightFloat, (y) => aseWeightFloat = y
            , 100
            , 2)
            .SetEase(Ease.OutExpo)
            .SetAutoKill(false)
            .OnComplete(() =>
            {
                //不透明にしておくのをTweenにしておくことで待機（若干むだっぽいがひとまず）
                aseVisTimeWaitTweener =
            DOTween.To(() => Ase.material.color, (x) => Ase.material.color = x
            , new Color(1, 1, 1, 1)
            , visTime)
            .SetEase(Ease.OutExpo)
            .OnComplete(() =>
             {
                 //透明に
                 aseFadeoutTweener =
             DOTween.To(() => Ase.material.color, (x) => Ase.material.color = x
             , new Color(1, 1, 1, 0)
             , 2)
             .SetEase(Ease.OutExpo)
             .OnComplete(() =>
             {
                 //透明になったらオフ
                 aseLateUpdateBool = false;
                 //Tweener切り
                 aseFadeinTweener.Kill();
                 aseMoveTweener.Kill();
             });
             });
            });
        }
        else
        {
            //初期化してリスタート
            aseVisTimeWaitTweener.Kill();
            aseFadeoutTweener.Kill();
            //汗位置ウェイト0
            aseWeightFloat = 0;
            //透明
            Ase.material.color = new Color(1, 1, 1, 0);
            aseFadeinTweener.Restart();
            aseMoveTweener.Restart();
        }

    }
    #region //旧汗垂れ
    //bool isAseVisWhileEnable = false;//引数でfalseを送り、すでに走ってるコルーチンをとめるために
    //void AseTare()
    //{ StartCoroutine(AseTareCor(1, true)); }
    //void AseTare(bool aseOn)
    //{ StartCoroutine(AseTareCor(0, aseOn)); }
    //void AseTare(float visTime)
    //{ StartCoroutine(AseTareCor(visTime, true)); }
    //IEnumerator AseTareCor(float visTime, bool aseOn)
    //{
    //    //宣言
    //    float
    //        tempAseWeight = 0,//ループ中代入するブレンドシェイプウェイト値
    //        tempWhileTime = 0,//ループ抜け出す用タイマー
    //        tempMotionTime = 2,//Tweenする時間初期化
    //        tempVisTime = 0;//渡された汗表示時間カウント用

    //    if (aseOn == false)//引数でfalse指定で既に走ってるコルーチンもとめる為
    //    {
    //        isAseVisWhileEnable = false;
    //        goto 汗止め;
    //    };


    //    //boolで重複キャンセル
    //    if (aseLateUpdateBool) { yield break; }
    //    

    //    //汗コンポーネントON（動いてない？）
    //    Ase.enabled = true;

    //    //汗LateUpdate実行bool ON
    //    aseLateUpdateBool = true;

    //    //汗フェードイン
    //    DOTween.To(() => Ase.material.color, (x) => Ase.material.color
    //       = x, new Color(1, 1, 1, 1)
    //       , tempMotionTime)
    //       .SetEase(Ease.OutExpo);

    //    //汗垂れるウェイト値（代入するためtemp値操作）
    //    DOTween.To(() => tempAseWeight, (y) => tempAseWeight
    //       = y, 100
    //       , tempMotionTime)
    //       .SetEase(Ease.OutExpo);

    //    //垂れモーション完了までLateUpdateの命令に代入しながらループ待機
    //    while (tempWhileTime < tempMotionTime)
    //    {
    //        aseWeightFloat = tempAseWeight;
    //        tempWhileTime += 1 * Time.deltaTime;
    //        yield return null;
    //    }

    //    //■引数で指定されたvisTime分ウェイト
    //    isAseVisWhileEnable = true;
    //    while (isAseVisWhileEnable == true)
    //    {
    //        tempVisTime += 1 * Time.deltaTime;
    //        if (visTime <= tempVisTime) { isAseVisWhileEnable = false; }
    //        yield return null;
    //    }
    //    Debug.Log("あせぬけ");
    //    汗止め:

    //    //汗フェードアウト
    //    DOTween.To(() => Ase.material.color, (x) => Ase.material.color
    //       = x, new Color(1, 1, 1, 0),
    //       tempMotionTime).SetEase(Ease.OutExpo);

    //    //汗 フェードアウト待ち
    //    yield return new WaitForSeconds(tempMotionTime);

    //    //LateUpdate命令用bool OFF
    //    aseLateUpdateBool = false;

    //    //汗OFF （効いてない？）
    //    Ase.enabled = false;

    //    
    //}
    #endregion
    #endregion

    #region ■照れ頬
    Tweener terehohoTweener;
    void TereHoho()
    {
        TereHoho(true, 3f);
    }
    void TereHoho(float heniTime = 3f, bool tereOn = true)
    { TereHoho(tereOn, heniTime); }
    void TereHoho(bool tereOn = true, float heniTime = 3f)
    {
        //前回のが生きてたら更新
        if (terehohoTweener != null)
        {
            if (tereOn)
            {
                terehohoTweener.ChangeEndValue(tereOnColor, heniTime, true);
            }
            else
            {
                terehohoTweener.ChangeEndValue(tereDefOffColor, heniTime, true);
            }
        }
        else //なかったら新規
        {
            if (tereOn)
            {
                terehohoTweener =
                    DOTween.To(() => tereMaterial.color, (x) => tereMaterial.color
                    = x, tereOnColor, heniTime)
                    .SetAutoKill(false)
                    .OnComplete(() =>
                    {
                        terehohoTweener.Kill();
                        terehohoTweener = null;
                    });
            }
            else
            {
                terehohoTweener =
                    DOTween.To(() => tereMaterial.color, (x) => tereMaterial.color
                    = x, tereDefOffColor, heniTime)
                    .SetAutoKill(false)
                    .OnComplete(() =>
                    {
                        terehohoTweener.Kill();
                        terehohoTweener = null;
                    });
            }
        }
    }

    //照れ頬透明度変更(デュレーションいらない（Terehohoでやる）
    void TereHohoAlphaChange(float alphaFloat, float durationTime = 0)
    {
        tereOnColor =
            new Color(tereDefOnColor.r, tereDefOnColor.g, tereDefOnColor.b,
            alphaFloat);

        //DOTween.To(() => tereOnColor, (x) => tereOnColor = x
        //, new Color(tereDefOnColor.r, tereDefOnColor.g, tereDefOnColor.b,
        //    alphaFloat)
        //    , durationTime);


    }
    #endregion

    #region ループモーション群
    public float kutipakuTimerFloat;
    public string kutipakuString = "口パク";
    void Kutipaku()
    {
        //口パクタイマー
        if (kutipakuTimerFloat > 0) { kutipakuTimerFloat -= 1 * Time.deltaTime; }

        //タイマー0以上でハッシュが口パク以外だったら 口パクする
        if (kutipakuTimerFloat > 0 && girlAnim.GetCurrentAnimatorStateInfo(3).IsName(kutipakuString) == false)
        { ChieriMotion(kutipakuString, 0, 3); }

        //タイマー0以下でハッシュが_noData以外だったら 口パク止める
        else if (kutipakuTimerFloat <= 0 && girlAnim.GetCurrentAnimatorStateInfo(3).IsName("_noData") == false)
        {
            //Durationをかけるとハッシュが口パク以外のまま連続で命令送り続けてしまうので
            //0フレで
            ChieriMotion("_noData", 0f, 3);
        }

        ////今まで閉じっぱなしだったので、閉じておきたい場合はm_defに（口とじ）
        //else if (kutipakuTimerFloat <= 0 && girlAnim.GetCurrentAnimatorStateInfo(3).IsName("m_def") == false)
        //{
        //    ChieriMotion("m_def", 0f, 3);
        //}
    }

    IEnumerator EyeBlinkIEnum;
    bool
        isEyeBlink = false,//智恵理Activeがオンの場合勝手にtrueになるので、
        isEyeBlinkAuto = true;//強制で止めたい場合はこちらと一緒にfalse
    IEnumerator EyeBlinkCor()
    {
        //Debug.Log("まばたきスタート");
        //目を瞑っているときはまばたきしない
        /*
        if (anim.GetCurrentAnimatorClipInfo(2)[0].clip.name != "笑顔01口眉" &&
            anim.GetCurrentAnimatorClipInfo(2)[0].clip.name != "はー終った" &&
            anim.GetCurrentAnimatorClipInfo(2)[0].clip.name != "ん～"
            )//今は表情名で監視してるが、表情モーフ確定してきたら直接目の瞑り具合を見たほうがよさそう
            */
        //↓そうした

        isEyeBlink = true;
        float randomWait = 0;
        while (isEyeBlink)
        {
            if (isEyeBlinkAuto)//オートがONなら
            {
                //ポーズ時以外に、EYE_Smile(0)・Sleep(4)が20以下の場合のみ瞬きする。(若干閉じ目でもまばたきしなくなる)
                if (timeScale == 0 ||
                    EYE_def.GetBlendShapeWeight(0) >= 20 ||
                    EYE_def.GetBlendShapeWeight(4) >= 20)
                { }
                else
                {
                    blinkTime += (1 * Time.deltaTime) * girlAnim.speed;

                    if (UnityEngine.Random.value > 0.996)
                    {
                        ChieriMotion("b_まばたきSlow用", 0f, 4);
                        blinkTime = 0;
                    }
                    //4秒経ったら高確率で
                    if (UnityEngine.Random.value > 0.984 && blinkTime > 4)
                    {
                        ChieriMotion("b_まばたきSlow用", 0f, 4);
                        blinkTime = 0;
                    }

                    //■アニメスピード遅いときは毎フレ抽選しないように（例えばスピードが0.5なら1フレ待つ）
                    randomWait += girlAnim.speed;
                    while (randomWait <= 1)
                    {
                        randomWait += girlAnim.speed;
                        yield return null;
                    }
                    randomWait = 0;
                }
            }
            yield return null;
        }

        yield break;
    }

    bool isDeskSyukudaiKeshigomMotion = false;//タイムライン上でONOFF用
    void DeskSyukudaiTaiki()//デスク宿題モーション中消しゴム
    {
        if (isGirlAnimReadSystem || Input.GetKeyDown(KeyCode.G))
        {
            #region 宿題モーション時にランダムで消しゴムモーション発動
            if (girlAnim.GetCurrentAnimatorClipInfo(0).Length != 0)//空の時エラーはかないように
            {
                if (isDeskSyukudaiKeshigomMotion && //オフ時は発動しない（始まっていたら処理はするようにここで判定）
                    girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "デスク宿題待機" &&
                    UnityEngine.Random.value > 0.9998 ||
                    Input.GetKeyDown("x")//デバッグXキー発動
                    )
                {
                    ChieriMotion("デスク消しゴム", 0.5f, 0);
                }

                //ペン離す
                if (girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "デスク消しゴム" &&
                    girlAnimNomPrevTime < 0.18f && girlAnimNomTime >= 0.18f)
                {
                    //ペン置く
                    SharpenObj.transform.SetParent(RoomTrs);
                    GameObject tmpObj = (GameObject)Resources.Load("_PosObj/D_Henai_Day1/Sharpen_DeskOkuTrsPosObj");
                    SharpenObj.transform.localPosition = tmpObj.transform.localPosition;
                    SharpenObj.transform.localEulerAngles = tmpObj.transform.localEulerAngles;
                }

                //消しゴム持つ
                if (girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "デスク消しゴム" &&
                    girlAnimNomPrevTime < 0.35f && girlAnimNomTime >= 0.35f)
                {
                    KeshigomuObj.transform.SetParent(GirlRhitosashi02Trs);
                    KeshigomuObj.transform.localPosition = Keshigomu_syukudai_GirlRhitosashi02_ParameterTrs.localPosition;
                    KeshigomuObj.transform.localEulerAngles = Keshigomu_syukudai_GirlRhitosashi02_ParameterTrs.localEulerAngles;
                }

                //消しゴム離す
                if (girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "デスク消しゴム" &&
                    girlAnimNomPrevTime < 0.72f && girlAnimNomTime >= 0.72f)
                {
                    //消しゴム置く
                    KeshigomuObj.transform.SetParent(RoomTrs);
                    GameObject tmpObj = (GameObject)Resources.Load("_PosObj/D_Henai_Day1/Keshigomu_DeskOkuPosObj");
                    KeshigomuObj.transform.localPosition = tmpObj.transform.localPosition;
                    KeshigomuObj.transform.localEulerAngles = tmpObj.transform.localEulerAngles;
                }

                //ペン持つ
                if (girlAnim.GetCurrentAnimatorClipInfo(0)[0].clip.name == "デスク消しゴム" &&
                    girlAnimNomPrevTime < 0.8f && girlAnimNomTime >= 0.8f)
                {
                    SharpenObj.transform.SetParent(GirlRhitosashi02Trs);
                    SharpenObj.transform.localPosition = Sharpen_syukudai_GirlRhitosashi02_ParameterTrs.localPosition;
                    SharpenObj.transform.localEulerAngles = Sharpen_syukudai_GirlRhitosashi02_ParameterTrs.localEulerAngles;
                }

            }

            #endregion
        }
        else
        { StartCoroutine(GirlAnimReadSystem()); }
    }


    //未実装
    void MitumeTere()
    {
        //見つめカウンター　一定量（半ランダム）でこっち向く（気づく）

        //「ん？」少し動き固めて笑顔見詰め合う　この時目線外すとリセット　SyukudaiTaikiとめる

        //更に一定量で驚き顔で紅潮

        //「ちゃ、ちゃんと集中しなきゃだめだよ！」　ガーッと宿題

        //時間かけて戻る
    }

    #endregion

    #region//（バグだっただけっぽいので一旦ボツ）手レイヤー モーションとレイヤーウェイト同時変更
    //void HandAnim(string stateName, float transitionDuration, float toLayerWeight)
    //{ StartCoroutine(HandAnimCor(stateName, transitionDuration, toLayerWeight)); }
    //IEnumerator HandAnimCor(string stateName, float transitionDuration, float toLayerWeight)
    //{
    //    
    //    //宣言　現在値取得
    //    float tempNowLayerWeight = girlAnim.GetLayerWeight(5);

    //    //まず普通にクロスフェード開始
    //    ChieriMotion(stateName, transitionDuration, 5);

    //    //同時にウェイト値を同じ時間かけて処理していく
    //    DOTween.To(() => tempNowLayerWeight, (x) => tempNowLayerWeight = x, toLayerWeight, transitionDuration);
    //    while (tempNowLayerWeight != toLayerWeight)
    //    {
    //        girlAnim.SetLayerWeight(5, tempNowLayerWeight);
    //        yield return null;
    //    }

    //    
    //}
    #endregion
    #endregion

    #region Ray関係 視線サークルにヒットした時用メソッド

    public float
        seeNomFlt,
        seeHeadNomFlt,
        seeSpineNomFlt,
        seeRFootNomFlt,
        seePantsNomFlt;


    //nearSizeAjust//距離に関係なくカメラにとって同じ大きさにする
    public void nearSizeAjust(Transform trs, float baseDistance)
    {
        Vector3 toward = VRCameraTrs.position - trs.position;

        trs.localScale = Vector3.one * (Vector3.Dot(toward.normalized, VRCameraTrs.forward) * toward.magnitude / baseDistance) * -1;

        //Vector3.Dot　は　内積（難しい）
    }


    #endregion

    #region FinalIK
    IEnumerator killAll_FainalIK()
    {
        //LookAtIK
        LAIKHeadS.headWeight =
        LAIKHeadS.eyesWeight =
        LAIKHeadS.bodyWeight =
        LAIKEyeS.headWeight =
        LAIKEyeS.eyesWeight =
        LAIKEyeS.bodyWeight =
        LAIKBodyS.headWeight =
        LAIKBodyS.eyesWeight =
        LAIKBodyS.bodyWeight = 0;

        //FinalIK
        IKBodyEf.positionWeight =
        IKBodyEf.rotationWeight =
        IKLHandEf.positionWeight =
        IKLHandEf.rotationWeight =
        IKLShoulderEf.positionWeight =
        IKLShoulderEf.rotationWeight =
        IKRHandEf.positionWeight =
        IKRHandEf.rotationWeight =
        IKRShoulderEf.positionWeight =
        IKRShoulderEf.rotationWeight =
        IKLFootEf.positionWeight =
        IKLFootEf.rotationWeight =
        IKLThighEf.positionWeight =
        IKLThighEf.rotationWeight =
        IKRFootEf.positionWeight =
        IKRFootEf.rotationWeight =
        IKRThighEf.positionWeight =
        IKRThighEf.rotationWeight = 0;

        //CCDIK(遅延でやる羽目になってるのがまず間違いなので見直しする)
        yield return new WaitForSeconds(0.2f);
        CCDIKRUpperArmSBone.weight =
        CCDIKRForearmSBone.weight =
        CCDIKRHandSBone.weight =
        CCDIKLUpperArmSBone.weight =
        CCDIKLForearmSBone.weight =
        CCDIKLHandSBone.weight = 0;


        #region//Player

        //LookAtIK
        PlayerLAIKHeadS.headWeight =
        PlayerLAIKHeadS.eyesWeight =
        PlayerLAIKHeadS.bodyWeight =
        PlayerLAIKEyeS.headWeight =
        PlayerLAIKEyeS.eyesWeight =
        PlayerLAIKEyeS.bodyWeight =
        PlayerLAIKBodyS.headWeight =
        PlayerLAIKBodyS.eyesWeight =
        PlayerLAIKBodyS.bodyWeight = 0;

        //FinalIK
        PlayerIKBodyEf.positionWeight =
        PlayerIKBodyEf.rotationWeight =
        PlayerIKLHandEf.positionWeight =
        PlayerIKLHandEf.rotationWeight =
        PlayerIKLShoulderEf.positionWeight =
        PlayerIKLShoulderEf.rotationWeight =
        PlayerIKRHandEf.positionWeight =
        PlayerIKRHandEf.rotationWeight =
        PlayerIKRShoulderEf.positionWeight =
        PlayerIKRShoulderEf.rotationWeight =
        PlayerIKLFootEf.positionWeight =
        PlayerIKLFootEf.rotationWeight =
        PlayerIKLThighEf.positionWeight =
        PlayerIKLThighEf.rotationWeight =
        PlayerIKRFootEf.positionWeight =
        PlayerIKRFootEf.rotationWeight =
        PlayerIKRThighEf.positionWeight =
        PlayerIKRThighEf.rotationWeight = 0;

        //CCDIK(遅延でやる羽目になってるのがまず間違いなので見直しする)
        yield return new WaitForSeconds(0.2f);
        PlayerCCDIKRUpperArmSBone.weight =
        PlayerCCDIKRForearmSBone.weight =
        PlayerCCDIKRHandSBone.weight =
        PlayerCCDIKLUpperArmSBone.weight =
        PlayerCCDIKLForearmSBone.weight =
        PlayerCCDIKLHandSBone.weight = 0;

        #endregion
    }

    //智恵理の手足位置取得してターゲットに
    bool isGirlPosToIKTargetPosRotLoading = false;
    public void GirlPosToIKTargetPosRot()
    {
        isGirlPosToIKTargetPosRotLoading = true;
        FixedAction(() =>
        {
            IKRHandTargetTrs.position = GirlRHandTrs.position;
            IKRHandTargetTrs.rotation = GirlRHandTrs.rotation;
            IKLHandTargetTrs.position = GirlLHandTrs.position;
            IKLHandTargetTrs.rotation = GirlLHandTrs.rotation;

            IKRFootTargetTrs.position = GirlRFootTrs.position;
            IKRFootTargetTrs.rotation = GirlRFootTrs.rotation;
            IKLFootTargetTrs.position = GirlLFootTrs.position;
            IKLFootTargetTrs.rotation = GirlLFootTrs.rotation;

            isGirlPosToIKTargetPosRotLoading = false;
        });
    }
    #endregion

    #region TimeLine

    //■イベントムーブ
    public void EventMove()
    { StartCoroutine(EventMove(DB.nowEventNum + 1, null, false)); }//オーバーロード
    public void EventMove(int evMoveNumInt)
    { StartCoroutine(EventMove(evMoveNumInt, null, false)); }//オーバーロード
    public void EventMove(int evMoveNumInt, bool isDebug, bool isForceSceneLoad = false)
    { StartCoroutine(EventMove(evMoveNumInt, null, isDebug, isForceSceneLoad)); }//オーバーロード
    public void EventMove(string setEventKey, bool isDebug, bool isForceSceneLoad = false)
    { StartCoroutine(EventMove(1, setEventKey, isDebug, isForceSceneLoad)); }//オーバーロード
    public void EventMove(string setEventKey)
    { StartCoroutine(EventMove(1, setEventKey, false)); }//オーバーロード
    bool isEventMove = false;//重複阻止用
    IEnumerator EventMove(int evMoveNumInt, string setEventKey, bool isDebug, bool isForceSceneLoad = false)//イベント移動（引数でデバッグや移動するステージ指定）
    {
        if (isEventMove) { yield break; }
        isEventMove = true;

        //boolでイベントが走るのを止める（初期化が終ったらつける）
        isEvRun = false;
        DB.nowEventNum = evMoveNumInt;
        sentakuListNum = 99;//選択肢ナンバーデフォルトへ
        eventMoveFlag = true;
        if (isDebug == true) { debugEventMoveFlag = true; }

        #region 一時Objのサウンドオブジェだけ先に削除（フェードアウトさせるため）

        //サウンドObjがあったら、DontDestroyにペアレントしてMuteして削除
        for (int i = 0; i < DB.evMoveDelObjList.Count; i++)
        {
            if (DB.evMoveDelObjList[i] != null)
            {
                if (DB.evMoveDelObjList[i].tag == "SoundObj")
                {
                    GameObject tmpObj = DB.evMoveDelObjList[i];
                    tmpObj.transform.SetParent(DontDestroySoundObjsTrs);
                    //1秒フェードアウト後削除
                    tmpObj.GetComponent<AudioSource>().DOFade(0, 1)
                        .OnComplete(() => { DestroyImmediate(tmpObj, true); });

                    DB.evMoveDelObjList.RemoveAt(i);//時間差削除するので削除リストから外す。
                }
            }
        }

        #endregion

        #region フローチャート移動時のフェードや音演出　設定（2秒取る）
        Image FadeBlackSceneMoveCanvasImage = GameObject.Find("FadeBlackSceneMoveCanvasImage").GetComponent<Image>();
        if (isFlowChartEventMove)
        {
            //シーン移動用のFade
            fadeBlackSceneMoveCanvasImageTweener
                = FadeBlackSceneMoveCanvasImage.DOFade(1, 2);

            //NewFadeBlackのもの
            //FadeBlack(1, 2, true);

            //環境音フェードアウト
            KankyouBGMVolumer(0f, 2f);
            //スピーカーフェードアウト
            DOTween.To(() => speaker.audioSource.volume, (x) => speaker.audioSource.volume = x,
                0f, 2f);

            yield return new WaitForSeconds(2);

            //シーン移動用のフェードがかかったので、内部のフェードを0に（フェード明けさせないシーンなどあるので）
            FadeBlack(0, 0);
            yield return null;


            #region 暗幕処理
            //カメラアンカー設定デフォルトに（リセット用の値をデフォルトに）
            DB.cameraAnchorResetLocalPos = DB.cameraStandAnchorDefLocalPos;
            DB.cameraAnchorResetLocalRot = Vector3.zero;

            //Followが残るので、クリアを挟む
            FollowDOMoveFromTrsList.Clear();
            //大丈夫かまだわからないけど、色々残留するのでkillAll
            DOTween.KillAll();


            //プレイヤーダミー調整していた時用にリセット
            PlayerFBBIKtoHeadEffectorObj.transform.localPosition =
            PlayerFBBIKtoHeadEffectorObj.transform.localEulerAngles = Vector3.zero;

            //ポニーMat
            PonyTrs.GetComponent<Renderer>().material = ponyDefMat;


            #endregion
        }
        #endregion

        #region 一時Obj(DB.evMoveDelObjList)削除処理
        //HwSシステム終了（コリダーリストがObj含んでいることあるため）
        if (isHwSimpleSystem) { isHwSimpleSystem = false; }

        //削除
        for (int i = 0; i < DB.evMoveDelObjList.Count; i++)
        {
            if (DB.evMoveDelObjList[i] != null)
            { DestroyImmediate(DB.evMoveDelObjList[i], true); }
        }
        DB.evMoveDelObjList.Clear();


        #endregion


        #region イベント中一時的コルーチン実行してたらストップ
        if (nowRunEvCoroutine != null) { StopCoroutine(nowRunEvCoroutine); }//イベントコルーチン実行時にストップ
        if (evTempCoroutine != null) { StopCoroutine(evTempCoroutine); }//イベント中一時的コルーチン実行してたらストップ
        if (nowRunEvIEnumerator != null) { nowRunEvIEnumerator = null; }//イベント中断用コルーチン実行してたらストップ
        //yield return nowRunEvIEnumerator != null ? null :nowRunEvIEnumerator;↑と同じ内容？

        //フリーモード解除
        isFreeCameraModeSystem = false;

        #endregion 

        //evsのキー名からindexナンバー取得し、DB.nowEventNoへ
        if (setEventKey != null)//名前指定があれば
        {
            for (int i = 0; i < evs.Count; i++)
            {
                //上から順にイベント名と一致するか調べて、一致したらそのインデックス番号代入
                if (evs.Skip(i).First().Key == setEventKey)
                    DB.nowEventNum = i;
            }
        }

        //SmartPhoneVisLockBool = false;//スマホロック解除

        #region デバッグ移動bool true時
        if (debugEventMoveFlag == true)
        {
            //DOTween用IKリスト　IKEf、LAIKSのDictクリア
            FollowDOMoveFromTrsList.Clear();
            IKEfPosTweenerDict.Clear();
            IKEfRotTweenerDict.Clear();
            LAIKSHeadTweenerDict.Clear();
            LAIKSEyesTweenerDict.Clear();
            LAIKSBodyTweenerDict.Clear();

            ////そしてDOTweenを全部クリア（不具合起こすのでなし）（シーン移動フェードなどが止まる）
            //DOTween.Clear();


            //デバッグ移動の場合IK系一旦切る
            StartCoroutine(killAll_FainalIK());

            //分岐待機用の変数群もリセット
            bunkiTaikiBool01
                = bunkiTaikiBool02
                = false;
            bunkiTaikiFloat01 = 0;

            //イベント用コルーチン停止
            //自動初期化・終了処理つきのものはboolで行っている。
            if (isKOSystem == true) { isKOSystem = false; }
            if (KO_chieriSerchCorBool == true) { KO_chieriSerchCorBool = false; }
            if (isANSystem == true) { isANSystem = false; }
            if (isKBSystem == true) { isKBSystem = false; }
            if (isTansakuSystem == true) { isTansakuSystem = false; }

            //システム終了用に1フレ
            yield return null;

            //アニメーションスピード1;
            girlAnim.speed = 1f;
            doorAnim.speed = 1f;
            chairAnim.speed = 1f;
            //表情デフォルトへ
            ChieriMotion("_noData", 0, 2, 0);
            //手デフォルト
            ChieriMotion("_noData", 0, 5, 0);
            //口デフォルト
            ChieriMotion("_noData", 0, 3, 0);
            //汗　照れ消し
            AseTare(false);
            TereHoho(false, 0);

            //ペアレント全部デフォルト
            CameraObjectsTrs.SetParent(GameObjectsTrs);
            IKRHandTargetTrs.SetParent(GirlIKTargetsTrs);
            IKLookAtEyeTargetTrs.SetParent(GirlIKTargetsTrs);
            IKLookAtHeadTargetTrs.SetParent(GirlIKTargetsTrs);

            //ペン置く
            SharpenObj.transform.SetParent(RoomTrs);
            SharpenObj.transform.localPosition = Sharpen_table_Room_ParameterTrs.localPosition;
            SharpenObj.transform.localEulerAngles = Sharpen_table_Room_ParameterTrs.localEulerAngles;
            //消しゴム置く
            KeshigomuObj.transform.SetParent(RoomTrs);
            KeshigomuObj.transform.localPosition = Keshigomu_table_Room_ParameterTrs.localPosition;
            KeshigomuObj.transform.localEulerAngles = Keshigomu_table_Room_ParameterTrs.localEulerAngles;

            //フキダシ消し
            DelAll_Hukidashi();
            //選択肢消し
            DelAll_Sentakushi();
            //一時保持選択肢Listクリア
            sentakushiTempLogList.Clear();
            //hukiPointの判定範囲デフォルトへ
            hukiPointMoveFaceWeightUpFloat = hukiPointMoveFaceWeightDownFloat = 0;
            //演出で選択肢後フキダシ消さないようにしていたら戻す
            if (sentakushiEndHukidashiEraseBool == false) { sentakushiEndHukidashiEraseBool = true; }

            //サブタイ消し
            SubTitleVis(false, 0);
            //右下文字消し


            //一応智恵理ゼロ位置へ（なぜかモーション中に切り替えると位置が変わったりするので）
            GirlTrs.rotation = Quaternion.Euler(0, 0, 0);//デバッグ用回転位置セット
            GirlTrs.localPosition = new Vector3(0, 0, 0);//デバッグ用位置セット
                                                         //智恵理0位置ロック
            DB.isChieriPosLock = true;

            #region //フェード前設定(シーンチェンジ用のFadeのおかげでいらなくなったっぽい)
            ////FadeWhite(1, 0);
            //FadeBlack(1, 0);

            //////■■イベントがFade開幕のステージだった場合はFade切らない
            ////if (
            ////    evs[DB.nowEventNum].Key == "タイトル" ||
            ////    evs[DB.nowEventNum].Key == "環境設定" ||
            ////    evs[DB.nowEventNum].Key == "メガネ外してチュートリアル" ||
            ////    evs[DB.nowEventNum].Key == "2-3ブリッジ開始 そろそろ気付いたかな" ||
            ////    evs[DB.nowEventNum].Key == "大大偏愛" ||
            ////    evs[DB.nowEventNum].Key == "予告 ベッドの下" ||
            ////    evs[DB.nowEventNum].Key == "予告 転送都市" ||
            ////    evs[DB.nowEventNum].Key == "予告 行ってきます" ||
            ////    evs[DB.nowEventNum].Key == "予告開始" ||
            ////    evs[DB.nowEventNum].Key == "予告終了" ||
            ////    evs[DB.nowEventNum].Key == "カラーテスト01" ||
            ////    evs[DB.nowEventNum].Key == "カラーテスト02"
            ////    )
            ////{ }
            ////else
            ////{
            ////    //フェードオフ
            ////    FadeWhite(0, 0);
            ////    FadeBlack(0, 0);
            ////}

            ////↑一旦やめて必ずフェードオフ
            //FadeWhite(0, 0);
            //FadeBlack(0, 0);
            #endregion

        }
        #endregion

        #region イベント移動時にクリアー関係

        //目IKClamp戻し
        LAIKEye.solver.clampWeightEyes = DB.defLAIKEyeClamp;

        //IKターゲットペアレント戻し
        IKRHandTargetTrs.SetParent(GirlIKTargetsTrs);
        IKLookAtEyeTargetTrs.SetParent(GirlIKTargetsTrs);
        IKLookAtHeadTargetTrs.SetParent(GirlIKTargetsTrs);
        IKLookAtBodyTargetTrs.SetParent(GirlIKTargetsTrs);

        //宿題移動バー発光させないBool戻し
        isTutorial = false;
        isHwClearEventWait = false;

        //肩とひじのツイスト機能をIKをON時にオフする機能　をオフ
        isKataTwistAuto = true;

        //AN起動時のプレイヤーモーション（回転や手IKなども）をONに
        isPlayerANRotate = true;

        #endregion

        #region シーンをDBから読み取り、適用

        //シーン移動したか判定用（シーン移動の場合削除するObjリストなど用）
        bool isSceneLoad = false;

        //コマデータからシーン情報取得（判定をDBリストからコマデータに移行）
        var tmpEnumScene
            = flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().scene;

        //デバッグ移動や強制（フローチャート移動など）の場合は同じでも強制でロード
        if (tmpEnumScene == DataBridging.enumScene.指定無し)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                MoveScene(SceneManager.GetActiveScene().name, true);
                isSceneLoad = true;
            }
        }
        else if (tmpEnumScene == DataBridging.enumScene.Hiru)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                //セミに変え
                KankyouBGMChanger(semiSE.audioSource, "minminzemi-cry1");

                MoveScene("TH_Hiru", true);
                isSceneLoad = true;
            }
            else
            { MoveScene("TH_Hiru"); }
        }
        else if (tmpEnumScene == DataBridging.enumScene.夕方)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                //ヒグラシに変え
                KankyouBGMChanger(semiSE.audioSource, "Higurashi_nc104892_間追加");

                MoveScene("TH_Yugata", true);
                isSceneLoad = true;
            }
            else
            { MoveScene("TH_Yugata"); }
        }
        else if (tmpEnumScene == DataBridging.enumScene.夜)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                //夜虫に変え
                KankyouBGMChanger(semiSE.audioSource, "musi2_loop");

                MoveScene("TH_Yoru", true);
                isSceneLoad = true;
            }
            else
            { MoveScene("TH_Yoru"); }
        }
        else if (tmpEnumScene == DataBridging.enumScene.深夜)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                //夜虫に変え
                KankyouBGMChanger(semiSE.audioSource, "musi2_loop");

                MoveScene("TH_Shinya", true);
                isSceneLoad = true;
            }
            else
            { MoveScene("TH_Shinya"); }
        }
        else if (tmpEnumScene == DataBridging.enumScene.あさ)
        {
            if (DB.isDebugEventChange || isForceSceneLoad)
            {
                DB.isDebugEventChange = false;
                MoveScene("TH_Asa", true);
                isSceneLoad = true;
            }
            else
            { MoveScene("TH_Asa"); }
        }
        #endregion

        #region シーンロードとなった場合、削除するObjリスト（DB.sceneMoveDelObjList）処理

        if (isSceneLoad)
        {
            //削除
            for (int i = 0; i < DB.sceneMoveDelObjList.Count; i++)
            {
                if (DB.sceneMoveDelObjList[i] != null)
                { DestroyImmediate(DB.sceneMoveDelObjList[i], true); }
            }
            DB.sceneMoveDelObjList.Clear();
        }

        #endregion

        //プレイヤー風切り音ミュートしてたらOFF
        //if (playerWindAudioSource.mute) { playerWindAudioSource.mute = false; }

        //↑（RigidBody監視システム起動してないと変数取得されてないので、GetComponent）
        if (SounderTrs.Find("PlayerWindSoundObj").GetComponent<AudioSource>().mute)
        { SounderTrs.Find("PlayerWindSoundObj").GetComponent<AudioSource>().mute = false; }


        //時計合わせ
        if (isClockSystem) { SetClockHourMinute(); }

        //プレイヤーダミーボディ表示Boolオフ
        isDummyBodyVis = isDummyHandVis = false;


        //データロードされてなければデータロード処理（デバッグ時でしか有り得ないはず）。データロードシーン以外ならそのまま開始。
        if (evs[DB.nowEventNum].Key != "ユーザーデータチェックとロード" &&
            DB.isSaveDataLoad == false)
        { StartCoroutine(LoadUserData()); }

        #region シーン移動用のFade（暗かったら消す。という仕様）
        if (FadeBlackSceneMoveCanvasImage.color.a > 0)
        {
            if (fadeBlackSceneMoveCanvasImageTweener != null) { fadeBlackSceneMoveCanvasImageTweener.Kill(); }
            fadeBlackSceneMoveCanvasImageTweener =
            FadeBlackSceneMoveCanvasImage.DOFade(1, 0)
            .OnComplete(() =>
            {
                if (fadeBlackSceneMoveCanvasImageTweener != null) { fadeBlackSceneMoveCanvasImageTweener.Kill(); }
                fadeBlackSceneMoveCanvasImageTweener =
                    FadeBlackSceneMoveCanvasImage.DOFade(1, 1)
                .OnComplete(() =>
                {
                    if (fadeBlackSceneMoveCanvasImageTweener != null) { fadeBlackSceneMoveCanvasImageTweener.Kill(); }
                    fadeBlackSceneMoveCanvasImageTweener =
                            FadeBlackSceneMoveCanvasImage.DOFade(0, 2);
                });
            });
        }
        #endregion

        ////NewFadeBlackのUIFront
        //FadeBlack(0, 2, true);


        //移動先イベントのコマデータにPlayerVisを
        flowChartKomaDataObjList[DB.nowEventNum].GetComponent<FlowChartKoma>().isPlayerVisFlag = true;

        //メニューのロックを解除
        isMenuLock = false;


        //引数なしでそのコマ指定のBGM（コマに指定無しなら無音になる）
        if (true) { BGMPlay(); }


        //boolをtrueに
        isEvRun = true;

        //オートセーブ(ユーザーデータロードや、セーブしないシーンじゃなければ)
        if (evs[DB.nowEventNum].Key != "ユーザーデータチェックとロード")
        { Save(); }

        //フローチャート移動フラグ解除
        isFlowChartEventMove = false;

        //VR時はトラッキングON
        if (XRSettings.enabled)
        { InputTracking.disablePositionalTracking = false; }

        //Resources.Load()で読み込んだデータは、そのデータを使用していたオブジェクトが削除されても、再利用する時のためにキャッシュに残る仕組みになっているようです。
        //このメソッドは、現在キャッシュに残っていて使用していないアセットを破棄してくれます。
        Resources.UnloadUnusedAssets();

        isEventMove = false;



        yield break;
    }
    Tweener fadeBlackSceneMoveCanvasImageTweener;//シーンフェードのTweener（タイトルでキャンセルしたいので）

    //■イベントリセット
    void EventReset() { EventReset(60); }//↓の時間指定しない場合のオーバーロード
    void EventReset(float setEvTimerMax)//イベント移動時の初期化処理（移動してからイベント名等々を取得するため↑とまとめない）
    {
        if (DB.isDebugMode) { EvNameText.text = evs[DB.nowEventNum].Key; }//デバッグ用タイトル表示

        debugEventMoveFlag = false;//デバッグ移動フラグ消し
        eventMoveFlag = false;
    }

    //■タイムポーズ・スキップシステム
    public bool
        isGamePause = false,
        isUserGamePause = false,
        isNowSkip = false,
        isNowSoSkip = false,
        isSkipLock = false;
    public float
        beforeTimeScale,
        skipCountFloat,
        soSkipCountFloat,
        pauseTimeScaleFloat = 0,
        skipTimeScaleFloat = 5,
        soSkipTimeScaleFloat = 20;
    public float
        beforeFixedTimeStep;
    //本体
    void TimeControlSystem()
    {
        //timeScale変数用意
        Time.timeScale = timeScale;

        //■ひとまず通常状態のTimeScale取得しておく。（スキップやポーズ復帰時に元に戻るように）
        //タイムスケールが変わっていて、ストップ・スキップ速度じゃなければbeforeに保持
        if (beforeTimeScale != timeScale &&
            timeScale != pauseTimeScaleFloat &&
            timeScale != skipTimeScaleFloat &&
            timeScale != soSkipTimeScaleFloat)
        {
            beforeTimeScale = timeScale;
            beforeFixedTimeStep = Time.fixedDeltaTime;
        }

        #region スキップbool操作（設定true・スキップロック解除時のみ）
        if (DB.isSkipMode == true && isSkipLock == false)
        {
            //キー長押しでスキップ
            if (Input.GetButton(DB.inputDict["右手"]) == true)
            { skipCountFloat += 1 * Time.unscaledDeltaTime; }
            //長押しカウントでスキップ判定
            if (skipCountFloat > 0.5f)
            { isNowSkip = true; }
            else { isNowSkip = false; }


            //キー長押しでSoスキップ
            if (isBack == true)
            { soSkipCountFloat += 1 * Time.unscaledDeltaTime; }
            //長押しカウントでSoスキップ判定 (スキップの方は止める)
            if (soSkipCountFloat > 0.5f)
            { isNowSoSkip = true; isNowSkip = false; }
            else { isNowSoSkip = false; }
        }

        //離した状態で0以上だったら0
        if (Input.GetButton(DB.inputDict["右手"]) == false
            && skipCountFloat > 0)
        { skipCountFloat = 0; }
        if (isBack == false
            && soSkipCountFloat > 0)
        { soSkipCountFloat = 0; }


        #endregion

        #region ■スキップ・ストップ・スキップロックそれぞれのbool判定による処理

        #region ポーズ判定（メニューやノベルログ時など）
        if (isDebugGamePause
            || isMenuGamePause
            || isNovelLogGamePause)
        {
            if (isGamePause == false) { isGamePause = true; }
        }
        else if (isGamePause
            && isDebugGamePause == false
            && isMenuGamePause == false
            && isNovelLogGamePause == false)
        {
            isGamePause = false;
        }
        #endregion


        //■■ポーズ時はいかなるスキップも効かずに止まる
        if (isGamePause == true && timeScale != pauseTimeScaleFloat)
        {
            timeScale = pauseTimeScaleFloat;
            //Time.fixedDeltaTime = beforeFixedTimeStep * pauseTimeScaleFloat;

            //右上に▯▯
            SkipPose01.color = Color.white;
            //SkipPose01.text = "▯▯";
            SkipPose01.text = "";

            //スカート揺れモノもポーズ
            skirtSpringManager.isPaused = true;

            //スキップ判定消し
            isNowSkip = isNowSoSkip = false;
        }

        //■■スキップ（ポーズじゃない・スキップロックかかってない前提）
        if (isGamePause == false && isSkipLock == false)
        {
            //スキップ状態でSoスキップじゃなければ　スキップ速度に
            if (isNowSkip == true && timeScale != skipTimeScaleFloat)
            {
                timeScale = skipTimeScaleFloat;
                Time.fixedDeltaTime = beforeFixedTimeStep * skipTimeScaleFloat;

                //右上に▷▷
                SkipPose01.color = Color.white;
                SkipPose01.text = "▷▷";
            }
            //Soスキップ状態
            else if (isNowSoSkip == true && timeScale != soSkipTimeScaleFloat)
            {
                timeScale = soSkipTimeScaleFloat;
                Time.fixedDeltaTime = beforeFixedTimeStep * soSkipTimeScaleFloat;

                //右上に▷▷▷
                SkipPose01.color = Color.white;
                SkipPose01.text = "▷▷▷";
            }
        }
        //■■スキップロックがきたら
        //bool外すだけ（快適性のためSoスキップのカウンターは保持）
        if (isSkipLock == true) { isNowSkip = isNowSoSkip = false; }

        //■通常状態
        //ポーズでもスキップでもない時は通常状態に
        if (isGamePause == false && isNowSkip == false && isNowSoSkip == false)
        {
            timeScale = beforeTimeScale;
            Time.fixedDeltaTime = beforeFixedTimeStep;

            //スカート揺れモノポーズ解除
            skirtSpringManager.isPaused = false;

            //右上なくし
            SkipPose01.color = new Color(1, 1, 1, 0);
            SkipPose01.text = "";
        }
        #endregion
    }

    //■ボタン操作の時のウェイト　フキダシ待ち
    IEnumerator KeyOrWait(float waitTime)
    {
        //■ボタン送りモードなら
        if (DB.isButtonWaitMode)
        {
            //■直前のセリフを探し出し　自動削除を止め　記号つけ
            //hukidasis内のセリフ全部に記号つけ
            for (int i = 0; i < hukidasis.Count; i++)
            {
                //nullじゃなければ
                if (hukidasis[i] != null)
                {
                    //■スキップ状態で"既読なら"即消去 次へ
                    if (isNowSkip == true || isNowSoSkip == true)
                    {
                        //既読オンリースキップでなければ既読でもスキップ
                        if (DB.isKidokuOnlySkip == false)
                        { goto ボタン待ち抜け; }
                        else if (DB.kidokuSerihuKeyList.Contains(hukidasis[i].name))
                        { goto ボタン待ち抜け; }
                    }
                    //次回既読スキップ用に、未読だったらListにKey追加
                    if (DB.kidokuSerihuKeyList.Contains(hukidasis[i].name) == false)
                    { DB.kidokuSerihuKeyList.Add(hukidasis[i].name); }

                    //ContentSizeFitterをオフにするとsizeDeltaが0になるので、1フレーム後に取得しオフにしたら適用
                    yield return null;
                    Vector2 tmpSizeDelta = hukidasis[i].transform.GetComponent<RectTransform>().sizeDelta;

                    //コンテンツサイズフィルターオフ
                    hukidasis[i].transform.GetComponent<ContentSizeFitter>().enabled = false;
                    hukidasis[i].transform.GetComponent<RectTransform>().sizeDelta = tmpSizeDelta;

                    //取得
                    TextMeshProUGUI tempText = hukidasis[i].transform.GetChild(0).GetComponent<TextMeshProUGUI>();

                    ////記号ついてなければつける
                    //if (tempText.text.IndexOf("ｎ") == -1)
                    //{ tempText.text += "<size=30><color=#FFFF00FF>▼</color></size>"; }

                    //記号つける ImageObj版
                    hukidasis[i].transform.GetChild(0).Find("ButtonTaikiImage").gameObject.SetActive(true);

                    //SHukidashiだった場合は待ってフキダシ消さない
                    if (tempText.text.IndexOf("★") > 0)
                    {
                        //なぜここにボタン待ち？
                        ////■ボタン待ちループ（スマホ出てる間は押せない） (スキップ状態では抜ける)
                        //while (ketteiDown == false ||
                        //    playerSmartPhoneVisBool == true)
                        //{
                        //    yield return null;

                        //    if (isNowSkip == true || isNowSoSkip == true) { goto ループ抜け; }
                        //}
                        //ループ抜け:


                        //記号消す ImageObj版
                        hukidasis[i].transform.GetChild(0).Find("ButtonTaikiImage").gameObject.SetActive(false);

                        ////「▼」消して抜ける
                        //tempText.text
                        //    = tempText.text.Replace("<size=30><color=#FFFF00FF>▼</color></size>", "");


                        yield break;
                    }

                    ////■スキップロック ＆ 消滅時にスキップロック解除のスクリプト埋め込み
                    //skipLockBool = true;
                    //hukidasis[i].AddComponent<HukidashiOnDestroySkipLockFalse>();

                }
            }
            //自動削除コルーチンを止め（List化してあるのを全部止め）
            for (int i = 0; i < hukidashiAutoDelCoroutineList.Count; i++)
            { StopCoroutine(hukidashiAutoDelCoroutineList[i]); }

            //リストクリア
            hukidashiAutoDelCoroutineList.Clear();

            //■ボタン待ちループ （ポーズ中は押せない）
            while (isKetteiDown == false ||
            isGamePause == true)
            { yield return null; }

            ボタン待ち抜け:

            //フキダシ全消し
            DelAll_Hukidashi();

            //口パク止め
            kutipakuTimerFloat = 0;


            //なぜここでスキップOFF?
            ////スキップOFF
            //isNowSkip = false;

            yield return new WaitForSeconds(0.2f);
        }

        //■ボタン送りモードでないなら
        else
        {
            //指定された時間待つ
            yield return new WaitForSeconds(waitTime);
        }

    }

    #endregion

    #region DOTween補助・省略
    #region FollowDOMove 基本はTransformと場所指定 LocalMoveは命令にメソッド名にLocalをつけてオーバーロードで
    //オーバーロードの値のデフォルト値宣言
    private float defFollowDOMoveTime = 0.5f;
    private Ease defFollowDOMoveEase = Ease.OutQuad;

    public void FollowDOMove(Transform fromTrs, Transform toTrs)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, time, defFollowDOMoveEase, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, time, ease, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, time, Ease.OutQuad, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, time, ease, false)); }
    public void FollowDOMove(Transform fromTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(Transform fromTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, time, Ease.OutQuad, false)); }
    public void FollowDOMove(Transform fromTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(Transform fromTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, time, ease, false)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, time, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, Vector3.zero, time, ease, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, time, Ease.OutQuad, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, toTrs, toAddV3, time, ease, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, time, Ease.OutQuad, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(Transform fromTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(0f, fromTrs, ServerTrs, toAddV3, time, ease, true)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, time, defFollowDOMoveEase, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, time, ease, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, time, Ease.OutQuad, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, time, ease, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, time, Ease.OutQuad, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, ease, false)); }
    public void FollowDOMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, time, ease, false)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, time, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, Vector3.zero, time, ease, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, time, Ease.OutQuad, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, toTrs, toAddV3, time, ease, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, defFollowDOMoveEase, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, float time)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, time, Ease.OutQuad, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, defFollowDOMoveTime, ease, true)); }
    public void FollowDOLocalMove(float delayTimeFloat, Transform fromTrs, Vector3 toAddV3, float time, Ease ease)
    { StartCoroutine(FollowDOMoveCoroutine(delayTimeFloat, fromTrs, ServerTrs, toAddV3, time, ease, true)); }

    //同じTrsで命令来たら切り替える用
    public List<Transform> FollowDOMoveFromTrsList = new List<Transform>();

    //FixedでTrsのPos取得する用
    public OrderedDictionary<Transform, Vector3>
        FollowDOMoveFixedPosDict = new OrderedDictionary<Transform, Vector3>();
    //ToTrsの総数と中身管理用（ここからなくなればDictから消したり）
    public List<Transform> FollowDOMoveToTrsList = new List<Transform>();

    //本体
    IEnumerator FollowDOMoveCoroutine(float delayTimeFloat, Transform fromTrs, Transform toTrs, Vector3 toAddV3, float time, Ease ease, bool localBool)
    {
        //delayTimeFloatが指定されてたらウェイト
        if (delayTimeFloat != 0) { yield return new WaitForSeconds(delayTimeFloat); }

        //宣言
        Tweener tempTweener;//これを宣言して追記で繰り返さないとDOTweenが増え続ける
        Vector3 targetLastPos = Vector3.zero;//位置が変わるまでRestartしないように

        //Listに同じfromTrsがある間消し続ける。（if判定で一回だと複数同時に入れた時おかしくなった）
        while (FollowDOMoveFromTrsList.Contains(fromTrs) == true)
        {
            FollowDOMoveFromTrsList.Remove(fromTrs);
            yield return null;
        }
        //入れる
        FollowDOMoveFromTrsList.Add(fromTrs);
        FollowDOMoveToTrsList.Add(toTrs);//総数確認用

        #region TrsのPosをFixedUpdateで更新する

        //まずDictに既にあるかどうか //なければTrs登録
        if (FollowDOMoveFixedPosDict.ContainsKey(toTrs) == false)
        { FollowDOMoveFixedPosDict.Add(toTrs, toTrs.position); }

        //■ここから以前のTrsのポジションをそのまま使っていた状態と、ほぼ同じ処理
        //ワールドローカル切り替え
        if (localBool == false)
        {
            //ワールドの場合、GameObjectsサイズをかける(いらないかも)
            toAddV3 = toAddV3 * GameObjectsTrs.localScale.z;

            tempTweener = fromTrs.DOMove(FollowDOMoveFixedPosDict[toTrs] + toAddV3, time).SetEase(ease)
            .SetAutoKill(false);
            targetLastPos = FollowDOMoveFixedPosDict[toTrs] + toAddV3;
        }
        else
        {
            tempTweener = fromTrs.DOLocalMove(FollowDOMoveFixedPosDict[toTrs] + toAddV3, time).SetEase(ease)
                .SetAutoKill(false);
            targetLastPos = FollowDOMoveFixedPosDict[toTrs] + toAddV3;
        }

        //ListにfromTrsがある間 追い続ける //次の命令来たら1フレーム無くなるので抜ける
        while (FollowDOMoveFromTrsList.Contains(fromTrs) == true)
        {
            //ターゲットが移動した時だけ更新
            if (FollowDOMoveFixedPosDict[toTrs] + toAddV3 != targetLastPos)
            {
                tempTweener.ChangeEndValue(FollowDOMoveFixedPosDict[toTrs] + toAddV3, true)
                    .Restart();

                targetLastPos = FollowDOMoveFixedPosDict[toTrs] + toAddV3;
            }
            yield return null;
        }

        #region //以前のfixedActionを使っていた版
        ////まずUpdateでのPosと"違う"適当なPosを用意
        //Vector3
        //    fixedPos = toTrs.position,
        //    tmpPos = toTrs.position * 2 + Vector3.one;//違うならなんでもいいので*2+1

        ////改めてFixedで読み込み、
        //FixedAction(() =>
        //{ fixedPos = tmpPos = toTrs.position; });

        ////同じになったら抜ける
        //while (fixedPos != tmpPos) { yield return null; }
        ////FixedActionは結果が反映されるのがずれるのでこんなやり方


        ////■ここから以前のTrsのポジションをそのまま使っていた状態と、ほぼ同じ処理
        ////ワールドローカル切り替え
        //if (localBool == false)
        //{
        //    //ワールドの場合、GameObjectsサイズをかける(いらないかも)
        //    toAddV3 = toAddV3 * GameObjectsTrs.localScale.z;

        //    tempTweener = fromTrs.DOMove(fixedPos + toAddV3, time).SetEase(ease)
        //    .SetAutoKill(false);
        //    targetLastPos = fixedPos + toAddV3;
        //}
        //else
        //{
        //    tempTweener = fromTrs.DOLocalMove(fixedPos + toAddV3, time).SetEase(ease)
        //        .SetAutoKill(false);
        //    targetLastPos = fixedPos + toAddV3;
        //}

        ////ListにfromTrsがある間 追い続ける //次の命令来たら1フレーム無くなるので抜ける
        //while (FollowDOMoveFromTrsList.Contains(fromTrs) == true)
        //{
        //    //Fixedで読み込み
        //    FixedAction(() =>
        //    { fixedPos = toTrs.position; });

        //    //ターゲットが移動した時だけ更新
        //    if (fixedPos + toAddV3 != targetLastPos)
        //    {
        //        tempTweener.ChangeEndValue(fixedPos + toAddV3, true)
        //            .Restart();

        //        targetLastPos = fixedPos + toAddV3;
        //    }
        //    yield return null;
        //}
        #endregion

        #region //以前のTrsのポジションをそのまま使っていた版
        ////ワールドローカル切り替え
        //if (localBool == false)
        //{
        //    //ワールドの場合、GameObjectsサイズをかける(いらないかも)
        //    toAddV3 = toAddV3 * GameObjectsTrs.localScale.z;

        //    tempTweener = fromTrs.DOMove(toTrs.position + toAddV3, time).SetEase(ease)
        //    .SetAutoKill(false);
        //    targetLastPos = toTrs.position + toAddV3;
        //}
        //else
        //{
        //    tempTweener = fromTrs.DOLocalMove(toTrs.position + toAddV3, time).SetEase(ease)
        //        .SetAutoKill(false);
        //    targetLastPos = toTrs.position + toAddV3;
        //}

        ////ListにfromTrsがある間 追い続ける //次の命令来たら1フレーム無くなるので抜ける
        //while (FollowDOMoveFromTrsList.Contains(fromTrs) == true)
        //{
        //    //ターゲットが移動した時だけ更新
        //    if (toTrs.position + toAddV3 != targetLastPos)
        //    {
        //        //ためしにFixedActionしたらエラーが出たり出なかったりなので、やめ
        //        //FixedAction(() =>
        //        //{
        //        tempTweener.ChangeEndValue(toTrs.position + toAddV3, true)
        //            .Restart();

        //        targetLastPos = toTrs.position + toAddV3;
        //        //});

        //    }
        //    yield return null;
        //}
        #endregion

        #endregion

        //toTrsリストから今回のを一個消す（数を管理しているだけなので、ひとつ消せばOK）
        FollowDOMoveToTrsList.Remove(toTrs);
        //それがもし最後の一個で、リストからそのTrsがなくなったのなら //消す
        if (FollowDOMoveToTrsList.Contains(toTrs) == false)
        { FollowDOMoveFixedPosDict.Remove(toTrs); }

        //Debug.Log("FollowDOMoveToTrsList" + FollowDOMoveToTrsList.Count);
        //Debug.Log("FollowDOMoveFixedPosDict" + FollowDOMoveFixedPosDict.Count);

        //Tweener消す
        tempTweener.Kill();
        yield break;
    }
    #endregion

    #region//DOTweenToの省略用メソッド群 IKウェイト量を操作するために。floatとかは直打ちする(デリゲートはref参照できないので )
    //DictionaryでIKEfとTweenerを追加し、動作中に次の命令来た場合は該当Tweenerを止めて入れなおす仕様。

    //また、IKウェイトのValueを0にした時、そのIKTargetがFollowDOMoveしていたら消す(RotationはMoveしないのでなし)
    //※↑必要なのか若干思い出せない

    Dictionary<IKEffector, Tweener> IKEfPosTweenerDict = new Dictionary<IKEffector, Tweener>();
    public void DOTweenToIKEfPos(IKEffector fromToIKEf, float value, float time = 0.5f, Ease ease = Ease.OutQuad)
    {
        if (IKEfPosTweenerDict.ContainsKey(fromToIKEf) == true)//既にDictに動作中の今回のIKEfがあれば
        {
            //削除
            IKEfPosTweenerDict[fromToIKEf].Kill();
            IKEfPosTweenerDict.Remove(fromToIKEf);
        }

        //Dictに入れるTweener生成
        Tweener tmpIKEFPosTweener = null;
        //Dictに追加
        IKEfPosTweenerDict.Add(fromToIKEf, tmpIKEFPosTweener);

        //Dictに入れたTweenerの内容を設定
        IKEfPosTweenerDict[fromToIKEf] = DOTween.To(() => fromToIKEf.positionWeight, (x) => fromToIKEf.positionWeight = x
        , value
        , time)
        .SetEase(ease)
        .OnComplete(() => { IKEfPosTweenerDict.Remove(fromToIKEf); }//Tween終了したらDictから該当のIKEf項目を自動削除
        );

        //IKウェイトを0にした時、そのIKTargetがFollowDOMoveしていたら消す(RotationはMoveしないのでなし)
        if (value == 0) { StartCoroutine(DOTweenToZeroIKRemove(null, fromToIKEf, time)); }
    }

    Dictionary<IKEffector, Tweener> IKEfRotTweenerDict = new Dictionary<IKEffector, Tweener>();
    public void DOTweenToIKEfRot(IKEffector fromToIKEf, float value, float time = 0.5f, Ease ease = Ease.OutQuad)
    {
        if (IKEfRotTweenerDict.ContainsKey(fromToIKEf) == true)//既にDictに動作中の今回のIKEfがあれば
        {
            //削除
            IKEfRotTweenerDict[fromToIKEf].Kill();
            IKEfRotTweenerDict.Remove(fromToIKEf);
        }

        //Dictに入れるTweener生成
        Tweener tmpIKEFRotTweener = null;
        //Dictに追加
        IKEfRotTweenerDict.Add(fromToIKEf, tmpIKEFRotTweener);

        //Dictに入れたTweenerの内容を設定
        IKEfRotTweenerDict[fromToIKEf] = DOTween.To(() => fromToIKEf.rotationWeight, (x) => fromToIKEf.rotationWeight = x
        , value
        , time)
        .SetEase(ease)
        .OnComplete(() => { IKEfRotTweenerDict.Remove(fromToIKEf); }//Tween終了したらDictから該当のIKEf項目を自動削除
        );
    }


    Dictionary<IKSolverLookAt, Tweener> LAIKSHeadTweenerDict = new Dictionary<IKSolverLookAt, Tweener>();
    public void DOTweenToLAIKSHead(IKSolverLookAt fromToIKS, float value, float time, Ease ease = Ease.OutQuad)
    {
        if (LAIKSHeadTweenerDict.ContainsKey(fromToIKS) == true)//既にDictに動作中の今回のIKEfがあれば
        {
            //削除
            LAIKSHeadTweenerDict[fromToIKS].Kill();
            LAIKSHeadTweenerDict.Remove(fromToIKS);
        }

        //Dictに入れるTweener生成
        Tweener tmpLAIKSHeadTweener = null;
        //Dictに追加
        LAIKSHeadTweenerDict.Add(fromToIKS, tmpLAIKSHeadTweener);

        //Dictに入れたTweenerの内容を設定
        LAIKSHeadTweenerDict[fromToIKS] = DOTween.To(() => fromToIKS.headWeight, (x) => fromToIKS.headWeight = x
        , value
        , time)
        .SetEase(ease)
        .OnComplete(() => { LAIKSHeadTweenerDict.Remove(fromToIKS); }//Tween終了したらDictから該当のIKEf項目を自動削除
        );

        if (value == 0) { StartCoroutine(DOTweenToZeroIKRemove(fromToIKS, null, time)); }
    }

    Dictionary<IKSolverLookAt, Tweener> LAIKSEyesTweenerDict = new Dictionary<IKSolverLookAt, Tweener>();
    public void DOTweenToLAIKSEyes(IKSolverLookAt fromToIKS, float value, float time, Ease ease = Ease.OutQuad)
    {
        if (LAIKSEyesTweenerDict.ContainsKey(fromToIKS) == true)//既にDictに動作中の今回のIKEfがあれば
        {
            //削除
            LAIKSEyesTweenerDict[fromToIKS].Kill();
            LAIKSEyesTweenerDict.Remove(fromToIKS);
        }

        //Dictに入れるTweener生成
        Tweener tmpLAIKSEyesTweener = null;
        //Dictに追加
        LAIKSEyesTweenerDict.Add(fromToIKS, tmpLAIKSEyesTweener);

        //Dictに入れたTweenerの内容を設定
        LAIKSEyesTweenerDict[fromToIKS] = DOTween.To(() => fromToIKS.eyesWeight, (x) => fromToIKS.eyesWeight = x
        , value
        , time)
        .SetEase(ease)
        .OnComplete(() => { LAIKSEyesTweenerDict.Remove(fromToIKS); }//Tween終了したらDictから該当のIKEf項目を自動削除
        );

        if (value == 0) { StartCoroutine(DOTweenToZeroIKRemove(fromToIKS, null, time)); }
    }

    Dictionary<IKSolverLookAt, Tweener> LAIKSBodyTweenerDict = new Dictionary<IKSolverLookAt, Tweener>();
    void DOTweenToLAIKSBody(IKSolverLookAt fromToIKS, float value, float time, Ease ease = Ease.OutQuad)
    {
        if (LAIKSBodyTweenerDict.ContainsKey(fromToIKS) == true)//既にDictに動作中の今回のIKEfがあれば
        {
            //削除
            LAIKSBodyTweenerDict[fromToIKS].Kill();
            LAIKSBodyTweenerDict.Remove(fromToIKS);
        }

        //Dictに入れるTweener生成
        Tweener tmpLAIKSBodyTweener = null;
        //Dictに追加
        LAIKSBodyTweenerDict.Add(fromToIKS, tmpLAIKSBodyTweener);

        //Dictに入れたTweenerの内容を設定
        LAIKSBodyTweenerDict[fromToIKS] = DOTween.To(() => fromToIKS.bodyWeight, (x) => fromToIKS.bodyWeight = x
        , value
        , time)
        .SetEase(ease)
        .OnComplete(() => { LAIKSBodyTweenerDict.Remove(fromToIKS); }//Tween終了したらDictから該当のIKEf項目を自動削除
        );

        //0にする場合、FollowDOMoveがあったら自動で消す
        if (value == 0) { StartCoroutine(DOTweenToZeroIKRemove(fromToIKS, null, time)); }
    }

    //IKウェイトを0にした時、そのIKTargetがFollowDOMoveしていたら消す(RotationはMoveしないのでなし)
    IEnumerator DOTweenToZeroIKRemove(IKSolverLookAt fromToIKS, IKEffector fromToIKEf, float time)
    {
        //0になるまでの時間+0.1待った後
        yield return new WaitForSeconds(time + 0.1f);
        //ほんとにウェイト0になってるか（途中で別命令等でウェイト増えてないか）確認してから消す
        if (fromToIKS == LAIKHeadS) { if (LAIKHeadS.headWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLookAtHeadTargetTrs); } }
        else if (fromToIKS == LAIKEyeS) { if (LAIKEyeS.eyesWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLookAtEyeTargetTrs); } }
        else if (fromToIKS == LAIKBodyS) { if (LAIKBodyS.bodyWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLookAtBodyTargetTrs); } }

        else if (fromToIKEf == IKBodyEf) { if (IKBodyEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKBodyTargetTrs); } }
        else if (fromToIKEf == IKLHandEf) { if (IKLHandEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLHandTargetTrs); } }
        else if (fromToIKEf == IKLShoulderEf) { if (IKLShoulderEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLShoulderTargetTrs); } }
        else if (fromToIKEf == IKRHandEf) { if (IKRHandEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKRHandTargetTrs); } }
        else if (fromToIKEf == IKRShoulderEf) { if (IKRShoulderEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKRShoulderTargetTrs); } }
        else if (fromToIKEf == IKLFootEf) { if (IKLFootEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLFootTargetTrs); } }
        else if (fromToIKEf == IKLThighEf) { if (IKLThighEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKLThighTargetTrs); } }
        else if (fromToIKEf == IKRFootEf) { if (IKRFootEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKRFootTargetTrs); } }
        else if (fromToIKEf == IKRThighEf) { if (IKRThighEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(IKRThighTargetTrs); } }

        //PlayerIK
        else if (fromToIKS == PlayerLAIKHeadS) { if (PlayerLAIKHeadS.headWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLookAtHeadTargetTrs); } }
        else if (fromToIKS == PlayerLAIKEyeS) { if (PlayerLAIKEyeS.eyesWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLookAtEyeTargetTrs); } }
        else if (fromToIKS == PlayerLAIKBodyS) { if (PlayerLAIKBodyS.bodyWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLookAtBodyTargetTrs); } }

        else if (fromToIKEf == PlayerIKBodyEf) { if (PlayerIKBodyEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKBodyTargetTrs); } }
        else if (fromToIKEf == PlayerIKLHandEf) { if (PlayerIKLHandEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLHandTargetTrs); } }
        else if (fromToIKEf == PlayerIKLShoulderEf) { if (PlayerIKLShoulderEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLShoulderTargetTrs); } }
        else if (fromToIKEf == PlayerIKRHandEf) { if (PlayerIKRHandEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKRHandTargetTrs); } }
        else if (fromToIKEf == PlayerIKRShoulderEf) { if (PlayerIKRShoulderEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKRShoulderTargetTrs); } }
        else if (fromToIKEf == PlayerIKLFootEf) { if (PlayerIKLFootEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLFootTargetTrs); } }
        else if (fromToIKEf == PlayerIKLThighEf) { if (PlayerIKLThighEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKLThighTargetTrs); } }
        else if (fromToIKEf == PlayerIKRFootEf) { if (PlayerIKRFootEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKRFootTargetTrs); } }
        else if (fromToIKEf == PlayerIKRThighEf) { if (PlayerIKRThighEf.positionWeight == 0) { FollowDOMoveFromTrsList.Remove(PlayerIKRThighTargetTrs); } }
    }
    #endregion
    #endregion

    #region novel serihu 変数置換

    void StringVarChange(ref string str)
    {
        str = str.Replace("#現身長#", nowPlayerSintyouFloat.ToString("f0")/*.ToUpper()*/);//ToUpperは全角化
        str = str.Replace("#エッフェルタイム#", eiffelClimgTime.ToString("f2"));

        #region 日本語
        //プレイヤー台詞などのカラー
        str = str.Replace("「", "#colorPlayer#「");
        str = str.Replace("」", "」</color>");
        //プレイヤー脳内台詞カラー
        str = str.Replace("（", "<color=#CADADAFF>（");
        str = str.Replace("）", "）</color>");

        //智恵理などのカラー
        str = str.Replace("ちえり", "#colorGirl#ちえり</color>");
        //メガネ のカラー
        str = str.Replace("メガネ", "#colorMegane#メガネ</color>");

        //ポニーのカラー
        str = str.Replace("＜", "#colorPony#＜");
        str = str.Replace("＞", "＞</color>");
        str = str.Replace("ぬいぐるみ", "#colorPony#ぬいぐるみ</color>");


        #endregion

        #region 英語

        //プレイヤー台詞などのカラー
        str = str.Replace("“", "#colorPlayer#“");
        str = str.Replace("”", "”</color>");
        //プレイヤー脳内台詞カラーは日本語と一緒

        //智恵理などのカラー
        str = str.Replace("Chieri", "#colorGirl#Chieri</color>");
        //メガネ のカラー
        str = str.Replace("glasses", "#colorMegane#glasses</color>");

        //ポニーのカラー
        str = str.Replace("＜", "#colorPony#＜");
        str = str.Replace("＞", "＞</color>");
        str = str.Replace("plushie", "#colorPony#plushie</color>");

        #endregion

        //カラー変数を色コードに書き換え
        str = str.Replace("#colorPlayer#", "<color=#D0FFFFFF>");
        str = str.Replace("#colorGirl#", "<color=#FFD6FFFF>");
        str = str.Replace("#colorMegane#", "<color=#ABEAA9FF>");
        str = str.Replace("#colorPony#", "<color=#50FFDAFF>");//前は50DADAFF
    }
    #endregion

    #region セーブ関連のコルーチンメソッド群
    //暗号化したければここを参照
    //http://magnaga.com/unity/2016/01/11/unity-save/

    bool
        isNowSaveLoading = false;

    IEnumerator SaveUserData()
    {
        isNowSaveLoading = true;


        if (DB.isEnglish)
        { SubTitleVis(true, "Now saving", 0.2f); }
        else
        { SubTitleVis(true, "セーブ中", 0.2f); }

        Save();

        if (DB.isSaveDataLoad)//既にセーブデータ読み書きしていた
        {
            if (DB.isEnglish)
            { SubTitleVis(true, "Save complete", 0.2f); }
            else
            { SubTitleVis(true, "セーブ完了", 0.2f); }
        }
        else //していなかった（デバッグプレイ中と思われる）
        {
            if (DB.isEnglish)
            { SubTitleVis(true, "New save data created successfully", 0.2f); }
            else
            { SubTitleVis(true, "新規セーブデータ作成完了", 0.2f); }
        }

        DB.isSaveDataLoad = true;

        yield return new WaitForSecondsRealtime(1);
        SubTitleVis(false, 1f);

        yield return null;
        isNowSaveLoading = false;
    }

    IEnumerator LoadUserData()
    {
        isNowSaveLoading = true;

        if (DB.isEnglish)
        { SubTitleVis(true, "Confirming save data", 0.2f); }
        else
        { SubTitleVis(true, "セーブデータ確認中", 0.2f); }

        //セーブデータがあれば
        if (File.Exists(Application.streamingAssetsPath + "/savedata.json"))
        {
            using (StreamReader sr = new StreamReader(Application.streamingAssetsPath + "/savedata.json"
                , Encoding.GetEncoding("utf-8")))
            {
                if (DB.saveDataDict != null)
                {
                    var sDict = JsonUtility.FromJson<Serialization<string, string>>(sr.ReadToEnd());
                    sDict.OnAfterDeserialize();
                    DB.saveDataDict = sDict.ToDictionary();
                }
            }

            #region ■■ロード処理
            DB.isUserInitialSetting = DB.saveDataDict[nameof(DB.isUserInitialSetting)] == "True" ? true : false;
            DB.isUserContinue = DB.saveDataDict[nameof(DB.isUserContinue)] == "True" ? true : false;

            DB.isEnglish = DB.saveDataDict[nameof(DB.isEnglish)] == "True" ? true : false;
            DB.storyLoopCountInt = int.Parse(DB.saveDataDict[nameof(DB.storyLoopCountInt)]);

            //メニュー系
            DB.userMasterVolume = float.Parse(DB.saveDataDict[nameof(DB.userMasterVolume)]);
            DB.userBGMVolume = float.Parse(DB.saveDataDict[nameof(DB.userBGMVolume)]);
            DB.userSEVolume = float.Parse(DB.saveDataDict[nameof(DB.userSEVolume)]);
            DB.userMouseCameraSensitivityFlt = float.Parse(DB.saveDataDict[nameof(DB.userMouseCameraSensitivityFlt)]);
            DB.userStickCameraSensitivity = float.Parse(DB.saveDataDict[nameof(DB.userStickCameraSensitivity)]);
            DB.isUserFixityMakotoHeightVis = DB.saveDataDict[nameof(DB.isUserFixityMakotoHeightVis)] == "True" ? true : false;

            DB.isUserAntialiasing = DB.saveDataDict[nameof(DB.isUserAntialiasing)] == "True" ? true : false;
            DB.isUserAmbientOcclusion = DB.saveDataDict[nameof(DB.isUserAmbientOcclusion)] == "True" ? true : false;
            DB.isUserBloom = DB.saveDataDict[nameof(DB.isUserBloom)] == "True" ? true : false;
            DB.isUserDepthOfFieldV1 = DB.saveDataDict[nameof(DB.isUserDepthOfFieldV1)] == "True" ? true : false;
            DB.isUserDepthOfFieldV2 = DB.saveDataDict[nameof(DB.isUserDepthOfFieldV2)] == "True" ? true : false;
            DB.isUserFog = DB.saveDataDict[nameof(DB.isUserFog)] == "True" ? true : false;
            DB.isUserTPSMode = DB.saveDataDict[nameof(DB.isUserTPSMode)] == "True" ? true : false;
            DB.userDepthOfFieldV1Float = float.Parse(DB.saveDataDict[nameof(DB.userDepthOfFieldV1Float)]);
            DB.userDepthOfFieldV2Float = float.Parse(DB.saveDataDict[nameof(DB.userDepthOfFieldV2Float)]);
            DB.userFieldOfViewFloat = float.Parse(DB.saveDataDict[nameof(DB.userFieldOfViewFloat)]);
            DB.isUserVRUpDownRotate = DB.saveDataDict[nameof(DB.isUserVRUpDownRotate)] == "True" ? true : false;
            DB.isUserVRSmoothRotate = DB.saveDataDict[nameof(DB.isUserVRSmoothRotate)] == "True" ? true : false;

            DB.isUserFixityOutfit = DB.saveDataDict[nameof(DB.isUserFixityOutfit)] == "True" ? true : false;
            DB.isUserClothsBarefoot = DB.saveDataDict[nameof(DB.isUserClothsBarefoot)] == "True" ? true : false;
            DB.isUserClothsTankTop = DB.saveDataDict[nameof(DB.isUserClothsTankTop)] == "True" ? true : false;

            //アンロック系
            DB.isUserInfoVisMakotoHeightUnlock = DB.saveDataDict[nameof(DB.isUserInfoVisMakotoHeightUnlock)] == "True" ? true : false;

            #region 反映
            //音
            audioMixer.SetFloat("MasterVol", (volumeCurve.Evaluate(DB.userMasterVolume / 80) * 80) - 80);
            audioMixer.SetFloat("BGMVol", (volumeCurve.Evaluate(DB.userBGMVolume / 80) * 80) - 80);
            audioMixer.SetFloat("SEVol", (volumeCurve.Evaluate(DB.userSEVolume / 80) * 80) - 80);

            //ポストプロセス
            PPUserLoad();

            #region TPSモードBool読み取って起動
            if (DB.isUserTPSMode)
            {
                //TPSCameraシステム起動
                StartCoroutine(TPSCameraSystemIEnum());
            }
            else //オフの場合はTPSMode=0と同じ処理
            {
                TPSCamera.enabled = false;
                //VR時はカメラリセット挟む
                if (XRSettings.enabled) { CameraReset(); }

                //FreeCamera時はFreeCameraのONOFF
                if (isFreeCameraModeSystem) { FreeCamera.enabled = true; }
                else { VRCamera.enabled = true; }
                //モデル非表示
                if (isDummyBodyVis == false) { Dummy_Body.SetActive(false); }
                if (isANSystem == false)
                { if (isDummyHandVis == false) { Dummy_Hand.SetActive(false); } }


            }
            #endregion


            #endregion


            #endregion

            #region ■■新規ロード処理（互換性を持たせるため、そのデータが無ければデフォルトを入れていくタイプ）

            #region メニュー ビキニ
            //セーブデータにフラグ存在していなかったら（旧セーブデータと思われる）
            if (DB.saveDataDict.ContainsKey(nameof(DB.isUserClothsBikini)) == false)
            {
                //フラグデータ追加(セーブと同じ)
                DB.saveDataDict.Add(nameof(DB.isUserClothsBikini), DB.isUserClothsBikini.ToString());
                Debug.Log("フラグ旧データ状態だったので新フラグデータをセーブに追加した(ビキニ)");
            }
            #endregion

            #region フローチャートコマデータ読み込み

            for (int i = 0; i < flowChartKomaDataObjList.Count; i++)
            {
                var tmpKomaData = flowChartKomaDataObjList[i].GetComponent<FlowChartKoma>();

                #region セーブデータにコマデータがなかったら追加（新イベントコマデータがない旧セーブと思われる）
                if (DB.saveDataDict.ContainsKey("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerVisFlag))
                    == false)
                {
                    Debug.Log("旧セーブデータ");

                    //追加処理（セーブと同じ）
                    //isPlayerVis
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerVisFlag)
                        , tmpKomaData.isPlayerVisFlag.ToString());

                    //isHintVis
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isHintVisFlag)
                        , tmpKomaData.isHintVisFlag.ToString());

                    //isPlayerChoice
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerChoice)
                        , tmpKomaData.isPlayerChoice.ToString());

                    //badEndList
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.badEndList)
                        , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.badEndList)));

                    //sentakushiTitleList
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushiTitleList)
                        , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.sentakushiTitleList)));

                    //sentakushisList
                    DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushisList)
                        , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.sentakushisList)));

                }

                #endregion

                //isPlayerVis
                tmpKomaData.isPlayerVisFlag
                    = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerVisFlag)]
                    == "True" ? true : false;

                //isHintVis
                tmpKomaData.isHintVisFlag
                    = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isHintVisFlag)]
                    == "True" ? true : false;

                //isPlayerChoice
                tmpKomaData.isPlayerChoice
                    = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerChoice)]
                    == "True" ? true : false;

                //badEndList
                string jsonBadEndList = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.badEndList)];
                Serialization<string> deserializeBadEndList = JsonUtility.FromJson<Serialization<string>>(jsonBadEndList);
                tmpKomaData.badEndList = new List<string>(deserializeBadEndList.ToList());

                //badEndList
                string jsonSentakushiTitleList = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushiTitleList)];
                Serialization<string> deserializeSentakushiTitleList = JsonUtility.FromJson<Serialization<string>>(jsonSentakushiTitleList);
                tmpKomaData.sentakushiTitleList = new List<string>(deserializeSentakushiTitleList.ToList());

                //badEndList
                string jsonSentakushisList = DB.saveDataDict["Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushisList)];
                Serialization<string> deserializeSentakushisList = JsonUtility.FromJson<Serialization<string>>(jsonSentakushisList);
                tmpKomaData.sentakushisList = new List<string>(deserializeSentakushisList.ToList());

            }

            #endregion

            #region StaticFlagDict（Dictで追加していくセーブ可能フラグ）

            //フラグデータ読み込み
            for (int f = 0; f < staticFlagDict.Count; f++)
            {
                //セーブデータにフラグ存在していなかったら（旧セーブデータと思われる）
                if (DB.saveDataDict.ContainsKey(staticFlagDict[f].Key) == false)
                {
                    //フラグデータ追加(セーブと同じ)                                      （↓混乱注意　DictからValueを取り出すにはKey名が必要 forでインデックス番号でKey名を呼び出している）
                    DB.saveDataDict.Add(staticFlagDict[f].Key, staticFlagDict[staticFlagDict[f].Key].ToString());
                    Debug.Log("フラグ旧データ状態だったので新フラグデータをセーブに追加した");
                }

                //キー名で呼び出して書き込み（↓混乱注意　DictからValueを取り出すにはKey名が必要 forでインデックス番号でKey名を呼び出している）
                staticFlagDict[staticFlagDict[f].Key]
                    = DB.saveDataDict[staticFlagDict[f].Key] == "True" ? true : false;

            }


            #endregion

            #endregion

            if (DB.isEnglish)
            { SubTitleVis(true, "Sava data loaded successfully.", 0.2f, true); }
            else
            { SubTitleVis(true, "セーブデータロード完了しました", 0.2f, true); }

        }
        //なければ現在状態でセーブデータ生成
        else
        {
            //セーブデータなかった場合、イベントナンバーを最初に
            for (int i = 0; i < evs.Count; i++)
            {
                //上から順にイベント名と一致するか調べて、一致したらそのインデックス番号をセーブデータに代入
                if (evs.Skip(i).First().Key == "入室")
                { Save(i); }
            }

            if (DB.isEnglish)
            { SubTitleVis(true, "New save data created successfully", 0.2f, true, 1); }
            else
            { SubTitleVis(true, "セーブデータを新規作成しました", 0.2f, true, 1); }

        }

        DB.isSaveDataLoad = true;

        yield return new WaitForSecondsRealtime(1);

        yield return null;
        isNowSaveLoading = false;
    }

    void Save(int? eventNum = null)
    {
        #region イベントナンバー（指定なければ現在イベントナンバー）
        int tmpEvInt;

        //引数で指定あればそれを優先
        if (eventNum != null) { tmpEvInt = (int)eventNum; }
        else
        {
            //ロードシーンやタイトルなどの場合は現在セーブデータのナンバーに
            if (DB.nowEventNum <= 3)
            {
                tmpEvInt = int.Parse(DB.saveDataDict[nameof(DB.nowEventNum)]);
            }
            //どれでもなかったら現在イベントナンバー
            else
            {
                tmpEvInt = DB.nowEventNum;
            }
        }




        イベントナンバー設定完了:
        #endregion

        #region 現在状態でセーブ処理
        DB.saveDataDict.Clear();

        //初期設定とコンティニューBool
        DB.saveDataDict.Add(nameof(DB.isUserInitialSetting), DB.isUserInitialSetting.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserContinue), DB.isUserContinue.ToString());

        DB.saveDataDict.Add(nameof(DB.nowEventNum), tmpEvInt.ToString());
        DB.saveDataDict.Add(nameof(DB.isEnglish), DB.isEnglish.ToString());
        DB.saveDataDict.Add(nameof(DB.storyLoopCountInt), DB.storyLoopCountInt.ToString());

        //■メニュー系
        DB.saveDataDict.Add(nameof(DB.userMasterVolume), DB.userMasterVolume.ToString());
        DB.saveDataDict.Add(nameof(DB.userBGMVolume), DB.userBGMVolume.ToString());
        DB.saveDataDict.Add(nameof(DB.userSEVolume), DB.userSEVolume.ToString());
        DB.saveDataDict.Add(nameof(DB.userMouseCameraSensitivityFlt), DB.userMouseCameraSensitivityFlt.ToString());
        DB.saveDataDict.Add(nameof(DB.userStickCameraSensitivity), DB.userStickCameraSensitivity.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserFixityMakotoHeightVis), DB.isUserFixityMakotoHeightVis.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserAntialiasing), DB.isUserAntialiasing.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserAmbientOcclusion), DB.isUserAmbientOcclusion.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserBloom), DB.isUserBloom.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserDepthOfFieldV1), DB.isUserDepthOfFieldV1.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserDepthOfFieldV2), DB.isUserDepthOfFieldV2.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserFog), DB.isUserFog.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserTPSMode), DB.isUserTPSMode.ToString());
        DB.saveDataDict.Add(nameof(DB.userDepthOfFieldV1Float), DB.userDepthOfFieldV1Float.ToString());
        DB.saveDataDict.Add(nameof(DB.userDepthOfFieldV2Float), DB.userDepthOfFieldV2Float.ToString());
        DB.saveDataDict.Add(nameof(DB.userFieldOfViewFloat), DB.userFieldOfViewFloat.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserVRUpDownRotate), DB.isUserVRUpDownRotate.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserVRSmoothRotate), DB.isUserVRSmoothRotate.ToString());
        //着替え
        DB.saveDataDict.Add(nameof(DB.isUserFixityOutfit), DB.isUserFixityOutfit.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserClothsBarefoot), DB.isUserClothsBarefoot.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserClothsTankTop), DB.isUserClothsTankTop.ToString());
        DB.saveDataDict.Add(nameof(DB.isUserClothsBikini), DB.isUserClothsBikini.ToString());

        //アンロック系
        DB.saveDataDict.Add(nameof(DB.isUserInfoVisMakotoHeightUnlock), DB.isUserInfoVisMakotoHeightUnlock.ToString());

        #region フローチャートコマデータ保存
        for (int i = 0; i < flowChartKomaDataObjList.Count; i++)
        {
            var tmpKomaData = flowChartKomaDataObjList[i].GetComponent<FlowChartKoma>();

            //isPlayerVis
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerVisFlag)
                , tmpKomaData.isPlayerVisFlag.ToString());

            //isHintVis
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isHintVisFlag)
                , tmpKomaData.isHintVisFlag.ToString());

            //isPlayerChoice
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.isPlayerChoice)
                , tmpKomaData.isPlayerChoice.ToString());

            //badEndList
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.badEndList)
                , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.badEndList)));

            //sentakushiTitleList
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushiTitleList)
                , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.sentakushiTitleList)));

            //sentakushisList
            DB.saveDataDict.Add("Koma" + tmpKomaData.staticSerialNumber + nameof(FlowChartKoma.sentakushisList)
                , JsonUtility.ToJson(new Serialization<string>(tmpKomaData.sentakushisList)));

        }
        #endregion

        #region StaticFlagDict（Dictで追加していくセーブ可能フラグ）
        //フラグデータ読み込み
        for (int f = 0; f < staticFlagDict.Count; f++)
        {
            //フラグデータ追加                                                （↓混乱注意　DictからValueを取り出すにはKey名が必要 forでインデックス番号でKey名を呼び出している）
            DB.saveDataDict.Add(staticFlagDict[f].Key, staticFlagDict[staticFlagDict[f].Key].ToString());
        }


        #endregion


        DB.saveDataDict.Add("テスト", "おにぎり");



        //セーブデータテストごとに作らない用if判定
        if (DB.isSaveDataCreate)
        {
            using (StreamWriter
                writer = new StreamWriter(Application.streamingAssetsPath + "/savedata.json"
                , false
                , Encoding.GetEncoding("utf-8")))
            {
                var serialDict = new Serialization<string, string>(DB.saveDataDict);
                serialDict.OnBeforeSerialize();
                string dictJsonString = JsonUtility.ToJson(serialDict);
                writer.WriteLine(dictJsonString);
            }
        }

        #endregion

    }

    #region Serialization Class(jsonはDictionaryが使えないので手動でシリアライズする必要がある とのこと(でも単純にstringのList入れてもダメだった))

    // List<T>
    [Serializable]
    private class Serialization<T>
    {
        public List<T> target;

        public List<T> ToList()
        {
            return target;
        }

        public Serialization()
        {
        }

        public Serialization(List<T> target)
        {
            this.target = target;
        }
    }
    // Dictionary<TKey, TValue>
    [Serializable]
    private class Serialization<TKey, TValue>
    {
        public List<TKey> keys;
        public List<TValue> values;
        private Dictionary<TKey, TValue> target;

        public Dictionary<TKey, TValue> ToDictionary()
        {
            return target;
        }

        public Serialization()
        {
        }

        public Serialization(Dictionary<TKey, TValue> target)
        {
            this.target = target;
        }

        public void OnBeforeSerialize()
        {
            keys = new List<TKey>(target.Keys);
            values = new List<TValue>(target.Values);
        }

        public void OnAfterDeserialize()
        {
            int count = Math.Min(keys.Count, values.Count);
            target = new Dictionary<TKey, TValue>(count);
            Enumerable.Range(0, count).ToList().ForEach(i => target.Add(keys[i], values[i]));
        }
    }

    #endregion


    #endregion

    #endregion

    #region//エディターメソッドテスト
    public void EdTest()
    {
        Debug.Log("まも");

        girlAnim.Play("座り待機", 0);//デバッグ用アニメ直接再生


        StartCoroutine(testes());
    }
    //結局1フレームしか動かせないっぽいので無理？
    IEnumerator testes()
    {
        Debug.Log("みも");
        yield return new WaitForSecondsRealtime(0.01f);

        Debug.Log("むも");
    }
    #endregion
}

#region//TIPS

//モーションのフレームを0~1で指定
//anim.ForceStateNormalizedTime(0f);

/*アニメーションブレンド例
if (storyPrevTimer < 8 && storyTimer >= 8)
{
anim.SetTrigger("anim01Trigger");
hyouzyou.SetBlendShapeWeight(0, 100);
}
*/

/*//アニメーション直接指定例
if (storyPrevTimer < 8 && storyTimer >= 8)
{
    anim.Play("28-29");
}
*/

/*表情（まつげ）ウェイト設定例
if (storyTimer > 13 && storyTimer < 20)
{
    matsugeWeight -= 0.1f;
    hyouzyou.SetBlendShapeWeight(0, matsugeWeight);
}
*/

#region //*アニメーターのステート名一覧表示
/*
var ac = anim.runtimeAnimatorController as UnityEditor.Animations.AnimatorController;

int layer_num = 0;
foreach (UnityEditor.Animations.AnimatorControllerLayer layer in ac.layers)
{

    foreach (UnityEditor.Animations.ChildAnimatorState childAS in ac.layers[layer_num].stateMachine.states)
    {
        Debug.Log(layer.name + childAS.state.name);
    }

    layer_num++;
}
*/
#endregion


/* //画面4隅取得用
public Vector3 lb, rt, lt, rb;
public Transform center; // 四隅の深さを設定する用のオブジェクト
*/

//ビューポート上の座標の取り方
//mainCamera.WorldToViewportPoint(DC.mouthTargetObj.transform.position)
//
//    //口（くち）の画面上の位置取得
//Vector3 mouthViewPoint = mainCamera.WorldToViewportPoint(DC.HeadSphere.transform.position);

//        //口（DC.mouthTargetObj）が画面範囲外ならfalse
//        if (mouthViewPoint.x > 0.7 || mouthViewPoint.y > 0.7 ||
//            mouthViewPoint.x< 0.3 || mouthViewPoint.y< 0.3)
//        {
//            viewMouthBool = false;
//        }
//        else
//        {
//            viewMouthBool = true;
//        }

/*■■■■■■フキダシold　カメラから見える4隅の座標を取って、それを制限範囲にしようとした　けど、上の方が楽

var distance = Vector3.Distance(mainCamera.transform.position, disCube.transform.position);
lb = mainCamera.ViewportToWorldPoint(new Vector3(0, 0, distance));
rt = mainCamera.ViewportToWorldPoint(new Vector3(1, 1, distance));
lt = new Vector3(lb.x, rt.y, lb.z);
rb = new Vector3(rt.x, lb.y, rt.z);

hukiPos.x = Mathf.Clamp(hukiPos.x, lt.x, rt.x);
hukiPos.y = Mathf.Clamp(hukiPos.y, lb.y, lt.y);
hukiPos.z = Mathf.Clamp(hukiPos.z, mainCamera.transform.position.z, disCube.transform.position.z);
hukiPos = Vector3.Lerp(hukiPos, hukiTarget.transform.position, 0.01f);

DebugPanel.Log("lt", "pos", lt);
DebugPanel.Log("rt", "pos", rt);
DebugPanel.Log("lb", "pos", lb);
DebugPanel.Log("rb", "pos", rb);

hukiOyaTra.LookAt(cameraObj.transform);
hukidasi.transform.position = hukiPos;

}
void OnDrawGizmos()
{
 Gizmos.DrawSphere(lb, 0.3f);
 Gizmos.DrawSphere(rt, 0.3f);
 Gizmos.DrawSphere(rb, 0.3f);
 Gizmos.DrawSphere(lt, 0.3f);
}

void hukiMTW() メッシュ頂点をワールド座標に変換するものだが使わなくなった
{
hukiVec = new List<Vector3>();
//Listの「vec」に親のメッシュの頂点座標をワールドの位置に変換したものを入れる。Quadは最初の2個で最小XYと最大XYの頂点が出たので2回で済ませてる。
for (int i = 0; i < 2; i++)
{
    hukiVec.Add(hukiAreaMeshFilter.transform.localToWorldMatrix.MultiplyPoint(hukiAreaMeshFilter.mesh.vertices[i]));
}
}
*/
#region//画面4隅取得 一時未使用
/*
var distance = Vector3.Distance(Camera.transform.position, DC.mouthTargetObj.transform.position);
lb = mainCamera.ViewportToWorldPoint(new Vector3(0, 0, distance));
rt = mainCamera.ViewportToWorldPoint(new Vector3(1, 1, distance));
lt = new Vector3(lb.x, rt.y, lb.z);
rb = new Vector3(rt.x, lb.y, rt.z);
*/
#endregion

/* void OnDrawGizmos() //画面4隅ギズモ表示
{
 Gizmos.DrawSphere(lb, 0.3f);
 Gizmos.DrawSphere(rt, 0.3f);
 Gizmos.DrawSphere(rb, 0.3f);
 Gizmos.DrawSphere(lt, 0.3f);
}
*/


#endregion